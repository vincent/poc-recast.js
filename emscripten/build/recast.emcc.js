// Note: Some Emscripten settings will significantly limit the speed of the generated code.
// Note: Some Emscripten settings may limit the speed of the generated code.
// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = eval('(function() { try { return Module || {} } catch(e) { return {} } })()');
// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}
// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  Module['print'] = function(x) {
    process['stdout'].write(x + '\n');
  };
  Module['printErr'] = function(x) {
    process['stderr'].write(x + '\n');
  };
  var nodeFS = require('fs');
  var nodePath = require('path');
  Module['read'] = function(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };
  Module['readBinary'] = function(filename) { return Module['read'](filename, true) };
  Module['load'] = function(f) {
    globalEval(read(f));
  };
  Module['arguments'] = process['argv'].slice(2);
  module.exports = Module;
}
else if (ENVIRONMENT_IS_SHELL) {
  Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm
  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function() { throw 'no read() available (jsc?)' };
  }
  Module['readBinary'] = function(f) {
    return read(f, 'binary');
  };
  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }
  this['Module'] = Module;
}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };
  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }
  if (ENVIRONMENT_IS_WEB) {
    Module['print'] = function(x) {
      console.log(x);
    };
    Module['printErr'] = function(x) {
      console.log(x);
    };
    this['Module'] = Module;
  } else if (ENVIRONMENT_IS_WORKER) {
    // We can do very little here...
    var TRY_USE_DUMP = false;
    Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
    Module['load'] = importScripts;
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}
function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***
// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];
// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];
// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// === Auto-generated preamble library stuff ===
//========================================
// Runtime code shared with compiler
//========================================
var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      var logg = log2(quantum);
      return '((((' +target + ')+' + (quantum-1) + ')>>' + logg + ')<<' + logg + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (isArrayType(type)) return true;
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type, quantumSize) {
    if (Runtime.QUANTUM_SIZE == 1) return 1;
    var size = {
      '%i1': 1,
      '%i8': 1,
      '%i16': 2,
      '%i32': 4,
      '%i64': 8,
      "%float": 4,
      "%double": 8
    }['%'+type]; // add '%' since float and double confuse Closure compiler as keys, and also spidermonkey as a compiler will remove 's from '_i8' etc
    if (!size) {
      if (type.charAt(type.length-1) == '*') {
        size = Runtime.QUANTUM_SIZE; // A pointer
      } else if (type[0] == 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 == 0);
        size = bits/8;
      }
    }
    return size;
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  STACK_ALIGN: 8,
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (type == 'i64' || type == 'double' || vararg) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    var index = 0;
    type.flatIndexes = type.fields.map(function(field) {
      index++;
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = Runtime.getAlignSize(field, size);
      } else if (Runtime.isStructType(field)) {
        if (field[1] === '0') {
          // this is [0 x something]. When inside another structure like here, it must be at the end,
          // and it adds no size
          // XXX this happens in java-nbody for example... assert(index === type.fields.length, 'zero-length in the middle!');
          size = 0;
          alignSize = type.alignSize || QUANTUM_SIZE;
        } else {
          size = Types.types[field].flatSize;
          alignSize = Runtime.getAlignSize(null, Types.types[field].alignSize);
        }
      } else if (field[0] == 'b') {
        // bN, large number field, like a [N x i8]
        size = field.substr(1)|0;
        alignSize = 1;
      } else {
        throw 'Unclear type in struct: ' + field + ', in ' + type.name_ + ' :: ' + dump(Types.types[type.name_]);
      }
      if (type.packed) alignSize = 1;
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      assert(args.length == sig.length-1);
      return FUNCTION_TABLE[ptr].apply(null, args);
    } else {
      assert(sig.length == 1);
      return FUNCTION_TABLE[ptr]();
    }
  },
  addFunction: function (func) {
    var table = FUNCTION_TABLE;
    var ret = table.length;
    table.push(func);
    table.push(0);
    return ret;
  },
  removeFunction: function (index) {
    var table = FUNCTION_TABLE;
    table[index] = null;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xff;
      if (needed) {
        buffer.push(code);
        needed--;
      }
      if (buffer.length == 0) {
        if (code < 128) return String.fromCharCode(code);
        buffer.push(code);
        if (code > 191 && code < 224) {
          needed = 1;
        } else {
          needed = 2;
        }
        return '';
      }
      if (needed > 0) return '';
      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var ret;
      if (c1 > 191 && c1 < 224) {
        ret = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      } else {
        ret = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = ((((STACKTOP)+7)>>3)<<3);(assert((STACKTOP|0) < (STACK_MAX|0))|0); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + (assert(!staticSealed),size))|0;STATICTOP = ((((STATICTOP)+7)>>3)<<3); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + (assert(DYNAMICTOP > 0),size))|0;DYNAMICTOP = ((((DYNAMICTOP)+7)>>3)<<3); if (DYNAMICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 8))*(quantum ? quantum : 8); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? (((low)>>>(0))+(((high)>>>(0))*4294967296)) : (((low)>>>(0))+(((high)|(0))*4294967296))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}
//========================================
// Runtime essentials
//========================================
var __THREW__ = 0; // Used in checking for thrown exceptions.
var setjmpId = 1; // Used in setjmp/longjmp
var setjmpLabels = {};
var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;
var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}
var globalScope = this;
// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Closure can also do so. To avoid that, add your function to
//       the exports using something like
//
//         -s EXPORTED_FUNCTIONS='["_main", "_myfunc"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays; note that arrays are 8-bit).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;
// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = Module['_' + ident]; // closure exported function
    if (!func) func = eval('_' + ident); // explicit lookup
  } catch(e) {
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}
// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length+1);
      writeStringToMemory(value, ret);
      return ret;
    } else if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}
// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;
// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,Math.min(Math.floor((value)/4294967296), 4294967295)>>>0],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;
// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;
var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;
// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }
  var singleType = typeof types === 'string' ? types : null;
  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }
  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)|0)]=0;
    }
    return ret;
  }
  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }
  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];
    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }
    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');
    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later
    setValue(ret+i, curr, type);
    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }
  return ret;
}
Module['allocate'] = allocate;
function Pointer_stringify(ptr, /* optional */ length) {
  // Find the length, and check for UTF while doing so
  var hasUtf = false;
  var t;
  var i = 0;
  while (1) {
    assert(ptr + i < TOTAL_MEMORY);
    t = HEAPU8[(((ptr)+(i))|0)];
    if (t >= 128) hasUtf = true;
    else if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;
  var ret = '';
  if (!hasUtf) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  var utf8 = new Runtime.UTF8Processor();
  for (i = 0; i < length; i++) {
    assert(ptr + i < TOTAL_MEMORY);
    t = HEAPU8[(((ptr)+(i))|0)];
    ret += utf8.processCChar(t);
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;
// Memory management
var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return ((x+4095)>>12)<<12;
}
var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk
function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value, (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}
var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;
// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(!!Int32Array && !!Float64Array && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'Cannot fallback to non-typed array case: Code is too specialized');
var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);
// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');
Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;
function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited
var runtimeInitialized = false;
function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}
function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
}
function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}
function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;
function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;
function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;
function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;
function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;
// Tools
// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;
function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;
// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))|0)]=chr
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;
function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;
function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}
if (!Math['imul']) Math['imul'] = function(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyTracking = {};
var calledInit = false, calledRun = false;
var runDependencyWatcher = null;
function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 10000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    } 
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!calledRun && shouldRunNow) run();
  }
}
Module['removeRunDependency'] = removeRunDependency;
Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data
function loadMemoryInitializer(filename) {
  function applyData(data) {
    HEAPU8.set(data, STATIC_BASE);
  }
  // always do this asynchronously, to keep shell and web as similar as possible
  addOnPreRun(function() {
    if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
      applyData(Module['readBinary'](filename));
    } else {
      Browser.asyncLoad(filename, function(data) {
        applyData(data);
      }, function(data) {
        throw 'could not load memory initializer ' + filename;
      });
    }
  });
}
// === Body ===
STATIC_BASE = 8;
STATICTOP = STATIC_BASE + 8232;
/* global initializers */ __ATINIT__.push({ func: function() { runPostSets() } },{ func: function() { __GLOBAL__I_a() } },{ func: function() { __GLOBAL__I_a596() } },{ func: function() { __GLOBAL__I_a616() } });
var ___dso_handle;
var __ZTVN10__cxxabiv120__si_class_type_infoE;
var __ZTVN10__cxxabiv117__class_type_infoE;
var __ZTIt;
var __ZTIs;
var __ZTIm;
var __ZTIl;
var __ZTIj;
var __ZTIi;
var __ZTIh;
var __ZTIf;
var __ZTId;
var __ZTIc;
var __ZTIa;
__ZTVN10__cxxabiv120__si_class_type_infoE=allocate([0,0,0,0,80,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTVN10__cxxabiv117__class_type_infoE=allocate([0,0,0,0,96,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIt=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIs=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIm=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIl=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIj=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIi=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIh=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIf=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTId=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIc=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
__ZTIa=allocate([0,0,0,0,0,0,0,0], "i8", ALLOC_STATIC);
/* memory initializer */ allocate([0,0,64,64,0,0,0,0,0,0,128,63,0,0,0,0,0,0,128,63,0,0,0,0,0,0,72,66,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,65,0,0,0,0,0,0,0,0,0,0,0,0,205,204,204,62,0,0,0,0,205,204,76,62,0,0,0,0,10,215,35,60,0,0,0,0,0,0,0,63,0,0,0,0,0,0,0,63,0,0,0,0,10,215,35,60,0,0,0,0,74,0,0,0,0,0,0,0,108,111,110,103,0,0,0,0,98,117,105,108,100,80,111,108,121,68,101,116,97,105,108,58,32,67,111,117,108,100,32,110,111,116,32,116,114,105,97,110,103,117,108,97,116,101,32,112,111,108,121,103,111,110,44,32,97,100,100,105,110,103,32,100,101,102,97,117,108,116,32,100,97,116,97,46,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,116,114,105,115,39,32,40,37,100,41,46,0,0,0,0,0,103,101,116,77,97,120,84,105,108,101,115,0,0,0,0,0,115,101,116,95,100,101,116,97,105,108,83,97,109,112,108,101,77,97,120,69,114,114,111,114,0,0,0,0,0,0,0,0,115,101,116,95,100,101,116,97,105,108,83,97,109,112,108,101,68,105,115,116,0,0,0,0,115,101,116,95,118,101,114,116,115,80,101,114,80,111,108,121,0,0,0,0,0,0,0,0,115,101,116,95,101,100,103,101,77,97,120,69,114,114,111,114,0,0,0,0,0,0,0,0,117,110,115,105,103,110,101,100,32,105,110,116,0,0,0,0,115,101,116,95,101,100,103,101,77,97,120,76,101,110,0,0,115,101,116,95,114,101,103,105,111,110,77,101,114,103,101,83,105,122,101,0,0,0,0,0,115,101,116,95,114,101,103,105,111,110,77,105,110,83,105,122,101,0,0,0,0,0,0,0,115,101,116,95,97,103,101,110,116,77,97,120,83,108,111,112,101,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,105,110,100,105,99,101,115,39,32,40,37,100,41,46,0,0,115,101,116,95,97,103,101,110,116,77,97,120,67,108,105,109,98,0,0,0,0,0,0,0,115,101,116,95,97,103,101,110,116,82,97,100,105,117,115,0,115,101,116,95,97,103,101,110,116,72,101,105,103,104,116,0,115,101,116,95,99,101,108,108,72,101,105,103,104,116,0,0,109,95,104,101,97,112,0,0,115,101,116,95,99,101,108,108,83,105,122,101,0,0,0,0,105,116,101,114,97,116,101,79,110,78,97,118,77,101,115,104,0,0,0,0,0,0,0,0,105,110,116,0,0,0,0,0,98,97,114,101,71,101,111,109,86,97,108,105,100,97,116,101,0,0,0,0,0,0,0,0,98,97,114,101,71,101,111,109,65,100,100,84,114,105,97,110,103,108,101,0,0,0,0,0,98,97,114,101,71,101,111,109,65,100,100,86,101,114,116,101,120,0,0,0,0,0,0,0,46,46,47,115,114,99,95,99,112,112,47,68,101,116,111,117,114,47,83,111,117,114,99,101,47,68,101,116,111,117,114,78,111,100,101,46,99,112,112,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,110,101,119,116,39,32,40,37,100,41,46,0,0,0,0,0,0,0,98,97,114,101,71,101,111,109,73,110,105,116,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,102,105,114,115,116,86,101,114,116,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,98,117,105,108,100,0,0,0,105,110,105,116,87,105,116,104,70,105,108,101,0,0,0,0,105,110,105,116,0,0,0,0,109,95,110,97,118,77,101,115,104,61,37,112,32,10,0,0,67,111,117,108,100,32,110,111,116,32,105,110,105,116,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,32,113,117,101,114,121,0,0,0,0,0,73,110,105,116,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,46,32,37,112,32,10,0,0,0,0,0,0,0,67,111,117,108,100,32,110,111,116,32,105,110,105,116,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,0,0,0,117,110,115,105,103,110,101,100,32,115,104,111,114,116,0,0,67,114,101,97,116,101,100,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,46,32,37,112,32,10,0,0,0,0,67,111,117,108,100,32,110,111,116,32,99,114,101,97,116,101,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,0,66,117,105,108,116,32,68,101,116,111,117,114,32,110,97,118,100,97,116,97,46,32,37,112,32,10,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,110,101,119,118,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,110,101,120,116,86,101,114,116,39,32,40,37,100,41,46,0,67,111,117,108,100,32,110,111,116,32,98,117,105,108,100,32,68,101,116,111,117,114,32,110,97,118,109,101,115,104,46,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,70,97,105,108,101,100,32,116,111,32,109,101,114,103,101,32,99,111,110,116,111,117,114,115,32,37,100,32,97,110,100,32,37,100,46,0,0,0,0,71,101,116,32,78,97,118,77,101,115,104,67,114,101,97,116,101,80,97,114,97,109,115,32,37,112,32,10,0,0,0,0,37,117,32,112,111,108,121,32,97,114,101,97,115,32,10,0,118,111,105,100,0,0,0,0,67,114,101,97,116,101,32,100,101,116,97,105,108,32,109,101,115,104,46,32,10,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,98,117,105,108,100,32,100,101,116,97,105,108,32,109,101,115,104,46,0,0,0,109,95,102,105,114,115,116,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,109,100,116,108,39,46,0,66,117,105,108,100,32,112,111,108,121,103,111,110,115,32,109,101,115,104,32,102,114,111,109,32,99,111,110,116,111,117,114,115,46,32,10,0,0,0,0,115,104,111,114,116,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,116,114,105,97,110,103,117,108,97,116,101,32,99,111,110,116,111,117,114,115,46,0,0,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,109,101,115,104,39,46,0,84,114,97,99,101,32,97,110,100,32,115,105,109,112,108,105,102,121,32,114,101,103,105,111,110,32,99,111,110,116,111,117,114,115,58,32,37,117,32,99,111,110,116,115,32,40,109,97,120,83,105,109,112,108,105,102,105,99,97,116,105,111,110,69,114,114,111,114,61,32,37,102,44,32,109,97,120,69,100,103,101,76,101,110,61,32,37,117,41,10,0,0,0,0,0,0,102,105,108,116,101,114,83,109,97,108,108,82,101,103,105,111,110,115,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,114,101,103,105,111,110,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,100,109,101,115,104,46,116,114,105,115,39,32,40,37,100,41,46,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,109,101,115,104,46,97,114,101,97,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,99,114,101,97,116,101,32,99,111,110,116,111,117,114,115,46,0,0,0,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,70,97,105,108,101,100,32,116,111,32,102,105,110,100,32,109,101,114,103,101,32,112,111,105,110,116,115,32,102,111,114,32,37,100,32,97,110,100,32,37,100,46,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,99,115,101,116,39,46,0,0,80,97,114,116,105,116,105,111,110,32,119,97,108,107,97,98,108,101,32,115,117,114,102,97,99,101,32,10,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,98,117,105,108,100,32,100,105,115,116,97,110,99,101,32,102,105,101,108,100,46,0,0,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,98,117,105,108,100,32,114,101,103,105,111,110,115,46,0,0,0,0,0,0,0,109,95,110,101,120,116,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,101,114,111,100,101,46,0,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,98,117,105,108,100,32,99,111,109,112,97,99,116,32,100,97,116,97,46,0,0,99,97,110,82,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,101,100,103,101,115,39,32,40,37,100,41,46,0,0,0,0,117,110,115,105,103,110,101,100,32,99,104,97,114,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,99,104,102,39,46,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,84,111,111,32,109,97,110,121,32,112,111,108,121,103,111,110,115,32,37,100,32,40,109,97,120,58,37,100,41,46,0,0,0,0,102,105,108,116,101,114,115,32,10,0,0,0,0,0,0,0,37,117,32,87,97,108,107,97,98,108,101,32,84,114,105,97,110,103,108,101,115,10,0,0,114,99,66,117,105,108,100,82,101,103,105,111,110,115,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,116,109,112,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,114,101,103,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,100,109,101,115,104,46,118,101,114,116,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,109,101,115,104,46,114,101,103,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,67,111,117,108,100,32,110,111,116,32,102,105,110,100,32,109,101,114,103,101,32,116,97,114,103,101,116,32,102,111,114,32,98,97,100,32,99,111,110,116,111,117,114,32,37,100,46,0,0,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,111,108,121,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,72,101,105,103,104,116,102,105,101,108,100,32,112,111,108,121,103,111,110,32,115,111,117,112,32,10,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,116,114,105,97,110,103,117,108,97,116,101,40,41,32,114,101,116,117,114,110,101,100,32,98,97,100,32,114,101,115,117,108,116,115,46,0,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,99,114,101,97,116,101,32,115,111,108,105,100,32,104,101,105,103,104,116,102,105,101,108,100,46,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,99,114,101,97,116,101,32,115,111,108,105,100,32,104,101,105,103,104,116,102,105,101,108,100,46,32,10,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,116,118,101,114,116,115,39,32,40,37,100,41,46,0,0,0,0,0,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,115,111,108,105,100,39,46,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,116,114,105,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,109,95,110,111,100,101,115,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,115,111,108,105,100,39,46,32,10,0,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,104,97,114,101,97,39,32,40,37,100,41,46,0,0,0,0,0,0,0,66,117,105,108,100,105,110,103,32,110,97,118,105,103,97,116,105,111,110,32,10,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,104,114,101,103,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,115,105,103,110,101,100,32,99,104,97,114,0,0,0,0,0,32,45,32,37,46,49,102,75,32,118,101,114,116,115,44,32,37,46,49,102,75,32,116,114,105,115,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,104,111,108,101,39,32,40,37,100,41,46,0,0,0,0,0,0,0,0,32,45,32,37,100,32,120,32,37,100,32,99,101,108,108,115,0,0,0,0,0,0,0,0,114,101,109,111,118,101,86,101,114,116,101,120,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,101,100,103,101,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,66,117,105,108,100,105,110,103,32,110,97,118,105,103,97,116,105,111,110,58,0,0,0,0,98,117,105,108,100,84,105,108,101,100,78,97,118,105,103,97,116,105,111,110,58,32,70,97,105,108,101,100,32,116,111,32,98,117,105,108,100,32,99,104,117,110,107,121,32,109,101,115,104,46,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,100,109,101,115,104,46,109,101,115,104,101,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,68,105,115,116,97,110,99,101,70,105,101,108,100,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,115,114,99,39,32,40,37,100,41,46,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,109,101,115,104,46,112,111,108,121,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,101,115,101,116,84,105,109,101,114,115,32,10,0,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,114,118,101,114,116,115,39,32,40,37,100,41,46,0,0,0,114,99,66,117,105,108,100,67,111,109,112,97,99,116,72,101,105,103,104,116,102,105,101,108,100,58,32,72,101,105,103,104,116,102,105,101,108,100,32,104,97,115,32,116,111,111,32,109,97,110,121,32,108,97,121,101,114,115,32,37,100,32,40,109,97,120,58,32,37,100,41,0,98,117,105,108,100,78,97,118,105,103,97,116,105,111,110,58,32,73,110,112,117,116,32,109,101,115,104,32,105,115,32,110,111,116,32,115,112,101,99,105,102,105,101,100,46,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,98,111,117,110,100,115,39,32,40,37,100,41,46,0,0,0,0,0,99,97,110,110,111,116,32,108,111,97,100,32,79,66,74,32,102,105,108,101,32,10,0,0,47,109,101,115,104,101,115,47,110,97,118,95,116,101,115,116,46,111,98,106,0,0,0,0,108,111,97,100,105,110,103,32,102,114,111,109,32,102,105,108,101,0,0,0,0,0,0,0,109,95,109,97,120,78,111,100,101,115,32,62,32,48,0,0,119,105,110,100,111,119,46,111,98,106,101,99,116,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,84,111,111,32,109,97,110,121,32,118,101,114,116,105,99,101,115,32,37,100,46,0,0,115,99,101,110,101,46,97,100,100,40,119,105,110,100,111,119,46,111,98,106,101,99,116,41,59,0,0,0,0,0,0,0,99,104,97,114,0,0,0,0,47,42,32,119,105,110,100,111,119,46,111,98,106,101,99,116,46,112,111,115,105,116,105,111,110,46,115,101,116,40,32,37,117,44,32,37,117,44,32,37,117,32,41,59,32,32,42,47,32,119,105,110,100,111,119,46,111,98,106,101,99,116,46,115,99,97,108,101,46,115,101,116,40,32,110,101,119,32,84,72,82,69,69,46,86,101,99,116,111,114,51,40,32,37,102,44,32,37,102,44,32,37,102,32,41,32,41,59,32,32,0,0,119,105,110,100,111,119,46,111,98,106,101,99,116,32,61,32,110,101,119,32,84,72,82,69,69,46,77,101,115,104,40,110,101,119,32,84,72,82,69,69,46,67,111,110,118,101,120,71,101,111,109,101,116,114,121,40,119,105,110,100,111,119,46,112,111,105,110,116,115,41,44,32,119,105,110,100,111,119,46,109,97,116,101,114,105,97,108,115,41,59,0,0,0,0,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,102,108,97,103,115,39,32,40,37,100,41,46,0,0,0,0,101,114,111,100,101,87,97,108,107,97,98,108,101,65,114,101,97,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,100,105,115,116,39,32,40,37,100,41,46,0,0,0,119,105,110,100,111,119,46,112,111,105,110,116,115,46,108,101,110,103,116,104,44,32,39,32,112,111,105,110,116,115,39,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,104,112,46,100,97,116,97,39,32,40,37,100,41,46,0,0,0,0,114,99,66,117,105,108,100,67,111,109,112,97,99,116,72,101,105,103,104,116,102,105,101,108,100,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,99,104,102,46,99,101,108,108,115,39,32,40,37,100,41,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,109,101,115,104,46,118,101,114,116,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,119,105,110,100,111,119,46,112,111,105,110,116,115,46,112,117,115,104,40,110,101,119,32,84,72,82,69,69,46,86,101,99,116,111,114,51,40,37,102,44,32,37,102,44,32,37,102,41,41,59,0,0,0,0,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,118,101,114,116,115,39,32,40,37,100,41,46,0,0,0,0,114,99,66,117,105,108,100,67,111,109,112,97,99,116,72,101,105,103,104,116,102,105,101,108,100,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,99,104,102,46,97,114,101,97,115,39,32,40,37,100,41,0,0,0,0,0,0,0,118,105,32,61,32,123,32,120,58,37,117,44,32,121,58,37,117,44,32,122,58,37,117,32,125,0,0,0,0,0,0,0,119,105,110,100,111,119,46,112,111,105,110,116,115,32,61,32,91,93,59,0,0,0,0,0,119,105,110,100,111,119,46,109,97,116,101,114,105,97,108,115,32,61,32,91,32,110,101,119,32,84,72,82,69,69,46,77,101,115,104,80,104,111,110,103,77,97,116,101,114,105,97,108,40,123,32,99,111,108,111,114,58,48,120,102,102,56,56,56,56,44,32,97,109,98,105,101,110,116,58,32,48,120,102,102,56,56,56,56,44,32,115,105,100,101,58,84,72,82,69,69,46,68,111,117,98,108,101,83,105,100,101,44,32,119,105,114,101,102,114,97,109,101,58,116,114,117,101,32,125,41,32,93,59,0,0,0,0,0,0,0,110,118,112,61,37,117,44,32,99,115,61,37,102,44,32,99,104,61,37,102,44,32,111,114,105,103,61,37,102,0,0,0,99,108,101,97,110,117,112,32,10,0,0,0,0,0,0,0,100,116,78,101,120,116,80,111,119,50,40,109,95,104,97,115,104,83,105,122,101,41,32,61,61,32,40,117,110,115,105,103,110,101,100,32,105,110,116,41,109,95,104,97,115,104,83,105,122,101,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,84,104,101,32,114,101,115,117,108,116,105,110,103,32,109,101,115,104,32,104,97,115,32,116,111,111,32,109,97,110,121,32,112,111,108,121,103,111,110,115,32,37,100,32,40,109,97,120,32,37,100,41,46,32,68,97,116,97,32,99,97,110,32,98,101,32,99,111,114,114,117,112,116,101,100,46,0,0,0,101,109,115,99,114,105,112,116,101,110,58,58,109,101,109,111,114,121,95,118,105,101,119,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,84,104,101,32,114,101,115,117,108,116,105,110,103,32,109,101,115,104,32,104,97,115,32,116,111,111,32,109,97,110,121,32,118,101,114,116,105,99,101,115,32,37,100,32,40,109,97,120,32,37,100,41,46,32,68,97,116,97,32,99,97,110,32,98,101,32,99,111,114,114,117,112,116,101,100,46,0,0,0,98,111,111,108,0,0,0,0,101,109,115,99,114,105,112,116,101,110,58,58,118,97,108,0,99,111,110,115,111,108,101,46,108,111,103,40,37,115,41,59,0,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,109,101,115,104,46,102,108,97,103,115,39,32,40,37,100,41,46,0,0,0,0,0,0,0,115,116,100,58,58,119,115,116,114,105,110,103,0,0,0,0,99,111,110,115,111,108,101,46,108,111,103,40,39,37,115,39,41,59,0,0,0,0,0,0,114,98,0,0,0,0,0,0,37,100,32,118,101,114,116,115,32,32,32,37,100,32,116,114,105,115,10,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,65,100,106,97,99,101,110,99,121,32,102,97,105,108,101,100,46,0,0,0,0,0,0,115,116,100,58,58,115,116,114,105,110,103,0,0,0,0,0,37,102,32,37,102,32,37,102,0,0,0,0,0,0,0,0,98,117,105,108,100,84,105,108,101,100,78,97,118,105,103,97,116,105,111,110,58,32,67,111,117,108,100,32,110,111,116,32,108,111,97,100,32,39,37,115,39,0,0,0,0,0,0,0,108,111,97,100,77,101,115,104,58,32,70,97,105,108,101,100,32,116,111,32,108,111,97,100,32,39,109,95,109,101,115,104,39,46,0,0,0,0,0,0,114,99,66,117,105,108,100,68,105,115,116,97,110,99,101,70,105,101,108,100,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,100,115,116,39,32,40,37,100,41,46,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,70,97,105,108,101,100,32,116,111,32,114,101,109,111,118,101,32,101,100,103,101,32,118,101,114,116,101,120,32,37,100,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,111,108,121,39,32,40,37,100,41,46,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,118,102,108,97,103,115,39,32,40,37,100,41,46,0,0,0,100,111,117,98,108,101,0,0,114,99,66,117,105,108,100,67,111,110,116,111,117,114,115,58,32,69,120,112,97,110,100,105,110,103,32,109,97,120,32,99,111,110,116,111,117,114,115,32,102,114,111,109,32,37,100,32,116,111,32,37,100,46,0,0,97,100,100,69,100,103,101,58,32,84,111,111,32,109,97,110,121,32,101,100,103,101,115,32,40,37,100,47,37,100,41,46,0,0,0,0,0,0,0,0,114,99,66,117,105,108,100,67,111,109,112,97,99,116,72,101,105,103,104,116,102,105,101,108,100,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,99,104,102,46,115,112,97,110,115,39,32,40,37,100,41,0,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,84,111,111,32,109,97,110,121,32,112,111,108,121,103,111,110,115,32,37,100,32,40,109,97,120,58,37,100,41,46,0,102,108,111,97,116,0,0,0,100,101,108,97,117,110,97,121,72,117,108,108,58,32,82,101,109,111,118,105,110,103,32,100,97,110,103,108,105,110,103,32,102,97,99,101,32,37,100,32,91,37,100,44,37,100,44,37,100,93,46,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,66,97,100,32,116,114,105,97,110,103,117,108,97,116,105,111,110,32,67,111,110,116,111,117,114,32,37,100,46,0,0,117,110,115,105,103,110,101,100,32,108,111,110,103,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,68,101,116,97,105,108,58,32,83,104,114,105,110,107,105,110,103,32,116,114,105,97,110,103,108,101,32,99,111,117,110,116,32,102,114,111,109,32,37,100,32,116,111,32,109,97,120,32,37,100,46,0,0,0,0,0,0,114,99,66,117,105,108,100,80,111,108,121,77,101,115,104,58,32,79,117,116,32,111,102,32,109,101,109,111,114,121,32,39,112,111,108,121,115,39,32,40,37,100,41,46,0,0,0,0,100,116,78,111,100,101,81,117,101,117,101,58,58,100,116,78,111,100,101,81,117,101,117,101,40,105,110,116,41,0,0,0,100,116,78,111,100,101,80,111,111,108,58,58,100,116,78,111,100,101,80,111,111,108,40,105,110,116,44,32,105,110,116,41,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,255,255,255,255,1,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,255,255,255,255,1,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,255,255,255,255,1,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,216,28,0,0,110,0,0,0,14,0,0,0,30,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,29,0,0,48,0,0,0,16,0,0,0,70,0,0,0,100,0,0,0,38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,29,0,0,48,0,0,0,84,0,0,0,70,0,0,0,100,0,0,0,54,0,0,0,52,0,0,0,68,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,118,0,0,0,0,0,0,0,116,0,0,0,0,0,0,0,115,0,0,0,0,0,0,0,109,0,0,0,0,0,0,0,108,0,0,0,0,0,0,0,106,0,0,0,0,0,0,0,105,0,0,0,0,0,0,0,104,0,0,0,0,0,0,0,102,0,0,0,0,0,0,0,100,0,0,0,0,0,0,0,99,0,0,0,0,0,0,0,98,0,0,0,0,0,0,0,97,0,0,0,0,0,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,83,116,57,101,120,99,101,112,116,105,111,110,0,0,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,78,83,116,51,95,95,49,50,49,95,95,98,97,115,105,99,95,115,116,114,105,110,103,95,99,111,109,109,111,110,73,76,98,49,69,69,69,0,0,0,78,83,116,51,95,95,49,49,50,98,97,115,105,99,95,115,116,114,105,110,103,73,119,78,83,95,49,49,99,104,97,114,95,116,114,97,105,116,115,73,119,69,69,78,83,95,57,97,108,108,111,99,97,116,111,114,73,119,69,69,69,69,0,0,78,83,116,51,95,95,49,49,50,98,97,115,105,99,95,115,116,114,105,110,103,73,99,78,83,95,49,49,99,104,97,114,95,116,114,97,105,116,115,73,99,69,69,78,83,95,57,97,108,108,111,99,97,116,111,114,73,99,69,69,69,69,0,0,78,49,48,101,109,115,99,114,105,112,116,101,110,51,118,97,108,69,0,0,0,0,0,0,78,49,48,101,109,115,99,114,105,112,116,101,110,49,49,109,101,109,111,114,121,95,118,105,101,119,69,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,51,95,95,102,117,110,100,97,109,101,110,116,97,108,95,116,121,112,101,95,105,110,102,111,69,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,49,95,95,118,109,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,0,40,26,0,0,120,26,0,0,40,26,0,0,208,26,0,0,0,0,0,0,224,26,0,0,0,0,0,0,240,26,0,0,0,0,0,0,0,27,0,0,208,28,0,0,0,0,0,0,0,0,0,0,16,27,0,0,80,26,0,0,56,27,0,0,0,0,0,0,1,0,0,0,232,28,0,0,0,0,0,0,80,26,0,0,120,27,0,0,0,0,0,0,1,0,0,0,232,28,0,0,0,0,0,0,0,0,0,0,184,27,0,0,0,0,0,0,208,27,0,0,0,0,0,0,240,27,0,0,112,29,0,0,0,0,0,0,0,0,0,0,24,28,0,0,96,29,0,0,0,0,0,0,0,0,0,0,64,28,0,0,96,29,0,0,0,0,0,0,0,0,0,0,104,28,0,0,112,29,0,0,0,0,0,0,0,0,0,0,144,28,0,0,200,28,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE)
function runPostSets() {
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(8))>>2)]=(48);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(12))>>2)]=(94);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(16))>>2)]=(70);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(20))>>2)]=(100);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(24))>>2)]=(54);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(28))>>2)]=(10);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(32))>>2)]=(32);
HEAP32[(((__ZTVN10__cxxabiv120__si_class_type_infoE)+(36))>>2)]=(112);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(8))>>2)]=(48);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(12))>>2)]=(20);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(16))>>2)]=(70);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(20))>>2)]=(100);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(24))>>2)]=(54);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(28))>>2)]=(56);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(32))>>2)]=(58);
HEAP32[(((__ZTVN10__cxxabiv117__class_type_infoE)+(36))>>2)]=(108);
HEAP32[((__ZTIt)>>2)]=(((6696)|0));
HEAP32[(((__ZTIt)+(4))>>2)]=((6784)|0);
HEAP32[((__ZTIs)>>2)]=(((6696)|0));
HEAP32[(((__ZTIs)+(4))>>2)]=((6792)|0);
HEAP32[((__ZTIm)>>2)]=(((6696)|0));
HEAP32[(((__ZTIm)+(4))>>2)]=((6800)|0);
HEAP32[((__ZTIl)>>2)]=(((6696)|0));
HEAP32[(((__ZTIl)+(4))>>2)]=((6808)|0);
HEAP32[((__ZTIj)>>2)]=(((6696)|0));
HEAP32[(((__ZTIj)+(4))>>2)]=((6816)|0);
HEAP32[((__ZTIi)>>2)]=(((6696)|0));
HEAP32[(((__ZTIi)+(4))>>2)]=((6824)|0);
HEAP32[((__ZTIh)>>2)]=(((6696)|0));
HEAP32[(((__ZTIh)+(4))>>2)]=((6832)|0);
HEAP32[((__ZTIf)>>2)]=(((6696)|0));
HEAP32[(((__ZTIf)+(4))>>2)]=((6840)|0);
HEAP32[((__ZTId)>>2)]=(((6696)|0));
HEAP32[(((__ZTId)+(4))>>2)]=((6848)|0);
HEAP32[((__ZTIc)>>2)]=(((6696)|0));
HEAP32[(((__ZTIc)+(4))>>2)]=((6856)|0);
HEAP32[((__ZTIa)>>2)]=(((6696)|0));
HEAP32[(((__ZTIa)+(4))>>2)]=((6872)|0);
HEAP32[((7368)>>2)]=(((__ZTVN10__cxxabiv117__class_type_infoE+8)|0));
HEAP32[((7376)>>2)]=(((__ZTVN10__cxxabiv117__class_type_infoE+8)|0));
HEAP32[((7384)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((7400)>>2)]=(((__ZTVN10__cxxabiv117__class_type_infoE+8)|0));
HEAP32[((7456)>>2)]=(((__ZTVN10__cxxabiv117__class_type_infoE+8)|0));
HEAP32[((7464)>>2)]=(((__ZTVN10__cxxabiv117__class_type_infoE+8)|0));
HEAP32[((7472)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((7488)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((7504)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((7520)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((7536)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
}
var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);
assert(tempDoublePtr % 8 == 0);
function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}
function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}
  var _cosf=Math.cos;
  function _memcpy(dest, src, num) {
      dest = dest|0; src = src|0; num = num|0;
      var ret = 0;
      ret = dest|0;
      if ((dest&3) == (src&3)) {
        while (dest & 3) {
          if ((num|0) == 0) return ret|0;
          HEAP8[(dest)]=HEAP8[(src)];
          dest = (dest+1)|0;
          src = (src+1)|0;
          num = (num-1)|0;
        }
        while ((num|0) >= 4) {
          HEAP32[((dest)>>2)]=HEAP32[((src)>>2)];
          dest = (dest+4)|0;
          src = (src+4)|0;
          num = (num-4)|0;
        }
      }
      while ((num|0) > 0) {
        HEAP8[(dest)]=HEAP8[(src)];
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      return ret|0;
    }var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;
  var _sqrtf=Math.sqrt;
  function ___gxx_personality_v0() {
    }
  function _llvm_umul_with_overflow_i32(x, y) {
      x = x>>>0;
      y = y>>>0;
      return tempRet0 = x*y > 4294967295,(x*y)>>>0;
    }
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:35,EIDRM:36,ECHRNG:37,EL2NSYNC:38,EL3HLT:39,EL3RST:40,ELNRNG:41,EUNATCH:42,ENOCSI:43,EL2HLT:44,EDEADLK:45,ENOLCK:46,EBADE:50,EBADR:51,EXFULL:52,ENOANO:53,EBADRQC:54,EBADSLT:55,EDEADLOCK:56,EBFONT:57,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:74,EDOTDOT:76,EBADMSG:77,ENOTUNIQ:80,EBADFD:81,EREMCHG:82,ELIBACC:83,ELIBBAD:84,ELIBSCN:85,ELIBMAX:86,ELIBEXEC:87,ENOSYS:88,ENOTEMPTY:90,ENAMETOOLONG:91,ELOOP:92,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:106,EPROTOTYPE:107,ENOTSOCK:108,ENOPROTOOPT:109,ESHUTDOWN:110,ECONNREFUSED:111,EADDRINUSE:112,ECONNABORTED:113,ENETUNREACH:114,ENETDOWN:115,ETIMEDOUT:116,EHOSTDOWN:117,EHOSTUNREACH:118,EINPROGRESS:119,EALREADY:120,EDESTADDRREQ:121,EMSGSIZE:122,EPROTONOSUPPORT:123,ESOCKTNOSUPPORT:124,EADDRNOTAVAIL:125,ENETRESET:126,EISCONN:127,ENOTCONN:128,ETOOMANYREFS:129,EUSERS:131,EDQUOT:132,ESTALE:133,ENOTSUP:134,ENOMEDIUM:135,EILSEQ:138,EOVERFLOW:139,ECANCELED:140,ENOTRECOVERABLE:141,EOWNERDEAD:142,ESTRPIPE:143};
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"No message of desired type",36:"Identifier removed",37:"Channel number out of range",38:"Level 2 not synchronized",39:"Level 3 halted",40:"Level 3 reset",41:"Link number out of range",42:"Protocol driver not attached",43:"No CSI structure available",44:"Level 2 halted",45:"Deadlock condition",46:"No record locks available",50:"Invalid exchange",51:"Invalid request descriptor",52:"Exchange full",53:"No anode",54:"Invalid request code",55:"Invalid slot",56:"File locking deadlock error",57:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",74:"Multihop attempted",76:"Cross mount point (not really error)",77:"Trying to read unreadable message",80:"Given log. name not unique",81:"f.d. invalid for this operation",82:"Remote address changed",83:"Can   access a needed shared lib",84:"Accessing a corrupted shared lib",85:".lib section in a.out corrupted",86:"Attempting to link in too many libs",87:"Attempting to exec a shared library",88:"Function not implemented",90:"Directory not empty",91:"File or path name too long",92:"Too many symbolic links",95:"Operation not supported on transport endpoint",96:"Protocol family not supported",104:"Connection reset by peer",105:"No buffer space available",106:"Address family not supported by protocol family",107:"Protocol wrong type for socket",108:"Socket operation on non-socket",109:"Protocol not available",110:"Can't send after socket shutdown",111:"Connection refused",112:"Address already in use",113:"Connection aborted",114:"Network is unreachable",115:"Network interface is not configured",116:"Connection timed out",117:"Host is down",118:"Host is unreachable",119:"Connection already in progress",120:"Socket already connected",121:"Destination address required",122:"Message too long",123:"Unknown protocol",124:"Socket type not supported",125:"Address not available",126:"Connection reset by network",127:"Socket is already connected",128:"Socket is not connected",129:"Too many references",131:"Too many users",132:"Quota exceeded",133:"Stale file handle",134:"Not supported",135:"No medium (in tape drive)",138:"Illegal byte sequence",139:"Value too large for defined data type",140:"Operation canceled",141:"State not recoverable",142:"Previous owner died",143:"Streams pipe error"};
  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value
      return value;
    }
  var VFS=undefined;
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path, ext) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var f = PATH.splitPath(path)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
          f = f.substr(0, f.length - ext.length);
        }
        return f;
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.filter(function(p, index) {
          if (typeof p !== 'string') {
            throw new TypeError('Arguments to path.join must be strings');
          }
          return p;
        }).join('/'));
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  var TTY={ttys:[],register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          // this wouldn't be required if the library wasn't eval'd at first...
          if (!TTY.utf8) {
            TTY.utf8 = new Runtime.UTF8Processor();
          }
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          if (stream.tty.output.length) {
            stream.tty.ops.put_char(stream.tty, 10);
          }
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              if (process.stdin.destroyed) {
                return undefined;
              }
              result = process.stdin.read();
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }}};
  var MEMFS={mount:function (mount) {
        return MEMFS.create_node(null, '/', 0040000 | 0777, 0);
      },create_node:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            lookup: MEMFS.node_ops.lookup,
            mknod: MEMFS.node_ops.mknod,
            mknod: MEMFS.node_ops.mknod,
            rename: MEMFS.node_ops.rename,
            unlink: MEMFS.node_ops.unlink,
            rmdir: MEMFS.node_ops.rmdir,
            readdir: MEMFS.node_ops.readdir,
            symlink: MEMFS.node_ops.symlink
          };
          node.stream_ops = {
            llseek: MEMFS.stream_ops.llseek
          };
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          };
          node.stream_ops = {
            llseek: MEMFS.stream_ops.llseek,
            read: MEMFS.stream_ops.read,
            write: MEMFS.stream_ops.write,
            allocate: MEMFS.stream_ops.allocate,
            mmap: MEMFS.stream_ops.mmap
          };
          node.contents = [];
        } else if (FS.isLink(node.mode)) {
          node.node_ops = {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr,
            readlink: MEMFS.node_ops.readlink
          };
          node.stream_ops = {};
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = {
            getattr: MEMFS.node_ops.getattr,
            setattr: MEMFS.node_ops.setattr
          };
          node.stream_ops = FS.chrdev_stream_ops;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.contents.length;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            var contents = node.contents;
            if (attr.size < contents.length) contents.length = attr.size;
            else while (attr.size > contents.length) contents.push(0);
          }
        },lookup:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.create_node(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.create_node(parent, newname, 0777 | 0120000, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          var size = Math.min(contents.length - position, length);
          if (contents.subarray) { // typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else
          {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          }
          return size;
        },write:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          while (contents.length < position) contents.push(0);
          for (var i = 0; i < length; i++) {
            contents[position + i] = buffer[offset + i];
          }
          stream.node.timestamp = Date.now();
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.contents.length;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          stream.ungotten = [];
          stream.position = position;
          return position;
        },allocate:function (stream, offset, length) {
          var contents = stream.node.contents;
          var limit = offset + length;
          while (limit > contents.length) contents.push(0);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 0x02)) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            assert(contents.buffer === buffer || contents.buffer === buffer.buffer);
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        }}};
  var _stdin=allocate(1, "i32*", ALLOC_STATIC);
  var _stdout=allocate(1, "i32*", ALLOC_STATIC);
  var _stderr=allocate(1, "i32*", ALLOC_STATIC);
  function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
      // we don't currently perform any user-space buffering of data
    }var FS={root:null,nodes:[null],devices:[null],streams:[null],nextInode:1,name_table:[,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,],currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:function (errno) {
        this.errno = errno;
        for (var key in ERRNO_CODES) {
          if (ERRNO_CODES[key] === errno) {
            this.code = key;
            break;
          }
        }
        this.message = ERRNO_MESSAGES[errno] + ' : ' + new Error().stack;
      },handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + new Error().stack;
        return ___setErrNo(e.errno);
      },hashName:function (parentid, name) {
        var hash = 0;
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.name_table.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.name_table[hash];
        FS.name_table[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.name_table[hash] === node) {
          FS.name_table[hash] = node.name_next;
        } else {
          var current = FS.name_table[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.name_table[hash]; node; node = node.name_next) {
          if (node.parent.id === parent.id && node.name === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        var node = {
          id: FS.nextInode++,
          name: name,
          mode: mode,
          node_ops: {},
          stream_ops: {},
          rdev: rdev,
          parent: null,
          mount: null
        };
        if (!parent) {
          parent = node;  // root node sets parent to itself
        }
        node.parent = parent;
        node.mount = parent.mount;
        // compatibility
        var readMode = 292 | 73;
        var writeMode = 146;
        // NOTE we must use Object.defineProperties instead of individual calls to
        // Object.defineProperty in order to make closure compiler happy
        Object.defineProperties(node, {
          read: {
            get: function() { return (node.mode & readMode) === readMode; },
            set: function(val) { val ? node.mode |= readMode : node.mode &= ~readMode; }
          },
          write: {
            get: function() { return (node.mode & writeMode) === writeMode; },
            set: function(val) { val ? node.mode |= writeMode : node.mode &= ~writeMode; }
          },
          isFolder: {
            get: function() { return FS.isDir(node.mode); },
          },
          isDevice: {
            get: function() { return FS.isChrdev(node.mode); },
          },
        });
        FS.hashAddNode(node);
        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return node.mounted;
      },isFile:function (mode) {
        return (mode & 0170000) === 0100000;
      },isDir:function (mode) {
        return (mode & 0170000) === 0040000;
      },isLink:function (mode) {
        return (mode & 0170000) === 0120000;
      },isChrdev:function (mode) {
        return (mode & 0170000) === 0020000;
      },isBlkdev:function (mode) {
        return (mode & 0170000) === 0060000;
      },isFIFO:function (mode) {
        return (mode & 0170000) === 0010000;
      },cwd:function () {
        return FS.currentPath;
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.currentPath, path);
        opts = opts || { recurse_count: 0 };
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
        // start at the root
        var current = FS.root;
        var current_path = '/';
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join(current_path, parts[i]);
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            current = current.mount.root;
          }
          // follow symlinks
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            return path ? PATH.join(node.mount.mountpoint, path) : node.mount.mountpoint;
          }
          path = path ? PATH.join(node.name, path) : node.name;
          node = node.parent;
        }
      },flagModes:{"r":0,"rs":8192,"r+":2,"w":1537,"wx":3585,"xw":3585,"w+":1538,"wx+":3586,"xw+":3586,"a":521,"ax":2569,"xa":2569,"a+":522,"ax+":2570,"xa+":2570},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 3;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 1024)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        return FS.nodePermissions(dir, 'x');
      },mayMknod:function (mode) {
        switch (mode & 0170000) {
          case 0100000:
          case 0020000:
          case 0060000:
          case 0010000:
          case 0140000:
            return 0;
          default:
            return ERRNO_CODES.EINVAL;
        }
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.currentPath) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 3) !== 0 ||  // opening for write
              (flags & 1024)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 1;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        // compatibility
        Object.defineProperties(stream, {
          object: {
            get: function() { return stream.node; },
            set: function(val) { stream.node = val; }
          },
          isRead: {
            get: function() { return (stream.flags & 3) !== 1; }
          },
          isWrite: {
            get: function() { return (stream.flags & 3) !== 0; }
          },
          isAppend: {
            get: function() { return (stream.flags & 8); }
          }
        });
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join(parent, part);
          try {
            FS.mkdir(current, 0777);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite) {
        var path = PATH.join(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(path, mode | 146);
          var stream = FS.open(path, 'w');
          FS.write(stream, data, 0, data.length, 0);
          FS.close(stream);
          FS.chmod(path, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = input && output ? 0777 : (input ? 0333 : 0555);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          var LazyUint8Array = function() {
            this.lengthKnown = false;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = Math.floor(idx / this.chunkSize);
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function(getter) {
            this.getter = getter;
          }
          LazyUint8Array.prototype.cacheLength = function() {
              // Find length
              var xhr = new XMLHttpRequest();
              xhr.open('HEAD', url, false);
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              var datalength = Number(xhr.getResponseHeader("Content-length"));
              var header;
              var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
              var chunkSize = 1024*1024; // Chunk size in bytes
              if (!hasByteServing) chunkSize = datalength;
              // Function to get a range from the remote URL.
              var doXHR = (function(from, to) {
                if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
                // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
                // Some hints to the browser that we want binary data.
                if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
                if (xhr.overrideMimeType) {
                  xhr.overrideMimeType('text/plain; charset=x-user-defined');
                }
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                if (xhr.response !== undefined) {
                  return new Uint8Array(xhr.response || []);
                } else {
                  return intArrayFromString(xhr.responseText || '', true);
                }
              });
              var lazyArray = this;
              lazyArray.setDataGetter(function(chunkNum) {
                var start = chunkNum * chunkSize;
                var end = (chunkNum+1) * chunkSize - 1; // including this byte
                end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
                if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
                  lazyArray.chunks[chunkNum] = doXHR(start, end);
                }
                if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
                return lazyArray.chunks[chunkNum];
              });
              this._length = datalength;
              this._chunkSize = chunkSize;
              this.lengthKnown = true;
          }
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = PATH.resolve(PATH.join(parent, name));
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp', 0777);
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev', 0777);
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', 0666, FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', 0666, FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', 0666, FS.makedev(6, 0));
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm', 0777);
        FS.mkdir('/dev/shm/tmp', 0777);
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=stdin.fd;
        assert(stdin.fd === 1, 'invalid handle for stdin (' + stdin.fd + ')');
        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=stdout.fd;
        assert(stdout.fd === 2, 'invalid handle for stdout (' + stdout.fd + ')');
        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=stderr.fd;
        assert(stderr.fd === 3, 'invalid handle for stderr (' + stderr.fd + ')');
      },staticInit:function () {
        FS.root = FS.createNode(null, '/', 0040000 | 0777, 0);
        FS.mount(MEMFS, {}, '/');
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },mount:function (type, opts, mountpoint) {
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          root: null
        };
        var lookup;
        if (mountpoint) {
          lookup = FS.lookupPath(mountpoint, { follow: false });
        }
        // create a root node for the fs
        var root = type.mount(mount);
        root.mount = mount;
        mount.root = root;
        // assign the mount info to the mountpoint's node
        if (lookup) {
          lookup.node.mount = mount;
          lookup.node.mounted = true;
          // compatibility update FS.root if we mount to /
          if (mountpoint === '/') {
            FS.root = mount.root;
          }
        }
        return root;
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode &= 4095;
        mode |= 0100000;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode &= 511 | 0001000;
        mode |= 0040000;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        mode |= 0020000;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:function (path) {
        var lookup = FS.lookupPath(path, { follow: false });
        var link = lookup.node;
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 3) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        path = PATH.normalize(path);
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 0666 : mode;
        if ((flags & 512)) {
          mode = (mode & 4095) | 0100000;
        } else {
          mode = 0;
        }
        var node;
        try {
          var lookup = FS.lookupPath(path, {
            follow: !(flags & 0200000)
          });
          node = lookup.node;
          path = lookup.path;
        } catch (e) {
          // ignore
        }
        // perhaps we need to create the node
        if ((flags & 512)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 2048)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~1024;
        }
        // check permissions
        var err = FS.mayOpen(node, flags);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // do truncation if necessary
        if ((flags & 1024)) {
          FS.truncate(node, 0);
        }
        // register the stream with the filesystem
        var stream = FS.createStream({
          path: path,
          node: node,
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        return stream.stream_ops.llseek(stream, offset, whence);
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 3) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 3) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        if (stream.flags & 8) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 3) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 3) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.errnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      }};
  function _send(fd, buf, len, flags) {
      var info = FS.getStream(fd);
      if (!info) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (info.socket.readyState === WebSocket.CLOSING || info.socket.readyState === WebSocket.CLOSED) {
        ___setErrNo(ERRNO_CODES.ENOTCONN);
        return -1;
      } else if (info.socket.readyState === WebSocket.CONNECTING) {
        ___setErrNo(ERRNO_CODES.EAGAIN);
        return -1;
      }
      info.sender(HEAPU8.subarray(buf, buf+len));
      return len;
    }
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (stream && ('socket' in stream)) {
        return _send(fildes, buf, nbyte, 0);
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var bytesWritten = _write(stream, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStream(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }
  function _strlen(ptr) {
      ptr = ptr|0;
      var curr = 0;
      curr = ptr;
      while (HEAP8[(curr)]) {
        curr = (curr + 1)|0;
      }
      return (curr - ptr)|0;
    }
  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = HEAPF64[(((varargs)+(argIndex))>>3)];
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+8))>>2)]];
          argIndex += 8; // each 32-bit chunk is in a 64-bit block
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Math.max(Runtime.getNativeFieldSize(type), Runtime.getAlignSize(type, null, true));
        return ret;
      }
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }
          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }
          // Handle precision.
          var precisionSet = false;
          if (next == 46) {
            var precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          } else {
            var precision = 6; // Standard default.
          }
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];
          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var origArg = currArg;
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (argSize == 8 && i64Math) {
                  if (origArg[1]) {
                    argText = (origArg[1]>>>0).toString(16);
                    var lower = (origArg[0]>>>0).toString(16);
                    while (lower.length < 8) lower = '0' + lower;
                    argText += lower;
                  } else {
                    argText = (origArg[0]>>>0).toString(16);
                  }
                } else
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }
              // Add sign if needed
              if (flagAlwaysSigned) {
                if (currArg < 0) {
                  prefix = '-' + prefix;
                } else {
                  prefix = '+' + prefix;
                }
              }
              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }
              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);
                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }
                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }
                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();
                // Add sign.
                if (flagAlwaysSigned && currArg >= 0) {
                  argText = '+' + argText;
                }
              }
              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }
              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();
              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)|0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[(i)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }function _printf(format, varargs) {
      // int printf(const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var stdout = HEAP32[((_stdout)>>2)];
      return _fprintf(stdout, format, varargs);
    }
  function _memset(ptr, value, num) {
      ptr = ptr|0; value = value|0; num = num|0;
      var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
      stop = (ptr + num)|0;
      if ((num|0) >= 20) {
        // This is unaligned, but quite large, so work hard to get to aligned settings
        value = value & 0xff;
        unaligned = ptr & 3;
        value4 = value | (value << 8) | (value << 16) | (value << 24);
        stop4 = stop & ~3;
        if (unaligned) {
          unaligned = (ptr + 4 - unaligned)|0;
          while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
            HEAP8[(ptr)]=value;
            ptr = (ptr+1)|0;
          }
        }
        while ((ptr|0) < (stop4|0)) {
          HEAP32[((ptr)>>2)]=value4;
          ptr = (ptr+4)|0;
        }
      }
      while ((ptr|0) < (stop|0)) {
        HEAP8[(ptr)]=value;
        ptr = (ptr+1)|0;
      }
    }var _llvm_memset_p0i8_i32=_memset;
  var _llvm_va_start=undefined;
  function _snprintf(s, n, format, varargs) {
      // int snprintf(char *restrict s, size_t n, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var limit = (n === undefined) ? result.length
                                    : Math.min(result.length, Math.max(n - 1, 0));
      if (s < 0) {
        s = -s;
        var buf = _malloc(limit+1);
        HEAP32[((s)>>2)]=buf;
        s = buf;
      }
      for (var i = 0; i < limit; i++) {
        HEAP8[(((s)+(i))|0)]=result[i];
      }
      if (limit < n || (n === undefined)) HEAP8[(((s)+(i))|0)]=0;
      return result.length;
    }function _vsnprintf(s, n, format, va_arg) {
      return _snprintf(s, n, format, HEAP32[((va_arg)>>2)]);
    }
  function _llvm_va_end() {}
  var _fabsf=Math.abs;
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module.print('exit(' + status + ') called');
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }function __ZSt9terminatev() {
      _exit(-1234);
    }
  var _floorf=Math.floor;
  function ___assert_func(filename, line, func, condition) {
      throw 'Assertion failed: ' + (condition ? Pointer_stringify(condition) : 'unknown condition') + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + new Error().stack;
    }
  var _ceilf=Math.ceil;
  function _qsort(base, num, size, cmp) {
      if (num == 0 || size == 0) return;
      // forward calls to the JavaScript sort method
      // first, sort the items logically
      var keys = [];
      for (var i = 0; i < num; i++) keys.push(i);
      keys.sort(function(a, b) {
        return FUNCTION_TABLE[cmp](base+a*size, base+b*size);
      });
      // apply the sort
      var temp = _malloc(num*size);
      _memcpy(temp, base, num*size);
      for (var i = 0; i < num; i++) {
        if (keys[i] == i) continue; // already in place
        _memcpy(base+i*size, temp+keys[i]*size, size);
      }
      _free(temp);
    }
  function _memmove(dest, src, num) {
      dest = dest|0; src = src|0; num = num|0;
      if (((src|0) < (dest|0)) & ((dest|0) < ((src + num)|0))) {
        // Unlikely case: Copy backwards in a safe manner
        src = (src + num)|0;
        dest = (dest + num)|0;
        while ((num|0) > 0) {
          dest = (dest - 1)|0;
          src = (src - 1)|0;
          num = (num - 1)|0;
          HEAP8[(dest)]=HEAP8[(src)];
        }
      } else {
        _memcpy(dest, src, num) | 0;
      }
    }var _llvm_memmove_p0i8_p0i8_i32=_memmove;
  function ___cxa_guard_acquire(variable) {
      if (!HEAP8[(variable)]) { // ignore SAFE_HEAP stuff because llvm mixes i64 and i8 here
        HEAP8[(variable)]=1;
        return 1;
      }
      return 0;
    }
  function ___cxa_guard_release() {}
  var _llvm_memset_p0i8_i64=_memset;
  var ___dirent_struct_layout={__size__:1040,d_ino:0,d_name:4,d_off:1028,d_reclen:1032,d_type:1036};function _open(path, oflag, varargs) {
      // int open(const char *path, int oflag, ...);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html
      var mode = HEAP32[((varargs)>>2)];
      path = Pointer_stringify(path);
      try {
        var stream = FS.open(path, oflag, mode);
        return stream.fd;
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fopen(filename, mode) {
      // FILE *fopen(const char *restrict filename, const char *restrict mode);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fopen.html
      var flags;
      mode = Pointer_stringify(mode);
      if (mode[0] == 'r') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 0;
        }
      } else if (mode[0] == 'w') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 1024;
      } else if (mode[0] == 'a') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 8;
      } else {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return 0;
      }
      var ret = _open(filename, flags, allocate([0x1FF, 0, 0, 0], 'i32', ALLOC_STACK));  // All creation permissions.
      return (ret == -1) ? 0 : ret;
    }
  function _lseek(fildes, offset, whence) {
      // off_t lseek(int fildes, off_t offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/lseek.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        return FS.llseek(stream, offset, whence);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fseek(stream, offset, whence) {
      // int fseek(FILE *stream, long offset, int whence);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fseek.html
      var ret = _lseek(stream, offset, whence);
      if (ret == -1) {
        return -1;
      }
      stream = FS.getStream(stream);
      stream.eof = false;
      return 0;
    }
  function _ftell(stream) {
      // long ftell(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/ftell.html
      stream = FS.getStream(stream);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (FS.isChrdev(stream.node.mode)) {
        ___setErrNo(ERRNO_CODES.ESPIPE);
        return -1;
      } else {
        return stream.position;
      }
    }
  function _close(fildes) {
      // int close(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/close.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        FS.close(stream);
        return 0;
      } catch (e) {
        FS.handleFSError(e);;
        return -1;
      }
    }
  function _fsync(fildes) {
      // int fsync(int fildes);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fsync.html
      var stream = FS.getStream(fildes);
      if (stream) {
        // We write directly to the file system, so there's nothing to do here.
        return 0;
      } else {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
    }function _fclose(stream) {
      // int fclose(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fclose.html
      _fsync(stream);
      return _close(stream);
    }
  function _recv(fd, buf, len, flags) {
      var info = FS.getStream(fd);
      if (!info) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (!info.hasData()) {
        if (info.socket.readyState === WebSocket.CLOSING || info.socket.readyState === WebSocket.CLOSED) {
          // socket has closed
          return 0;
        } else {
          // else, our socket is in a valid state but truly has nothing available
          ___setErrNo(ERRNO_CODES.EAGAIN);
          return -1;
        }
      }
      var buffer = info.inQueue.shift();
      if (len < buffer.length) {
        if (info.stream) {
          // This is tcp (reliable), so if not all was read, keep it
          info.inQueue.unshift(buffer.subarray(len));
        }
        buffer = buffer.subarray(0, len);
      }
      HEAPU8.set(buffer, buf);
      return buffer.length;
    }
  function _pread(fildes, buf, nbyte, offset) {
      // ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _read(fildes, buf, nbyte) {
      // ssize_t read(int fildes, void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      if (stream && ('socket' in stream)) {
        return _recv(fildes, buf, nbyte, 0);
      }
      try {
        var slab = HEAP8;
        return FS.read(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _fread(ptr, size, nitems, stream) {
      // size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fread.html
      var bytesToRead = nitems * size;
      if (bytesToRead == 0) {
        return 0;
      }
      var bytesRead = 0;
      var streamObj = FS.getStream(stream);
      while (streamObj.ungotten.length && bytesToRead > 0) {
        HEAP8[((ptr++)|0)]=streamObj.ungotten.pop()
        bytesToRead--;
        bytesRead++;
      }
      var err = _read(stream, ptr, bytesToRead);
      if (err == -1) {
        if (streamObj) streamObj.error = true;
        return 0;
      }
      bytesRead += err;
      if (bytesRead < bytesToRead) streamObj.eof = true;
      return Math.floor(bytesRead / size);
    }
  function __isFloat(text) {
      return !!(/^[+-]?[0-9]*\.?[0-9]+([eE][+-]?[0-9]+)?$/.exec(text));
    }function __scanString(format, get, unget, varargs) {
      if (!__scanString.whiteSpace) {
        __scanString.whiteSpace = {};
        __scanString.whiteSpace[32] = 1;
        __scanString.whiteSpace[9] = 1;
        __scanString.whiteSpace[10] = 1;
        __scanString.whiteSpace[11] = 1;
        __scanString.whiteSpace[12] = 1;
        __scanString.whiteSpace[13] = 1;
        __scanString.whiteSpace[' '] = 1;
        __scanString.whiteSpace['\t'] = 1;
        __scanString.whiteSpace['\n'] = 1;
        __scanString.whiteSpace['\v'] = 1;
        __scanString.whiteSpace['\f'] = 1;
        __scanString.whiteSpace['\r'] = 1;
      }
      // Supports %x, %4x, %d.%d, %lld, %s, %f, %lf.
      // TODO: Support all format specifiers.
      format = Pointer_stringify(format);
      var soFar = 0;
      if (format.indexOf('%n') >= 0) {
        // need to track soFar
        var _get = get;
        get = function() {
          soFar++;
          return _get();
        }
        var _unget = unget;
        unget = function() {
          soFar--;
          return _unget();
        }
      }
      var formatIndex = 0;
      var argsi = 0;
      var fields = 0;
      var argIndex = 0;
      var next;
      mainLoop:
      for (var formatIndex = 0; formatIndex < format.length;) {
        if (format[formatIndex] === '%' && format[formatIndex+1] == 'n') {
          var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += Runtime.getAlignSize('void*', null, true);
          HEAP32[((argPtr)>>2)]=soFar;
          formatIndex += 2;
          continue;
        }
        if (format[formatIndex] === '%') {
          var nextC = format.indexOf('c', formatIndex+1);
          if (nextC > 0) {
            var maxx = 1;
            if (nextC > formatIndex+1) {
              var sub = format.substring(formatIndex+1, nextC)
              maxx = parseInt(sub);
              if (maxx != sub) maxx = 0;
            }
            if (maxx) {
              var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
              argIndex += Runtime.getAlignSize('void*', null, true);
              fields++;
              for (var i = 0; i < maxx; i++) {
                next = get();
                HEAP8[((argPtr++)|0)]=next;
              }
              formatIndex += nextC - formatIndex + 1;
              continue;
            }
          }
        }
        // remove whitespace
        while (1) {
          next = get();
          if (next == 0) return fields;
          if (!(next in __scanString.whiteSpace)) break;
        }
        unget();
        if (format[formatIndex] === '%') {
          formatIndex++;
          var suppressAssignment = false;
          if (format[formatIndex] == '*') {
            suppressAssignment = true;
            formatIndex++;
          }
          var maxSpecifierStart = formatIndex;
          while (format[formatIndex].charCodeAt(0) >= 48 &&
                 format[formatIndex].charCodeAt(0) <= 57) {
            formatIndex++;
          }
          var max_;
          if (formatIndex != maxSpecifierStart) {
            max_ = parseInt(format.slice(maxSpecifierStart, formatIndex), 10);
          }
          var long_ = false;
          var half = false;
          var longLong = false;
          if (format[formatIndex] == 'l') {
            long_ = true;
            formatIndex++;
            if (format[formatIndex] == 'l') {
              longLong = true;
              formatIndex++;
            }
          } else if (format[formatIndex] == 'h') {
            half = true;
            formatIndex++;
          }
          var type = format[formatIndex];
          formatIndex++;
          var curr = 0;
          var buffer = [];
          // Read characters according to the format. floats are trickier, they may be in an unfloat state in the middle, then be a valid float later
          if (type == 'f' || type == 'e' || type == 'g' ||
              type == 'F' || type == 'E' || type == 'G') {
            var last = 0;
            next = get();
            while (next > 0) {
              buffer.push(String.fromCharCode(next));
              if (__isFloat(buffer.join(''))) {
                last = buffer.length;
              }
              next = get();
            }
            for (var i = 0; i < buffer.length - last + 1; i++) {
              unget();
            }
            buffer.length = last;
          } else {
            next = get();
            var first = true;
            while ((curr < max_ || isNaN(max_)) && next > 0) {
              if (!(next in __scanString.whiteSpace) && // stop on whitespace
                  (type == 's' ||
                   ((type === 'd' || type == 'u' || type == 'i') && ((next >= 48 && next <= 57) ||
                                                                     (first && next == 45))) ||
                   ((type === 'x' || type === 'X') && (next >= 48 && next <= 57 ||
                                     next >= 97 && next <= 102 ||
                                     next >= 65 && next <= 70))) &&
                  (formatIndex >= format.length || next !== format[formatIndex].charCodeAt(0))) { // Stop when we read something that is coming up
                buffer.push(String.fromCharCode(next));
                next = get();
                curr++;
                first = false;
              } else {
                break;
              }
            }
            unget();
          }
          if (buffer.length === 0) return 0;  // Failure.
          if (suppressAssignment) continue;
          var text = buffer.join('');
          var argPtr = HEAP32[(((varargs)+(argIndex))>>2)];
          argIndex += Runtime.getAlignSize('void*', null, true);
          switch (type) {
            case 'd': case 'u': case 'i':
              if (half) {
                HEAP16[((argPtr)>>1)]=parseInt(text, 10);
              } else if (longLong) {
                (tempI64 = [parseInt(text, 10)>>>0,Math.min(Math.floor((parseInt(text, 10))/4294967296), 4294967295)>>>0],HEAP32[((argPtr)>>2)]=tempI64[0],HEAP32[(((argPtr)+(4))>>2)]=tempI64[1]);
              } else {
                HEAP32[((argPtr)>>2)]=parseInt(text, 10);
              }
              break;
            case 'X':
            case 'x':
              HEAP32[((argPtr)>>2)]=parseInt(text, 16)
              break;
            case 'F':
            case 'f':
            case 'E':
            case 'e':
            case 'G':
            case 'g':
            case 'E':
              // fallthrough intended
              if (long_) {
                HEAPF64[((argPtr)>>3)]=parseFloat(text)
              } else {
                HEAPF32[((argPtr)>>2)]=parseFloat(text)
              }
              break;
            case 's':
              var array = intArrayFromString(text);
              for (var j = 0; j < array.length; j++) {
                HEAP8[(((argPtr)+(j))|0)]=array[j]
              }
              break;
          }
          fields++;
        } else if (format[formatIndex] in __scanString.whiteSpace) {
          next = get();
          while (next in __scanString.whiteSpace) {
            if (next <= 0) break mainLoop;  // End of input.
            next = get();
          }
          unget(next);
          formatIndex++;
        } else {
          // Not a specifier.
          next = get();
          if (format[formatIndex].charCodeAt(0) !== next) {
            unget(next);
            break mainLoop;
          }
          formatIndex++;
        }
      }
      return fields;
    }function _sscanf(s, format, varargs) {
      // int sscanf(const char *restrict s, const char *restrict format, ... );
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/scanf.html
      var index = 0;
      var get = function() { return HEAP8[(((s)+(index++))|0)]; };
      var unget = function() { index--; };
      return __scanString(format, get, unget, varargs);
    }
  function _strncpy(pdest, psrc, num) {
      pdest = pdest|0; psrc = psrc|0; num = num|0;
      var padding = 0, curr = 0, i = 0;
      while ((i|0) < (num|0)) {
        curr = padding ? 0 : HEAP8[(((psrc)+(i))|0)];
        HEAP8[(((pdest)+(i))|0)]=curr
        padding = padding ? 1 : (HEAP8[(((psrc)+(i))|0)] == 0);
        i = (i+1)|0;
      }
      return pdest|0;
    }
  function _isspace(chr) {
      return (chr == 32) || (chr >= 9 && chr <= 13);
    }function __parseInt(str, endptr, base, min, max, bits, unsign) {
      // Skip space.
      while (_isspace(HEAP8[(str)])) str++;
      // Check for a plus/minus sign.
      var multiplier = 1;
      if (HEAP8[(str)] == 45) {
        multiplier = -1;
        str++;
      } else if (HEAP8[(str)] == 43) {
        str++;
      }
      // Find base.
      var finalBase = base;
      if (!finalBase) {
        if (HEAP8[(str)] == 48) {
          if (HEAP8[((str+1)|0)] == 120 ||
              HEAP8[((str+1)|0)] == 88) {
            finalBase = 16;
            str += 2;
          } else {
            finalBase = 8;
            str++;
          }
        }
      } else if (finalBase==16) {
        if (HEAP8[(str)] == 48) {
          if (HEAP8[((str+1)|0)] == 120 ||
              HEAP8[((str+1)|0)] == 88) {
            str += 2;
          }
        }
      }
      if (!finalBase) finalBase = 10;
      // Get digits.
      var chr;
      var ret = 0;
      while ((chr = HEAP8[(str)]) != 0) {
        var digit = parseInt(String.fromCharCode(chr), finalBase);
        if (isNaN(digit)) {
          break;
        } else {
          ret = ret * finalBase + digit;
          str++;
        }
      }
      // Apply sign.
      ret *= multiplier;
      // Set end pointer.
      if (endptr) {
        HEAP32[((endptr)>>2)]=str
      }
      // Unsign if needed.
      if (unsign) {
        if (Math.abs(ret) > max) {
          ret = max;
          ___setErrNo(ERRNO_CODES.ERANGE);
        } else {
          ret = unSign(ret, bits);
        }
      }
      // Validate range.
      if (ret > max || ret < min) {
        ret = ret > max ? max : min;
        ___setErrNo(ERRNO_CODES.ERANGE);
      }
      if (bits == 64) {
        return tempRet0 = Math.min(Math.floor((ret)/4294967296), 4294967295)>>>0,ret>>>0;
      }
      return ret;
    }function _strtol(str, endptr, base) {
      return __parseInt(str, endptr, base, -2147483648, 2147483647, 32);  // LONG_MIN, LONG_MAX.
    }function _atoi(ptr) {
      return _strtol(ptr, null, 10);
    }
  function _atexit(func, arg) {
      __ATEXIT__.unshift({ func: func, arg: arg });
    }var ___cxa_atexit=_atexit;
  var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],currArrayBuffer:0,currElementArrayBuffer:0,byteSizeByTypeRoot:5120,byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],uniformTable:{},packAlignment:4,unpackAlignment:4,init:function () {
        Browser.moduleContextCreatedCallbacks.push(GL.initExtensions);
      },getNewId:function (table) {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },MINI_TEMP_BUFFER_SIZE:16,miniTempBuffer:null,miniTempBufferViews:[0],MAX_TEMP_BUFFER_SIZE:2097152,tempBufferIndexLookup:null,tempVertexBuffers:null,tempIndexBuffers:null,tempQuadIndexBuffer:null,generateTempBuffers:function (quads) {
        GL.tempBufferIndexLookup = new Uint8Array(GL.MAX_TEMP_BUFFER_SIZE+1);
        GL.tempVertexBuffers = [];
        GL.tempIndexBuffers = [];
        var last = -1, curr = -1;
        var size = 1;
        for (var i = 0; i <= GL.MAX_TEMP_BUFFER_SIZE; i++) {
          if (i > size) {
            size <<= 1;
          }
          if (size != last) {
            curr++;
            GL.tempVertexBuffers[curr] = Module.ctx.createBuffer();
            Module.ctx.bindBuffer(Module.ctx.ARRAY_BUFFER, GL.tempVertexBuffers[curr]);
            Module.ctx.bufferData(Module.ctx.ARRAY_BUFFER, size, Module.ctx.DYNAMIC_DRAW);
            Module.ctx.bindBuffer(Module.ctx.ARRAY_BUFFER, null);
            GL.tempIndexBuffers[curr] = Module.ctx.createBuffer();
            Module.ctx.bindBuffer(Module.ctx.ELEMENT_ARRAY_BUFFER, GL.tempIndexBuffers[curr]);
            Module.ctx.bufferData(Module.ctx.ELEMENT_ARRAY_BUFFER, size, Module.ctx.DYNAMIC_DRAW);
            Module.ctx.bindBuffer(Module.ctx.ELEMENT_ARRAY_BUFFER, null);
            last = size;
          }
          GL.tempBufferIndexLookup[i] = curr;
        }
        if (quads) {
          // GL_QUAD indexes can be precalculated
          GL.tempQuadIndexBuffer = Module.ctx.createBuffer();
          Module.ctx.bindBuffer(Module.ctx.ELEMENT_ARRAY_BUFFER, GL.tempQuadIndexBuffer);
          var numIndexes = GL.MAX_TEMP_BUFFER_SIZE >> 1;
          var quadIndexes = new Uint16Array(numIndexes);
          var i = 0, v = 0;
          while (1) {
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+1;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+2;
            if (i >= numIndexes) break;
            quadIndexes[i++] = v+3;
            if (i >= numIndexes) break;
            v += 4;
          }
          Module.ctx.bufferData(Module.ctx.ELEMENT_ARRAY_BUFFER, quadIndexes, Module.ctx.STATIC_DRAW);
          Module.ctx.bindBuffer(Module.ctx.ELEMENT_ARRAY_BUFFER, null);
        }
      },findToken:function (source, token) {
        function isIdentChar(ch) {
          if (ch >= 48 && ch <= 57) // 0-9
            return true;
          if (ch >= 65 && ch <= 90) // A-Z
            return true;
          if (ch >= 97 && ch <= 122) // a-z
            return true;
          return false;
        }
        var i = -1;
        do {
          i = source.indexOf(token, i + 1);
          if (i < 0) {
            break;
          }
          if (i > 0 && isIdentChar(source[i - 1])) {
            continue;
          }
          i += token.length;
          if (i < source.length - 1 && isIdentChar(source[i + 1])) {
            continue;
          }
          return true;
        } while (true);
        return false;
      },getSource:function (shader, count, string, length) {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var frag;
          if (length) {
            var len = HEAP32[(((length)+(i*4))>>2)];
            if (len < 0) {
              frag = Pointer_stringify(HEAP32[(((string)+(i*4))>>2)]);
            } else {
              frag = Pointer_stringify(HEAP32[(((string)+(i*4))>>2)], len);
            }
          } else {
            frag = Pointer_stringify(HEAP32[(((string)+(i*4))>>2)]);
          }
          source += frag;
        }
        // Let's see if we need to enable the standard derivatives extension
        type = Module.ctx.getShaderParameter(GL.shaders[shader], 0x8B4F /* GL_SHADER_TYPE */);
        if (type == 0x8B30 /* GL_FRAGMENT_SHADER */) {
          if (GL.findToken(source, "dFdx") ||
              GL.findToken(source, "dFdy") ||
              GL.findToken(source, "fwidth")) {
            source = "#extension GL_OES_standard_derivatives : enable\n" + source;
            var extension = Module.ctx.getExtension("OES_standard_derivatives");
          }
        }
        return source;
      },computeImageSize:function (width, height, sizePerPixel, alignment) {
        function roundedToNextMultipleOf(x, y) {
          return Math.floor((x + y - 1) / y) * y
        }
        var plainRowSize = width * sizePerPixel;
        var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
        return (height <= 0) ? 0 :
                 ((height - 1) * alignedRowSize + plainRowSize);
      },getTexPixelData:function (type, format, width, height, pixels, internalFormat) {
        var sizePerPixel;
        switch (type) {
          case 0x1401 /* GL_UNSIGNED_BYTE */:
            switch (format) {
              case 0x1906 /* GL_ALPHA */:
              case 0x1909 /* GL_LUMINANCE */:
                sizePerPixel = 1;
                break;
              case 0x1907 /* GL_RGB */:
                sizePerPixel = 3;
                break;
              case 0x1908 /* GL_RGBA */:
                sizePerPixel = 4;
                break;
              case 0x190A /* GL_LUMINANCE_ALPHA */:
                sizePerPixel = 2;
                break;
              default:
                throw 'Invalid format (' + format + ')';
            }
            break;
          case 0x8363 /* GL_UNSIGNED_SHORT_5_6_5 */:
          case 0x8033 /* GL_UNSIGNED_SHORT_4_4_4_4 */:
          case 0x8034 /* GL_UNSIGNED_SHORT_5_5_5_1 */:
            sizePerPixel = 2;
            break;
          case 0x1406 /* GL_FLOAT */:
            assert(GL.floatExt, 'Must have OES_texture_float to use float textures');
            switch (format) {
              case 0x1907 /* GL_RGB */:
                sizePerPixel = 3*4;
                break;
              case 0x1908 /* GL_RGBA */:
                sizePerPixel = 4*4;
                break;
              default:
                throw 'Invalid format (' + format + ')';
            }
            internalFormat = Module.ctx.RGBA;
            break;
          default:
            throw 'Invalid type (' + type + ')';
        }
        var bytes = GL.computeImageSize(width, height, sizePerPixel, GL.unpackAlignment);
        if (type == 0x1401 /* GL_UNSIGNED_BYTE */) {
          pixels = HEAPU8.subarray((pixels),(pixels+bytes));
        } else if (type == 0x1406 /* GL_FLOAT */) {
          pixels = HEAPF32.subarray((pixels)>>2,(pixels+bytes)>>2);
        } else {
          pixels = HEAPU16.subarray((pixels)>>1,(pixels+bytes)>>1);
        }
        return {
          pixels: pixels,
          internalFormat: internalFormat
        }
      },initExtensions:function () {
        if (GL.initExtensions.done) return;
        GL.initExtensions.done = true;
        if (!Module.useWebGL) return; // an app might link both gl and 2d backends
        GL.miniTempBuffer = new Float32Array(GL.MINI_TEMP_BUFFER_SIZE);
        for (var i = 0; i < GL.MINI_TEMP_BUFFER_SIZE; i++) {
          GL.miniTempBufferViews[i] = GL.miniTempBuffer.subarray(0, i+1);
        }
        GL.maxVertexAttribs = Module.ctx.getParameter(Module.ctx.MAX_VERTEX_ATTRIBS);
        GL.compressionExt = Module.ctx.getExtension('WEBGL_compressed_texture_s3tc') ||
                            Module.ctx.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
                            Module.ctx.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
        GL.anisotropicExt = Module.ctx.getExtension('EXT_texture_filter_anisotropic') ||
                            Module.ctx.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                            Module.ctx.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
        GL.floatExt = Module.ctx.getExtension('OES_texture_float');
        GL.elementIndexUintExt = Module.ctx.getExtension('OES_element_index_uint');
        GL.standardDerivativesExt = Module.ctx.getExtension('OES_standard_derivatives');
      }};function _glDeleteTextures(n, textures) {
      for (var i = 0; i < n; i++) {
        var id = HEAP32[(((textures)+(i*4))>>2)];
        var texture = GL.textures[id];
        Module.ctx.deleteTexture(texture);
        texture.name = 0;
        GL.textures[id] = null;
      }
    }
  function _sprintf(s, format, varargs) {
      // int sprintf(char *restrict s, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      return _snprintf(s, undefined, format, varargs);
    }
  function _emscripten_run_script(ptr) {
      eval(Pointer_stringify(ptr));
    }
;
;
  function _strdup(ptr) {
      var len = _strlen(ptr);
      var newStr = _malloc(len + 1);
      (_memcpy(newStr, ptr, len)|0);
      HEAP8[(((newStr)+(len))|0)]=0;
      return newStr;
    }
;
;
;
;
;
;
;
;
  function _abort() {
      Module['abort']();
    }
  function ___errno_location() {
      return ___errno_state;
    }var ___errno=___errno_location;
  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }
  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 8: return PAGE_SIZE;
        case 54:
        case 56:
        case 21:
        case 61:
        case 63:
        case 22:
        case 67:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 69:
        case 28:
        case 101:
        case 70:
        case 71:
        case 29:
        case 30:
        case 199:
        case 75:
        case 76:
        case 32:
        case 43:
        case 44:
        case 80:
        case 46:
        case 47:
        case 45:
        case 48:
        case 49:
        case 42:
        case 82:
        case 33:
        case 7:
        case 108:
        case 109:
        case 107:
        case 112:
        case 119:
        case 121:
          return 200809;
        case 13:
        case 104:
        case 94:
        case 95:
        case 34:
        case 35:
        case 77:
        case 81:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 94:
        case 95:
        case 110:
        case 111:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 120:
        case 40:
        case 16:
        case 79:
        case 19:
          return -1;
        case 92:
        case 93:
        case 5:
        case 72:
        case 6:
        case 74:
        case 92:
        case 93:
        case 96:
        case 97:
        case 98:
        case 99:
        case 102:
        case 103:
        case 105:
          return 1;
        case 38:
        case 66:
        case 50:
        case 51:
        case 4:
          return 1024;
        case 15:
        case 64:
        case 41:
          return 32;
        case 55:
        case 37:
        case 17:
          return 2147483647;
        case 18:
        case 1:
          return 47839;
        case 59:
        case 57:
          return 99;
        case 68:
        case 58:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 14: return 32768;
        case 73: return 32767;
        case 39: return 16384;
        case 60: return 1000;
        case 106: return 700;
        case 52: return 256;
        case 62: return 255;
        case 2: return 100;
        case 65: return 64;
        case 36: return 20;
        case 100: return 16;
        case 20: return 6;
        case 53: return 4;
        case 10: return 1;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }
  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret
      }
      return ret;
    }
  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }
  function _llvm_eh_exception() {
      return HEAP32[((_llvm_eh_exception.buf)>>2)];
    }
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  function ___cxa_is_number_type(type) {
      var isNumber = false;
      try { if (type == __ZTIi) isNumber = true } catch(e){}
      try { if (type == __ZTIj) isNumber = true } catch(e){}
      try { if (type == __ZTIl) isNumber = true } catch(e){}
      try { if (type == __ZTIm) isNumber = true } catch(e){}
      try { if (type == __ZTIx) isNumber = true } catch(e){}
      try { if (type == __ZTIy) isNumber = true } catch(e){}
      try { if (type == __ZTIf) isNumber = true } catch(e){}
      try { if (type == __ZTId) isNumber = true } catch(e){}
      try { if (type == __ZTIe) isNumber = true } catch(e){}
      try { if (type == __ZTIc) isNumber = true } catch(e){}
      try { if (type == __ZTIa) isNumber = true } catch(e){}
      try { if (type == __ZTIh) isNumber = true } catch(e){}
      try { if (type == __ZTIs) isNumber = true } catch(e){}
      try { if (type == __ZTIt) isNumber = true } catch(e){}
      return isNumber;
    }function ___cxa_does_inherit(definiteType, possibilityType, possibility) {
      if (possibility == 0) return false;
      if (possibilityType == 0 || possibilityType == definiteType)
        return true;
      var possibility_type_info;
      if (___cxa_is_number_type(possibilityType)) {
        possibility_type_info = possibilityType;
      } else {
        var possibility_type_infoAddr = HEAP32[((possibilityType)>>2)] - 8;
        possibility_type_info = HEAP32[((possibility_type_infoAddr)>>2)];
      }
      switch (possibility_type_info) {
      case 0: // possibility is a pointer
        // See if definite type is a pointer
        var definite_type_infoAddr = HEAP32[((definiteType)>>2)] - 8;
        var definite_type_info = HEAP32[((definite_type_infoAddr)>>2)];
        if (definite_type_info == 0) {
          // Also a pointer; compare base types of pointers
          var defPointerBaseAddr = definiteType+8;
          var defPointerBaseType = HEAP32[((defPointerBaseAddr)>>2)];
          var possPointerBaseAddr = possibilityType+8;
          var possPointerBaseType = HEAP32[((possPointerBaseAddr)>>2)];
          return ___cxa_does_inherit(defPointerBaseType, possPointerBaseType, possibility);
        } else
          return false; // one pointer and one non-pointer
      case 1: // class with no base class
        return false;
      case 2: // class with base class
        var parentTypeAddr = possibilityType + 8;
        var parentType = HEAP32[((parentTypeAddr)>>2)];
        return ___cxa_does_inherit(definiteType, parentType, possibility);
      default:
        return false; // some unencountered type
      }
    }
  function ___resumeException(ptr) {
      if (HEAP32[((_llvm_eh_exception.buf)>>2)] == 0) HEAP32[((_llvm_eh_exception.buf)>>2)]=ptr;
      throw ptr;;
    }function ___cxa_find_matching_catch(thrown, throwntype) {
      if (thrown == -1) thrown = HEAP32[((_llvm_eh_exception.buf)>>2)];
      if (throwntype == -1) throwntype = HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)];
      var typeArray = Array.prototype.slice.call(arguments, 2);
      // If throwntype is a pointer, this means a pointer has been
      // thrown. When a pointer is thrown, actually what's thrown
      // is a pointer to the pointer. We'll dereference it.
      if (throwntype != 0 && !___cxa_is_number_type(throwntype)) {
        var throwntypeInfoAddr= HEAP32[((throwntype)>>2)] - 8;
        var throwntypeInfo= HEAP32[((throwntypeInfoAddr)>>2)];
        if (throwntypeInfo == 0)
          thrown = HEAP32[((thrown)>>2)];
      }
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (___cxa_does_inherit(typeArray[i], throwntype, thrown))
          return tempRet0 = typeArray[i],thrown;
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      return tempRet0 = throwntype,thrown;
    }function ___cxa_throw(ptr, type, destructor) {
      if (!___cxa_throw.initialized) {
        try {
          HEAP32[((__ZTVN10__cxxabiv119__pointer_type_infoE)>>2)]=0; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv117__class_type_infoE)>>2)]=1; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv120__si_class_type_infoE)>>2)]=2; // Workaround for libcxxabi integration bug
        } catch(e){}
        ___cxa_throw.initialized = true;
      }
      HEAP32[((_llvm_eh_exception.buf)>>2)]=ptr
      HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)]=type
      HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)]=destructor
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr;;
    }
  function ___cxa_call_unexpected(exception) {
      Module.printErr('Unexpected exception thrown, this is not properly supported - aborting');
      ABORT = true;
      throw exception;
    }
  function _llvm_lifetime_start() {}
  function _llvm_lifetime_end() {}
  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
        if (Browser.initted || ENVIRONMENT_IS_WORKER) return;
        Browser.initted = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
        var imagePlugin = {};
        imagePlugin['canHandle'] = function(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
        var audioPlugin = {};
        audioPlugin['canHandle'] = function(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
        // Canvas event setup
        var canvas = Module['canvas'];
        canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                    canvas['mozRequestPointerLock'] ||
                                    canvas['webkitRequestPointerLock'];
        canvas.exitPointerLock = document['exitPointerLock'] ||
                                 document['mozExitPointerLock'] ||
                                 document['webkitExitPointerLock'] ||
                                 function(){}; // no-op if function does not exist
        canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        if (Module['elementPointerLock']) {
          canvas.addEventListener("click", function(ev) {
            if (!Browser.pointerLock && canvas.requestPointerLock) {
              canvas.requestPointerLock();
              ev.preventDefault();
            }
          }, false);
        }
      },createContext:function (canvas, useWebGL, setInModule) {
        var ctx;
        try {
          if (useWebGL) {
            ctx = canvas.getContext('experimental-webgl', {
              alpha: false
            });
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas - ' + e);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'];
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else if (Browser.resizeCanvas){
            Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
        }
        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
        }
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen();
      },requestAnimationFrame:function (func) {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                         window['mozRequestAnimationFrame'] ||
                                         window['webkitRequestAnimationFrame'] ||
                                         window['msRequestAnimationFrame'] ||
                                         window['oRequestAnimationFrame'] ||
                                         window['setTimeout'];
        }
        window.requestAnimationFrame(func);
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (!ABORT) func();
        });
      },safeSetTimeout:function (func, timeout) {
        return setTimeout(function() {
          if (!ABORT) func();
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        return setInterval(function() {
          if (!ABORT) func();
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
          // check if SDL is available
          if (typeof SDL != "undefined") {
          	Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
          	Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
          	// just add the mouse delta to the current absolut mouse position
          	// FIXME: ideally this should be clamped against the canvas size and zero
          	Browser.mouseX += Browser.mouseMovementX;
          	Browser.mouseY += Browser.mouseMovementY;
          }        
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var x = event.pageX - (window.scrollX + rect.left);
          var y = event.pageY - (window.scrollY + rect.top);
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        var canvas = Module['canvas'];
        this.windowedWidth = canvas.width;
        this.windowedHeight = canvas.height;
        canvas.width = screen.width;
        canvas.height = screen.height;
        // check if SDL is available   
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        var canvas = Module['canvas'];
        canvas.width = this.windowedWidth;
        canvas.height = this.windowedHeight;
        // check if SDL is available       
        if (typeof SDL != "undefined") {
        	var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
        	flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
        	HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      }};
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
GL.init()
_llvm_eh_exception.buf = allocate(12, "void*", ALLOC_STATIC);
Module["requestFullScreen"] = function(lockPointer, resizeCanvas) { Browser.requestFullScreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function(func) { Browser.requestAnimationFrame(func) };
  Module["pauseMainLoop"] = function() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function() { Browser.getUserMedia() }
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);
staticSealed = true; // seal the static portion of memory
STACK_MAX = STACK_BASE + 5242880;
DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);
assert(DYNAMIC_BASE < TOTAL_MEMORY); // Stack must fit in TOTAL_MEMORY; allocations from here on may enlarge TOTAL_MEMORY
var FUNCTION_TABLE = [0,0,__Z15set_agentHeightf,0,__Z19bareGeomAddTriangleiiii,0,__ZL12compareItemYPKvS0_337,0,__Z17set_regionMinSizef,0,__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib
,0,__Z12set_cellSizef,0,__ZNSt9bad_allocD0Ev,0,__ZN10__cxxabiv123__fundamental_type_infoD0Ev,0,__ZL12compareItemYPKvS0_,0,__ZN10__cxxabiv117__class_type_infoD0Ev
,0,__Z15set_agentRadiusf,0,__ZN10emscripten8internal7InvokerIvJfEE6invokeEPFvfEf,0,__Z12bareGeomInitv,0,__Z4initv,0,__ZNKSt9bad_alloc4whatEv
,0,__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,0,__Z14set_edgeMaxLenf,0,__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,0,__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv,0,__ZL12compareItemXPKvS0_336
,0,__ZL12compareItemXPKvS0_,0,__Z5buildv,0,__ZN16GLCheckerTextureD1Ev,0,__ZN10__cxxabiv116__shim_type_infoD2Ev,0,__ZN10emscripten8internal7InvokerIvJEE6invokeEPFvvE
,0,__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,0,__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv,0,__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,0,__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,0,__Z19set_regionMergeSizef
,0,__Z17set_agentMaxSlopef,0,__Z11getMaxTilesv,0,__Z16set_edgeMaxErrorf,0,__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,0,__ZNK10__cxxabiv116__shim_type_info5noop1Ev
,0,__Z17bareGeomAddVertexfffi,0,___getTypeName,0,__Z14set_cellHeightf,0,__ZN10emscripten8internal7InvokerIbJEE6invokeEPFbvE,0,__Z16iterateOnNavMeshv
,0,__Z16bareGeomValidatev,0,__ZN10__cxxabiv121__vmi_class_type_infoD0Ev,0,__ZL12compareItemZPKvS0_,0,__Z24set_detailSampleMaxErrorf,0,__Z12initWithFilev
,0,__ZN10emscripten8internal7InvokerIvJfffiEE6invokeEPFvfffiEfffi,0,__ZN10__cxxabiv120__si_class_type_infoD0Ev,0,__ZN10emscripten8internal7InvokerIiJEE6invokeEPFivE,0,__Z17set_agentMaxClimbf,0,__ZNK10__cxxabiv116__shim_type_info5noop2Ev
,0,__Z20set_detailSampleDistf,0,__Z16set_vertsPerPolyf,0,__ZN10emscripten8internal7InvokerIvJiiiiEE6invokeEPFviiiiEiiii,0,__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,0,__ZNSt9bad_allocD2Ev,0,__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi];
// EMSCRIPTEN_START_FUNCS
function __Z13dtFreeNavMeshP9dtNavMesh($navmesh) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($navmesh)|(0))==0;
   if ($1) { label = 14; break; } else { label = 2; break; }
  case 2: 
   var $3=(($navmesh+48)|0);
   var $4=(($navmesh+68)|0);
   var $storemerge_i = 0;label = 3; break;
  case 3: 
   var $storemerge_i;
   var $6=HEAP32[(($3)>>2)];
   var $7=(($storemerge_i)|(0)) < (($6)|(0));
   if ($7) { label = 4; break; } else { label = 9; break; }
  case 4: 
   var $9=HEAP32[(($4)>>2)];
   var $10=(($9+((($storemerge_i)*(60))&-1)+52)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=$11 & 1;
   var $13=(($12)|(0))==0;
   if ($13) { label = 8; break; } else { label = 5; break; }
  case 5: 
   var $15=(($9+((($storemerge_i)*(60))&-1)+44)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=(($16)|(0))==0;
   if ($17) { var $19 = $9;label = 7; break; } else { label = 6; break; }
  case 6: 
   _free($16);
   var $_pre=HEAP32[(($4)>>2)];
   var $19 = $_pre;label = 7; break;
  case 7: 
   var $19;
   var $20=(($19+((($storemerge_i)*(60))&-1)+44)|0);
   HEAP32[(($20)>>2)]=0;
   var $21=HEAP32[(($4)>>2)];
   var $22=(($21+((($storemerge_i)*(60))&-1)+48)|0);
   HEAP32[(($22)>>2)]=0;
   label = 8; break;
  case 8: 
   var $24=((($storemerge_i)+(1))|0);
   var $storemerge_i = $24;label = 3; break;
  case 9: 
   var $26=(($navmesh+60)|0);
   var $27=HEAP32[(($26)>>2)];
   var $28=(($27)|(0))==0;
   if ($28) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $30=$27;
   _free($30);
   label = 11; break;
  case 11: 
   var $31=HEAP32[(($4)>>2)];
   var $32=(($31)|(0))==0;
   if ($32) { label = 13; break; } else { label = 12; break; }
  case 12: 
   var $34=$31;
   _free($34);
   label = 13; break;
  case 13: 
   var $35=$navmesh;
   _free($35);
   label = 14; break;
  case 14: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9dtNavMesh4initEPK15dtNavMeshParams($this, $params) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=$this;
   var $2=$params;
   assert(28 % 1 === 0);HEAP32[(($1)>>2)]=HEAP32[(($2)>>2)];HEAP32[((($1)+(4))>>2)]=HEAP32[((($2)+(4))>>2)];HEAP32[((($1)+(8))>>2)]=HEAP32[((($2)+(8))>>2)];HEAP32[((($1)+(12))>>2)]=HEAP32[((($2)+(12))>>2)];HEAP32[((($1)+(16))>>2)]=HEAP32[((($2)+(16))>>2)];HEAP32[((($1)+(20))>>2)]=HEAP32[((($2)+(20))>>2)];HEAP32[((($1)+(24))>>2)]=HEAP32[((($2)+(24))>>2)];
   var $3=(($this+28)|0);
   var $4=(($params)|0);
   var $5=HEAPF32[(($4)>>2)];
   HEAPF32[(($3)>>2)]=$5;
   var $6=(($params+4)|0);
   var $7=HEAPF32[(($6)>>2)];
   var $8=(($this+32)|0);
   HEAPF32[(($8)>>2)]=$7;
   var $9=(($params+8)|0);
   var $10=HEAPF32[(($9)>>2)];
   var $11=(($this+36)|0);
   HEAPF32[(($11)>>2)]=$10;
   var $12=(($params+12)|0);
   var $13=HEAPF32[(($12)>>2)];
   var $14=(($this+40)|0);
   HEAPF32[(($14)>>2)]=$13;
   var $15=(($params+16)|0);
   var $16=HEAPF32[(($15)>>2)];
   var $17=(($this+44)|0);
   HEAPF32[(($17)>>2)]=$16;
   var $18=(($params+20)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($this+48)|0);
   HEAP32[(($20)>>2)]=$19;
   var $21=HEAP32[(($18)>>2)];
   var $22=((((($21)|(0)))/(4))&-1);
   var $23=((($22)-(1))|0);
   var $24=$23 >>> 1;
   var $25=$23 | $24;
   var $26=$25 >>> 2;
   var $27=$25 | $26;
   var $28=$27 >>> 4;
   var $29=$27 | $28;
   var $30=$29 >>> 8;
   var $31=$29 | $30;
   var $32=$31 >>> 16;
   var $33=$31 | $32;
   var $34=((($33)+(1))|0);
   var $35=(($this+52)|0);
   var $36=(($34)|(0))==0;
   var $_=$36 ? 1 : $34;
   HEAP32[(($35)>>2)]=$_;
   var $37=((($_)-(1))|0);
   var $38=(($this+56)|0);
   HEAP32[(($38)>>2)]=$37;
   var $39=((($19)*(60))&-1);
   var $40=_malloc($39);
   var $41=$40;
   var $42=(($this+68)|0);
   HEAP32[(($42)>>2)]=$41;
   var $43=(($40)|(0))==0;
   if ($43) { label = 7; break; } else { label = 2; break; }
  case 2: 
   var $45=HEAP32[(($35)>>2)];
   var $46=$45 << 2;
   var $47=_malloc($46);
   var $48=$47;
   var $49=(($this+60)|0);
   HEAP32[(($49)>>2)]=$48;
   var $50=(($47)|(0))==0;
   if ($50) { label = 7; break; } else { label = 3; break; }
  case 3: 
   var $52=HEAP32[(($42)>>2)];
   var $53=$52;
   var $54=HEAP32[(($20)>>2)];
   var $55=((($54)*(60))&-1);
   _memset($53, 0, $55);
   var $56=HEAP32[(($49)>>2)];
   var $57=$56;
   var $58=HEAP32[(($35)>>2)];
   var $59=$58 << 2;
   _memset($57, 0, $59);
   var $60=(($this+64)|0);
   HEAP32[(($60)>>2)]=0;
   var $61=HEAP32[(($20)>>2)];
   var $storemerge_in = $61;label = 4; break;
  case 4: 
   var $storemerge_in;
   var $storemerge=((($storemerge_in)-(1))|0);
   var $63=(($storemerge_in)|(0)) > 0;
   if ($63) { label = 5; break; } else { label = 6; break; }
  case 5: 
   var $65=HEAP32[(($42)>>2)];
   var $66=(($65+((($storemerge)*(60))&-1))|0);
   HEAP32[(($66)>>2)]=1;
   var $67=HEAP32[(($60)>>2)];
   var $68=HEAP32[(($42)>>2)];
   var $69=(($68+((($storemerge)*(60))&-1)+56)|0);
   HEAP32[(($69)>>2)]=$67;
   var $70=HEAP32[(($42)>>2)];
   var $71=(($70+((($storemerge)*(60))&-1))|0);
   HEAP32[(($60)>>2)]=$71;
   var $storemerge_in = $storemerge;label = 4; break;
  case 6: 
   var $73=HEAP32[(($18)>>2)];
   var $74=((($73)-(1))|0);
   var $75=$74 >>> 1;
   var $76=$74 | $75;
   var $77=$76 >>> 2;
   var $78=$76 | $77;
   var $79=$78 >>> 4;
   var $80=$78 | $79;
   var $81=$80 >>> 8;
   var $82=$80 | $81;
   var $83=$82 >>> 16;
   var $84=$82 | $83;
   var $85=((($84)+(1))|0);
   var $86=(($85)>>>(0)) > 65535;
   var $87=(($86)&(1));
   var $88=$87 << 4;
   var $89=$85 >>> (($88)>>>(0));
   var $90=(($89)>>>(0)) > 255;
   var $91=(($90)&(1));
   var $92=$91 << 3;
   var $93=$89 >>> (($92)>>>(0));
   var $94=$88 | $92;
   var $95=(($93)>>>(0)) > 15;
   var $96=(($95)&(1));
   var $97=$96 << 2;
   var $98=$93 >>> (($97)>>>(0));
   var $99=$94 | $97;
   var $100=(($98)>>>(0)) > 3;
   var $101=(($100)&(1));
   var $102=$101 << 1;
   var $103=$98 >>> (($102)>>>(0));
   var $104=$99 | $102;
   var $105=$103 >>> 1;
   var $106=$104 | $105;
   var $107=(($this+76)|0);
   HEAP32[(($107)>>2)]=$106;
   var $108=(($params+24)|0);
   var $109=HEAP32[(($108)>>2)];
   var $110=((($109)-(1))|0);
   var $111=$110 >>> 1;
   var $112=$110 | $111;
   var $113=$112 >>> 2;
   var $114=$112 | $113;
   var $115=$114 >>> 4;
   var $116=$114 | $115;
   var $117=$116 >>> 8;
   var $118=$116 | $117;
   var $119=$118 >>> 16;
   var $120=$118 | $119;
   var $121=((($120)+(1))|0);
   var $122=(($121)>>>(0)) > 65535;
   var $123=(($122)&(1));
   var $124=$123 << 4;
   var $125=$121 >>> (($124)>>>(0));
   var $126=(($125)>>>(0)) > 255;
   var $127=(($126)&(1));
   var $128=$127 << 3;
   var $129=$125 >>> (($128)>>>(0));
   var $130=$124 | $128;
   var $131=(($129)>>>(0)) > 15;
   var $132=(($131)&(1));
   var $133=$132 << 2;
   var $134=$129 >>> (($133)>>>(0));
   var $135=$130 | $133;
   var $136=(($134)>>>(0)) > 3;
   var $137=(($136)&(1));
   var $138=$137 << 1;
   var $139=$134 >>> (($138)>>>(0));
   var $140=$135 | $138;
   var $141=$139 >>> 1;
   var $142=$140 | $141;
   var $143=(($this+80)|0);
   HEAP32[(($143)>>2)]=$142;
   var $144=(((32)-($106))|0);
   var $145=((($144)-($142))|0);
   var $146=(($145)>>>(0)) > 31;
   var $147=$146 ? 31 : $145;
   var $148=(($this+72)|0);
   HEAP32[(($148)>>2)]=$147;
   var $149=(($147)>>>(0)) < 10;
   var $_34=$149 ? -2147483640 : 1073741824;
   return $_34;
  case 7: 
   return -2147483644;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9dtNavMesh4initEPhii($this, $data, $dataSize) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $params=sp;
   var $1=$data;
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0))==1145979222;
   if ($3) { label = 2; break; } else { var $_0 = -2147483647;label = 5; break; }
  case 2: 
   var $5=(($data+4)|0);
   var $6=$5;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7)|(0))==7;
   if ($8) { label = 3; break; } else { var $_0 = -2147483646;label = 5; break; }
  case 3: 
   var $10=(($params)|0);
   var $11=(($data+72)|0);
   var $12=$11;
   var $13=HEAPF32[(($12)>>2)];
   HEAPF32[(($10)>>2)]=$13;
   var $14=(($data+76)|0);
   var $15=$14;
   var $16=HEAPF32[(($15)>>2)];
   var $17=(($params+4)|0);
   HEAPF32[(($17)>>2)]=$16;
   var $18=(($data+80)|0);
   var $19=$18;
   var $20=HEAPF32[(($19)>>2)];
   var $21=(($params+8)|0);
   HEAPF32[(($21)>>2)]=$20;
   var $22=(($data+84)|0);
   var $23=$22;
   var $24=HEAPF32[(($23)>>2)];
   var $25=($24)-($13);
   var $26=(($params+12)|0);
   HEAPF32[(($26)>>2)]=$25;
   var $27=(($data+92)|0);
   var $28=$27;
   var $29=HEAPF32[(($28)>>2)];
   var $30=($29)-($20);
   var $31=(($params+16)|0);
   HEAPF32[(($31)>>2)]=$30;
   var $32=(($params+20)|0);
   HEAP32[(($32)>>2)]=1;
   var $33=(($data+24)|0);
   var $34=$33;
   var $35=HEAP32[(($34)>>2)];
   var $36=(($params+24)|0);
   HEAP32[(($36)>>2)]=$35;
   var $37=__ZN9dtNavMesh4initEPK15dtNavMeshParams($this, $params);
   var $38=(($37)|(0)) < 0;
   if ($38) { var $_0 = $37;label = 5; break; } else { label = 4; break; }
  case 4: 
   var $40=__ZN9dtNavMesh7addTileEPhiijPj($this, $data, $dataSize, 1, 0);
   var $_0 = $40;label = 5; break;
  case 5: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9dtNavMesh7addTileEPhiijPj($this, $data, $dataSize, $flags, $lastRef) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 160)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $ext_i=sp;
   var $nearestPt_i=(sp)+(16);
   var $neis=(sp)+(32);
   var $1=$data;
   var $2=$data;
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|(0))==1145979222;
   if ($4) { label = 2; break; } else { var $_0 = -2147483647;label = 54; break; }
  case 2: 
   var $6=(($data+4)|0);
   var $7=$6;
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==7;
   if ($9) { label = 3; break; } else { var $_0 = -2147483646;label = 54; break; }
  case 3: 
   var $11=(($data+8)|0);
   var $12=$11;
   var $13=HEAP32[(($12)>>2)];
   var $14=(($data+12)|0);
   var $15=$14;
   var $16=HEAP32[(($15)>>2)];
   var $17=(($data+16)|0);
   var $18=$17;
   var $19=HEAP32[(($18)>>2)];
   var $20=(($this+56)|0);
   var $21=HEAP32[(($20)>>2)];
   var $22=(Math.imul($13,-1918454973)|0);
   var $23=(Math.imul($16,-669632447)|0);
   var $24=((($22)+($23))|0);
   var $25=$24 & $21;
   var $26=(($this+60)|0);
   var $27=HEAP32[(($26)>>2)];
   var $28=(($27+($25<<2))|0);
   var $storemerge_in_i = $28;label = 4; break;
  case 4: 
   var $storemerge_in_i;
   var $storemerge_i=HEAP32[(($storemerge_in_i)>>2)];
   var $30=(($storemerge_i)|(0))==0;
   if ($30) { label = 10; break; } else { label = 5; break; }
  case 5: 
   var $32=(($storemerge_i+8)|0);
   var $33=HEAP32[(($32)>>2)];
   var $34=(($33)|(0))==0;
   if ($34) { label = 9; break; } else { label = 6; break; }
  case 6: 
   var $36=(($33+8)|0);
   var $37=HEAP32[(($36)>>2)];
   var $38=(($37)|(0))==(($13)|(0));
   if ($38) { label = 7; break; } else { label = 9; break; }
  case 7: 
   var $40=(($33+12)|0);
   var $41=HEAP32[(($40)>>2)];
   var $42=(($41)|(0))==(($16)|(0));
   if ($42) { label = 8; break; } else { label = 9; break; }
  case 8: 
   var $44=(($33+16)|0);
   var $45=HEAP32[(($44)>>2)];
   var $46=(($45)|(0))==(($19)|(0));
   if ($46) { var $_0 = -2147483648;label = 54; break; } else { label = 9; break; }
  case 9: 
   var $48=(($storemerge_i+56)|0);
   var $storemerge_in_i = $48;label = 4; break;
  case 10: 
   var $50=(($lastRef)|(0))==0;
   if ($50) { label = 11; break; } else { label = 13; break; }
  case 11: 
   var $52=(($this+64)|0);
   var $53=HEAP32[(($52)>>2)];
   var $54=(($53)|(0))==0;
   if ($54) { var $_0 = -2147483644;label = 54; break; } else { label = 12; break; }
  case 12: 
   var $55=(($53+56)|0);
   var $56=HEAP32[(($55)>>2)];
   HEAP32[(($52)>>2)]=$56;
   HEAP32[(($55)>>2)]=0;
   var $tile_0269 = $53;label = 22; break;
  case 13: 
   var $58=(($this+76)|0);
   var $59=HEAP32[(($58)>>2)];
   var $60=1 << $59;
   var $61=((($60)-(1))|0);
   var $62=(($this+80)|0);
   var $63=HEAP32[(($62)>>2)];
   var $64=$lastRef >>> (($63)>>>(0));
   var $65=$64 & $61;
   var $66=(($this+48)|0);
   var $67=HEAP32[(($66)>>2)];
   var $68=(($65)|(0)) < (($67)|(0));
   if ($68) { label = 14; break; } else { var $_0 = -2147483644;label = 54; break; }
  case 14: 
   var $70=(($this+68)|0);
   var $71=HEAP32[(($70)>>2)];
   var $72=(($71+((($65)*(60))&-1))|0);
   var $73=(($this+64)|0);
   var $storemerge4_in = $73;var $prev_0 = 0;label = 15; break;
  case 15: 
   var $prev_0;
   var $storemerge4_in;
   var $storemerge4=HEAP32[(($storemerge4_in)>>2)];
   var $75=(($storemerge4)|(0))!=0;
   var $76=(($storemerge4)|(0))!=(($72)|(0));
   var $or_cond=$75 & $76;
   if ($or_cond) { label = 16; break; } else { label = 17; break; }
  case 16: 
   var $78=(($storemerge4+56)|0);
   var $storemerge4_in = $78;var $prev_0 = $storemerge4;label = 15; break;
  case 17: 
   var $79=(($storemerge4)|(0))==(($72)|(0));
   if ($79) { label = 18; break; } else { var $_0 = -2147483644;label = 54; break; }
  case 18: 
   var $81=(($prev_0)|(0))==0;
   var $82=(($71+((($65)*(60))&-1)+56)|0);
   var $83=HEAP32[(($82)>>2)];
   if ($81) { label = 19; break; } else { label = 20; break; }
  case 19: 
   HEAP32[(($73)>>2)]=$83;
   var $89 = $63;var $88 = $59;label = 21; break;
  case 20: 
   var $86=(($prev_0+56)|0);
   HEAP32[(($86)>>2)]=$83;
   var $_pre255=HEAP32[(($62)>>2)];
   var $_pre256=HEAP32[(($58)>>2)];
   var $89 = $_pre255;var $88 = $_pre256;label = 21; break;
  case 21: 
   var $88;
   var $89;
   var $90=(($this+72)|0);
   var $91=HEAP32[(($90)>>2)];
   var $92=1 << $91;
   var $93=((($92)-(1))|0);
   var $94=((($89)+($88))|0);
   var $95=$lastRef >>> (($94)>>>(0));
   var $96=$95 & $93;
   var $97=(($72)|0);
   HEAP32[(($97)>>2)]=$96;
   var $98=(($72)|(0))==0;
   if ($98) { var $_0 = -2147483644;label = 54; break; } else { var $tile_0269 = $72;label = 22; break; }
  case 22: 
   var $tile_0269;
   var $100=HEAP32[(($12)>>2)];
   var $101=HEAP32[(($15)>>2)];
   var $102=HEAP32[(($20)>>2)];
   var $103=(Math.imul($100,-1918454973)|0);
   var $104=(Math.imul($101,-669632447)|0);
   var $105=((($103)+($104))|0);
   var $106=$105 & $102;
   var $107=HEAP32[(($26)>>2)];
   var $108=(($107+($106<<2))|0);
   var $109=HEAP32[(($108)>>2)];
   var $110=(($tile_0269+56)|0);
   HEAP32[(($110)>>2)]=$109;
   var $111=HEAP32[(($26)>>2)];
   var $112=(($111+($106<<2))|0);
   HEAP32[(($112)>>2)]=$tile_0269;
   var $113=(($data+28)|0);
   var $114=$113;
   var $115=HEAP32[(($114)>>2)];
   var $116=((($115)*(12))&-1);
   var $117=(($data+24)|0);
   var $118=$117;
   var $119=HEAP32[(($118)>>2)];
   var $120=$119 << 5;
   var $121=(($data+32)|0);
   var $122=$121;
   var $123=HEAP32[(($122)>>2)];
   var $124=((($123)*(12))&-1);
   var $125=(($data+36)|0);
   var $126=$125;
   var $127=HEAP32[(($126)>>2)];
   var $128=((($127)*(12))&-1);
   var $129=(($data+40)|0);
   var $130=$129;
   var $131=HEAP32[(($130)>>2)];
   var $132=((($131)*(12))&-1);
   var $133=(($data+44)|0);
   var $134=$133;
   var $135=HEAP32[(($134)>>2)];
   var $136=$135 << 2;
   var $137=(($data+48)|0);
   var $138=$137;
   var $139=HEAP32[(($138)>>2)];
   var $140=$139 << 4;
   var $141=(($data+100)|0);
   var $142=$141;
   var $143=(($tile_0269+16)|0);
   HEAP32[(($143)>>2)]=$142;
   var $_sum=((($116)+(100))|0);
   var $144=(($data+$_sum)|0);
   var $145=$144;
   var $146=(($tile_0269+12)|0);
   HEAP32[(($146)>>2)]=$145;
   var $_sum258=((($_sum)+($120))|0);
   var $147=(($data+$_sum258)|0);
   var $148=$147;
   var $149=(($tile_0269+20)|0);
   HEAP32[(($149)>>2)]=$148;
   var $_sum259=((($_sum258)+($124))|0);
   var $150=(($data+$_sum259)|0);
   var $151=$150;
   var $152=(($tile_0269+24)|0);
   HEAP32[(($152)>>2)]=$151;
   var $_sum260=((($_sum259)+($128))|0);
   var $153=(($data+$_sum260)|0);
   var $154=$153;
   var $155=(($tile_0269+28)|0);
   HEAP32[(($155)>>2)]=$154;
   var $_sum261=((($_sum260)+($132))|0);
   var $156=(($data+$_sum261)|0);
   var $157=(($tile_0269+32)|0);
   HEAP32[(($157)>>2)]=$156;
   var $_sum262=((($_sum261)+($136))|0);
   var $158=(($data+$_sum262)|0);
   var $159=$158;
   var $160=(($tile_0269+36)|0);
   HEAP32[(($160)>>2)]=$159;
   var $_sum263=((($_sum262)+($140))|0);
   var $161=(($data+$_sum263)|0);
   var $162=$161;
   var $163=(($tile_0269+40)|0);
   HEAP32[(($163)>>2)]=$162;
   var $164=(($140)|(0))==0;
   if ($164) { label = 23; break; } else { label = 24; break; }
  case 23: 
   HEAP32[(($160)>>2)]=0;
   label = 24; break;
  case 24: 
   var $167=(($tile_0269+4)|0);
   HEAP32[(($167)>>2)]=0;
   var $168=HEAP32[(($122)>>2)];
   var $169=((($168)-(1))|0);
   var $170=(($148+((($169)*(12))&-1)+4)|0);
   HEAP32[(($170)>>2)]=-1;
   var $storemerge = 0;label = 25; break;
  case 25: 
   var $storemerge;
   var $172=HEAP32[(($122)>>2)];
   var $173=((($172)-(1))|0);
   var $174=(($storemerge)|(0)) < (($173)|(0));
   if ($174) { label = 26; break; } else { label = 27; break; }
  case 26: 
   var $176=((($storemerge)+(1))|0);
   var $177=HEAP32[(($149)>>2)];
   var $178=(($177+((($storemerge)*(12))&-1)+4)|0);
   HEAP32[(($178)>>2)]=$176;
   var $storemerge = $176;label = 25; break;
  case 27: 
   var $179=(($tile_0269+8)|0);
   HEAP32[(($179)>>2)]=$1;
   var $180=(($tile_0269+44)|0);
   HEAP32[(($180)>>2)]=$data;
   var $181=(($tile_0269+48)|0);
   HEAP32[(($181)>>2)]=$dataSize;
   var $182=(($tile_0269+52)|0);
   HEAP32[(($182)>>2)]=$flags;
   var $183=(($this+68)|0);
   var $184=HEAP32[(($183)>>2)];
   var $185=$tile_0269;
   var $186=$184;
   var $187=((($185)-($186))|0);
   var $188=((((($187)|(0)))/(60))&-1);
   var $189=(($tile_0269)|0);
   var $190=HEAP32[(($189)>>2)];
   var $191=(($this+80)|0);
   var $192=HEAP32[(($191)>>2)];
   var $193=(($this+76)|0);
   var $194=HEAP32[(($193)>>2)];
   var $195=((($192)+($194))|0);
   var $196=$190 << $195;
   var $197=$188 << $192;
   var $198=$196 | $197;
   var $storemerge_i15 = 0;var $200 = $1;label = 28; break;
  case 28: 
   var $200;
   var $storemerge_i15;
   var $201=(($200+24)|0);
   var $202=HEAP32[(($201)>>2)];
   var $203=(($storemerge_i15)|(0)) < (($202)|(0));
   if ($203) { label = 29; break; } else { label = 36; break; }
  case 29: 
   var $205=HEAP32[(($146)>>2)];
   var $206=(($205+($storemerge_i15<<5))|0);
   HEAP32[(($206)>>2)]=-1;
   var $207=(($205+($storemerge_i15<<5)+31)|0);
   var $208=HEAP8[($207)];
   var $_mask=$208 & -64;
   var $209=(($_mask << 24) >> 24)==64;
   if ($209) { label = 35; break; } else { label = 30; break; }
  case 30: 
   var $211=(($205+($storemerge_i15<<5)+30)|0);
   var $212=HEAP8[($211)];
   var $213=(($212)&(255));
   var $storemerge1_in_i = $213;label = 31; break;
  case 31: 
   var $storemerge1_in_i;
   var $storemerge1_i16=((($storemerge1_in_i)-(1))|0);
   var $214=(($storemerge1_in_i)|(0)) > 0;
   if ($214) { label = 32; break; } else { label = 35; break; }
  case 32: 
   var $216=(($205+($storemerge_i15<<5)+16+($storemerge1_i16<<1))|0);
   var $217=HEAP16[(($216)>>1)];
   var $218=(($217 << 16) >> 16)==0;
   var $219=(($217 << 16) >> 16) < 0;
   var $or_cond270=$218 | $219;
   if ($or_cond270) { var $storemerge1_in_i = $storemerge1_i16;label = 31; break; } else { label = 33; break; }
  case 33: 
   var $221=HEAP32[(($167)>>2)];
   var $222=(($221)|(0))==-1;
   if ($222) { var $storemerge1_in_i = $storemerge1_i16;label = 31; break; } else { label = 34; break; }
  case 34: 
   var $224=HEAP32[(($149)>>2)];
   var $225=(($224+((($221)*(12))&-1)+4)|0);
   var $226=HEAP32[(($225)>>2)];
   HEAP32[(($167)>>2)]=$226;
   var $227=HEAP16[(($216)>>1)];
   var $228=(($227)&(65535));
   var $229=((($228)-(1))|0);
   var $230=$198 | $229;
   var $231=(($224+((($221)*(12))&-1))|0);
   HEAP32[(($231)>>2)]=$230;
   var $232=(($storemerge1_i16) & 255);
   var $233=(($224+((($221)*(12))&-1)+8)|0);
   HEAP8[($233)]=$232;
   var $234=(($224+((($221)*(12))&-1)+9)|0);
   HEAP8[($234)]=-1;
   var $235=(($224+((($221)*(12))&-1)+11)|0);
   HEAP8[($235)]=0;
   var $236=(($224+((($221)*(12))&-1)+10)|0);
   HEAP8[($236)]=0;
   var $237=HEAP32[(($206)>>2)];
   var $238=(($224+((($221)*(12))&-1)+4)|0);
   HEAP32[(($238)>>2)]=$237;
   HEAP32[(($206)>>2)]=$221;
   var $storemerge1_in_i = $storemerge1_i16;label = 31; break;
  case 35: 
   var $239=((($storemerge_i15)+(1))|0);
   var $_pre254=HEAP32[(($179)>>2)];
   var $storemerge_i15 = $239;var $200 = $_pre254;label = 28; break;
  case 36: 
   var $240=$ext_i;
   var $241=$nearestPt_i;
   var $242=(($this+68)|0);
   var $243=HEAP32[(($242)>>2)];
   var $244=$tile_0269;
   var $245=$243;
   var $246=((($244)-($245))|0);
   var $247=((((($246)|(0)))/(60))&-1);
   var $248=(($tile_0269)|0);
   var $249=HEAP32[(($248)>>2)];
   var $250=(($this+80)|0);
   var $251=HEAP32[(($250)>>2)];
   var $252=(($this+76)|0);
   var $253=HEAP32[(($252)>>2)];
   var $254=((($251)+($253))|0);
   var $255=$249 << $254;
   var $256=$247 << $251;
   var $257=$255 | $256;
   var $258=(($ext_i)|0);
   var $259=(($ext_i+4)|0);
   var $260=(($ext_i+8)|0);
   var $261=(($nearestPt_i)|0);
   var $262=(($nearestPt_i+8)|0);
   var $263=(($nearestPt_i+4)|0);
   var $264=(($nearestPt_i+8)|0);
   var $storemerge_i6 = 0;var $266 = $200;label = 37; break;
  case 37: 
   var $266;
   var $storemerge_i6;
   var $267=(($266+52)|0);
   var $268=HEAP32[(($267)>>2)];
   var $269=(($storemerge_i6)|(0)) < (($268)|(0));
   if ($269) { label = 38; break; } else { label = 44; break; }
  case 38: 
   var $271=HEAP32[(($163)>>2)];
   var $272=(($271+((($storemerge_i6)*(36))&-1)+28)|0);
   var $273=HEAP16[(($272)>>1)];
   var $274=(($273)&(65535));
   var $275=HEAP32[(($146)>>2)];
   var $276=(($271+((($storemerge_i6)*(36))&-1)+24)|0);
   var $277=HEAPF32[(($276)>>2)];
   HEAPF32[(($258)>>2)]=$277;
   var $278=(($266+68)|0);
   var $279=HEAPF32[(($278)>>2)];
   HEAPF32[(($259)>>2)]=$279;
   HEAPF32[(($260)>>2)]=$277;
   var $280=(($271+((($storemerge_i6)*(36))&-1))|0);
   var $281=__ZNK9dtNavMesh21findNearestPolyInTileEPK10dtMeshTilePKfS4_Pf($this, $tile_0269, $280, $258, $261);
   var $282=(($281)|(0))==0;
   if ($282) { label = 43; break; } else { label = 39; break; }
  case 39: 
   var $284=HEAPF32[(($261)>>2)];
   var $285=HEAPF32[(($280)>>2)];
   var $286=($284)-($285);
   var $287=($286)*($286);
   var $288=HEAPF32[(($262)>>2)];
   var $289=(($271+((($storemerge_i6)*(36))&-1)+8)|0);
   var $290=HEAPF32[(($289)>>2)];
   var $291=($288)-($290);
   var $292=($291)*($291);
   var $293=($287)+($292);
   var $294=HEAPF32[(($276)>>2)];
   var $295=($294)*($294);
   var $296=$293 > $295;
   if ($296) { label = 43; break; } else { label = 40; break; }
  case 40: 
   var $298=(($275+($274<<5)+4)|0);
   var $299=HEAP16[(($298)>>1)];
   var $300=(($299)&(65535));
   var $301=((($300)*(3))&-1);
   var $302=HEAP32[(($143)>>2)];
   var $303=(($302+($301<<2))|0);
   HEAPF32[(($303)>>2)]=$284;
   var $304=HEAPF32[(($263)>>2)];
   var $_sum264=((($301)+(1))|0);
   var $305=(($302+($_sum264<<2))|0);
   HEAPF32[(($305)>>2)]=$304;
   var $306=HEAPF32[(($264)>>2)];
   var $_sum265=((($301)+(2))|0);
   var $307=(($302+($_sum265<<2))|0);
   HEAPF32[(($307)>>2)]=$306;
   var $308=HEAP32[(($167)>>2)];
   var $309=(($308)|(0))==-1;
   if ($309) { label = 43; break; } else { label = 41; break; }
  case 41: 
   var $310=HEAP32[(($149)>>2)];
   var $311=(($310+((($308)*(12))&-1)+4)|0);
   var $312=HEAP32[(($311)>>2)];
   HEAP32[(($167)>>2)]=$312;
   var $313=(($310+((($308)*(12))&-1))|0);
   HEAP32[(($313)>>2)]=$281;
   var $314=(($310+((($308)*(12))&-1)+8)|0);
   HEAP8[($314)]=0;
   var $315=(($310+((($308)*(12))&-1)+9)|0);
   HEAP8[($315)]=-1;
   var $316=(($310+((($308)*(12))&-1)+11)|0);
   HEAP8[($316)]=0;
   var $317=(($310+((($308)*(12))&-1)+10)|0);
   HEAP8[($317)]=0;
   var $318=(($275+($274<<5))|0);
   var $319=HEAP32[(($318)>>2)];
   var $320=(($310+((($308)*(12))&-1)+4)|0);
   HEAP32[(($320)>>2)]=$319;
   HEAP32[(($318)>>2)]=$308;
   var $_pre253=HEAP32[(($167)>>2)];
   var $321=(($_pre253)|(0))==-1;
   if ($321) { label = 43; break; } else { label = 42; break; }
  case 42: 
   var $323=HEAP32[(($149)>>2)];
   var $324=(($323+((($_pre253)*(12))&-1)+4)|0);
   var $325=HEAP32[(($324)>>2)];
   HEAP32[(($167)>>2)]=$325;
   var $326=HEAP32[(($250)>>2)];
   var $327=1 << $326;
   var $328=((($327)+(65535))|0);
   var $329=$328 & $281;
   var $330=$329 & 65535;
   var $331=HEAP32[(($146)>>2)];
   var $332=(($271+((($storemerge_i6)*(36))&-1)+28)|0);
   var $333=HEAP16[(($332)>>1)];
   var $334=(($333)&(65535));
   var $335=$257 | $334;
   var $336=(($323+((($_pre253)*(12))&-1))|0);
   HEAP32[(($336)>>2)]=$335;
   var $337=(($323+((($_pre253)*(12))&-1)+8)|0);
   HEAP8[($337)]=-1;
   var $338=(($323+((($_pre253)*(12))&-1)+9)|0);
   HEAP8[($338)]=-1;
   var $339=(($323+((($_pre253)*(12))&-1)+11)|0);
   HEAP8[($339)]=0;
   var $340=(($323+((($_pre253)*(12))&-1)+10)|0);
   HEAP8[($340)]=0;
   var $341=(($331+($330<<5))|0);
   var $342=HEAP32[(($341)>>2)];
   var $343=(($323+((($_pre253)*(12))&-1)+4)|0);
   HEAP32[(($343)>>2)]=$342;
   HEAP32[(($341)>>2)]=$_pre253;
   label = 43; break;
  case 43: 
   var $344=((($storemerge_i6)+(1))|0);
   var $_pre=HEAP32[(($179)>>2)];
   var $storemerge_i6 = $344;var $266 = $_pre;label = 37; break;
  case 44: 
   var $345=HEAP32[(($12)>>2)];
   var $346=HEAP32[(($15)>>2)];
   var $347=(($neis)|0);
   var $this_idx_val=HEAP32[(($20)>>2)];
   var $this_idx18_val=HEAP32[(($26)>>2)];
   var $348=__ZNK9dtNavMesh10getTilesAtEiiPP10dtMeshTilei($this_idx_val, $this_idx18_val, $345, $346, $347, 32);
   var $storemerge1 = 0;label = 45; break;
  case 45: 
   var $storemerge1;
   var $350=(($storemerge1)|(0)) < (($348)|(0));
   if ($350) { label = 46; break; } else { var $storemerge2 = 0;label = 49; break; }
  case 46: 
   var $352=(($neis+($storemerge1<<2))|0);
   var $353=HEAP32[(($352)>>2)];
   var $354=(($353)|(0))==(($tile_0269)|(0));
   if ($354) { var $357 = $tile_0269;label = 48; break; } else { label = 47; break; }
  case 47: 
   __ZN9dtNavMesh15connectExtLinksEP10dtMeshTileS1_i($this, $tile_0269, $353, -1);
   __ZN9dtNavMesh15connectExtLinksEP10dtMeshTileS1_i($this, $353, $tile_0269, -1);
   var $357 = $353;label = 48; break;
  case 48: 
   var $357;
   __ZN9dtNavMesh22connectExtOffMeshLinksEP10dtMeshTileS1_i($this, $tile_0269, $357, -1);
   __ZN9dtNavMesh22connectExtOffMeshLinksEP10dtMeshTileS1_i($this, $357, $tile_0269, -1);
   var $358=((($storemerge1)+(1))|0);
   var $storemerge1 = $358;label = 45; break;
  case 49: 
   var $storemerge2;
   var $359=(($storemerge2)|(0)) < 8;
   if ($359) { label = 50; break; } else { var $_0 = 1073741824;label = 54; break; }
  case 50: 
   var $361=HEAP32[(($12)>>2)];
   var $362=HEAP32[(($15)>>2)];
   var $363=__ZNK9dtNavMesh19getNeighbourTilesAtEiiiPP10dtMeshTilei($this, $361, $362, $storemerge2, $347);
   var $364=((($storemerge2)+(4))|0);
   var $365=$364 & 7;
   var $storemerge3 = 0;label = 51; break;
  case 51: 
   var $storemerge3;
   var $367=(($storemerge3)|(0)) < (($363)|(0));
   if ($367) { label = 52; break; } else { label = 53; break; }
  case 52: 
   var $369=(($neis+($storemerge3<<2))|0);
   var $370=HEAP32[(($369)>>2)];
   __ZN9dtNavMesh15connectExtLinksEP10dtMeshTileS1_i($this, $tile_0269, $370, $storemerge2);
   __ZN9dtNavMesh15connectExtLinksEP10dtMeshTileS1_i($this, $370, $tile_0269, $365);
   __ZN9dtNavMesh22connectExtOffMeshLinksEP10dtMeshTileS1_i($this, $tile_0269, $370, $storemerge2);
   __ZN9dtNavMesh22connectExtOffMeshLinksEP10dtMeshTileS1_i($this, $370, $tile_0269, $365);
   var $371=((($storemerge3)+(1))|0);
   var $storemerge3 = $371;label = 51; break;
  case 53: 
   var $373=((($storemerge2)+(1))|0);
   var $storemerge2 = $373;label = 49; break;
  case 54: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL17calcSlabEndPointsPKfS0_PfS1_i($va, $vb, $bmin, $bmax, $side) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   if ((($side)|(0))==0 | (($side)|(0))==4) {
    label = 2; break;
   }
   else if ((($side)|(0))==2 | (($side)|(0))==6) {
    label = 5; break;
   }
   else {
   label = 8; break;
   }
  case 2: 
   var $2=(($va+8)|0);
   var $3=HEAPF32[(($2)>>2)];
   var $4=(($vb+8)|0);
   var $5=HEAPF32[(($4)>>2)];
   var $6=$3 < $5;
   if ($6) { label = 3; break; } else { label = 4; break; }
  case 3: 
   HEAPF32[(($bmin)>>2)]=$3;
   var $8=(($va+4)|0);
   var $9=HEAPF32[(($8)>>2)];
   var $10=(($bmin+4)|0);
   HEAPF32[(($10)>>2)]=$9;
   var $11=HEAPF32[(($4)>>2)];
   HEAPF32[(($bmax)>>2)]=$11;
   var $12=(($vb+4)|0);
   var $13=HEAPF32[(($12)>>2)];
   var $14=(($bmax+4)|0);
   HEAPF32[(($14)>>2)]=$13;
   label = 8; break;
  case 4: 
   HEAPF32[(($bmin)>>2)]=$5;
   var $16=(($vb+4)|0);
   var $17=HEAPF32[(($16)>>2)];
   var $18=(($bmin+4)|0);
   HEAPF32[(($18)>>2)]=$17;
   var $19=HEAPF32[(($2)>>2)];
   HEAPF32[(($bmax)>>2)]=$19;
   var $20=(($va+4)|0);
   var $21=HEAPF32[(($20)>>2)];
   var $22=(($bmax+4)|0);
   HEAPF32[(($22)>>2)]=$21;
   label = 8; break;
  case 5: 
   var $24=HEAPF32[(($va)>>2)];
   var $25=HEAPF32[(($vb)>>2)];
   var $26=$24 < $25;
   if ($26) { label = 6; break; } else { label = 7; break; }
  case 6: 
   HEAPF32[(($bmin)>>2)]=$24;
   var $28=(($va+4)|0);
   var $29=HEAPF32[(($28)>>2)];
   var $30=(($bmin+4)|0);
   HEAPF32[(($30)>>2)]=$29;
   var $31=HEAPF32[(($vb)>>2)];
   HEAPF32[(($bmax)>>2)]=$31;
   var $32=(($vb+4)|0);
   var $33=HEAPF32[(($32)>>2)];
   var $34=(($bmax+4)|0);
   HEAPF32[(($34)>>2)]=$33;
   label = 8; break;
  case 7: 
   HEAPF32[(($bmin)>>2)]=$25;
   var $36=(($vb+4)|0);
   var $37=HEAPF32[(($36)>>2)];
   var $38=(($bmin+4)|0);
   HEAPF32[(($38)>>2)]=$37;
   var $39=HEAPF32[(($va)>>2)];
   HEAPF32[(($bmax)>>2)]=$39;
   var $40=(($va+4)|0);
   var $41=HEAPF32[(($40)>>2)];
   var $42=(($bmax+4)|0);
   HEAPF32[(($42)>>2)]=$41;
   label = 8; break;
  case 8: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9dtNavMesh15connectExtLinksEP10dtMeshTileS1_i($this, $tile, $target, $side) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 80)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $amin_i=sp;
   var $amax_i=(sp)+(8);
   var $bmin_i=(sp)+(16);
   var $bmax_i=(sp)+(24);
   var $nei=(sp)+(32);
   var $neia=(sp)+(48);
   var $1=(($tile)|(0))==0;
   if ($1) { label = 48; break; } else { label = 2; break; }
  case 2: 
   var $2=(($tile+8)|0);
   var $3=(($tile+12)|0);
   var $4=(($side)|(0))==-1;
   var $5=(($tile+16)|0);
   var $6=$amin_i;
   var $7=$amax_i;
   var $8=$bmin_i;
   var $9=$bmax_i;
   var $10=(($target)|(0))==0;
   var $11=(($tile+4)|0);
   var $12=(($tile+20)|0);
   var $13=(($amin_i)|0);
   var $14=(($amax_i)|0);
   var $15=(($target+8)|0);
   var $16=(($target+12)|0);
   var $17=(($target+16)|0);
   var $18=(($bmin_i)|0);
   var $19=(($bmax_i)|0);
   var $20=(($amax_i+4)|0);
   var $21=(($amin_i+4)|0);
   var $22=(($bmax_i+4)|0);
   var $23=(($bmin_i+4)|0);
   var $24=(($this+68)|0);
   var $25=$target;
   var $26=(($target)|0);
   var $27=(($this+80)|0);
   var $28=(($this+76)|0);
   var $storemerge = 0;label = 3; break;
  case 3: 
   var $storemerge;
   var $30=HEAP32[(($2)>>2)];
   var $31=(($30+24)|0);
   var $32=HEAP32[(($31)>>2)];
   var $33=(($storemerge)|(0)) < (($32)|(0));
   if ($33) { label = 4; break; } else { label = 48; break; }
  case 4: 
   var $35=HEAP32[(($3)>>2)];
   var $36=(($35+($storemerge<<5)+30)|0);
   var $37=HEAP8[($36)];
   var $38=(($37)&(255));
   var $39=(($35+($storemerge<<5))|0);
   var $storemerge1 = 0;label = 5; break;
  case 5: 
   var $storemerge1;
   var $41=(($storemerge1)|(0)) < (($38)|(0));
   if ($41) { label = 6; break; } else { label = 47; break; }
  case 6: 
   var $43=(($35+($storemerge<<5)+16+($storemerge1<<1))|0);
   var $44=HEAP16[(($43)>>1)];
   var $45=(($44 << 16) >> 16) > -1;
   if ($45) { label = 46; break; } else { label = 7; break; }
  case 7: 
   var $47=(($44)&(65535));
   var $48=$47 & 255;
   var $49=(($48)|(0))==(($side)|(0));
   var $or_cond=$4 | $49;
   if ($or_cond) { label = 8; break; } else { label = 46; break; }
  case 8: 
   var $50=(($35+($storemerge<<5)+4+($storemerge1<<1))|0);
   var $51=HEAP16[(($50)>>1)];
   var $52=(($51)&(65535));
   var $53=((($52)*(3))&-1);
   var $54=HEAP32[(($5)>>2)];
   var $55=(($54+($53<<2))|0);
   var $56=((($storemerge1)+(1))|0);
   var $57=((((($56)|(0)))%((($38)|(0))))&-1);
   var $58=(($35+($storemerge<<5)+4+($57<<1))|0);
   var $59=HEAP16[(($58)>>1)];
   var $60=(($59)&(65535));
   var $61=((($60)*(3))&-1);
   var $62=(($54+($61<<2))|0);
   var $63=((($47)+(4))|0);
   var $64=$63 & 7;
   if ($10) { var $storemerge1_i = 0;label = 31; break; } else { label = 9; break; }
  case 9: 
   __ZL17calcSlabEndPointsPKfS0_PfS1_i($55, $62, $13, $14, $64);
   if ((($64)|(0))==4 | (($64)|(0))==0) {
    label = 10; break;
   }
   else if ((($64)|(0))==2 | (($64)|(0))==6) {
    label = 11; break;
   }
   else {
   var $_0238 = 0;label = 12; break;
   }
  case 10: 
   var $67=HEAPF32[(($55)>>2)];
   var $_0238 = $67;label = 12; break;
  case 11: 
   var $_sum251=((($53)+(2))|0);
   var $69=(($54+($_sum251<<2))|0);
   var $70=HEAPF32[(($69)>>2)];
   var $_0238 = $70;label = 12; break;
  case 12: 
   var $_0238;
   var $71=$64 | 32768;
   var $72=(($71) & 65535);
   var $73=HEAP32[(($24)>>2)];
   var $74=$73;
   var $75=((($25)-($74))|0);
   var $76=((((($75)|(0)))/(60))&-1);
   var $77=HEAP32[(($26)>>2)];
   var $78=HEAP32[(($27)>>2)];
   var $79=HEAP32[(($28)>>2)];
   var $80=((($78)+($79))|0);
   var $81=$77 << $80;
   var $82=$76 << $78;
   var $83=$81 | $82;
   var $84=HEAPF32[(($13)>>2)];
   var $85=($84)+(0.009999999776482582);
   var $86=HEAPF32[(($14)>>2)];
   var $87=($86)-(0.009999999776482582);
   var $88=($86)-($84);
   var $89=(($64)|(0))==6;
   var $_pre=HEAP32[(($15)>>2)];
   var $storemerge_i7 = 0;var $n_i_0 = 0;var $91 = $_pre;label = 13; break;
  case 13: 
   var $91;
   var $n_i_0;
   var $storemerge_i7;
   var $92=(($91+24)|0);
   var $93=HEAP32[(($92)>>2)];
   var $94=(($storemerge_i7)|(0)) < (($93)|(0));
   if ($94) { label = 14; break; } else { var $storemerge1_i = $n_i_0;label = 31; break; }
  case 14: 
   var $96=HEAP32[(($16)>>2)];
   var $97=(($96+($storemerge_i7<<5)+30)|0);
   var $98=HEAP8[($97)];
   var $99=(($98)&(255));
   var $storemerge2_i = 0;var $100 = $91;label = 15; break;
  case 15: 
   var $100;
   var $storemerge2_i;
   var $101=(($storemerge2_i)|(0)) < (($99)|(0));
   if ($101) { label = 16; break; } else { var $n_i_1 = $n_i_0;var $192 = $100;label = 30; break; }
  case 16: 
   var $103=(($96+($storemerge_i7<<5)+16+($storemerge2_i<<1))|0);
   var $104=HEAP16[(($103)>>1)];
   var $105=(($104 << 16) >> 16)==(($72 << 16) >> 16);
   if ($105) { label = 18; break; } else { label = 17; break; }
  case 17: 
   var $_pre243=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $_pre243;var $100 = $100;label = 15; break;
  case 18: 
   var $107=(($96+($storemerge_i7<<5)+4+($storemerge2_i<<1))|0);
   var $108=HEAP16[(($107)>>1)];
   var $109=(($108)&(65535));
   var $110=((($109)*(3))&-1);
   var $111=HEAP32[(($17)>>2)];
   var $112=(($111+($110<<2))|0);
   var $113=((($storemerge2_i)+(1))|0);
   var $114=((((($113)|(0)))%((($99)|(0))))&-1);
   var $115=(($96+($storemerge_i7<<5)+4+($114<<1))|0);
   var $116=HEAP16[(($115)>>1)];
   var $117=(($116)&(65535));
   var $118=((($117)*(3))&-1);
   var $119=(($111+($118<<2))|0);
   if ((($64)|(0))==4 | (($64)|(0))==0) {
    label = 19; break;
   }
   else if ((($64)|(0))==2 | (($64)|(0))==6) {
    label = 20; break;
   }
   else {
   var $_0 = 0;label = 21; break;
   }
  case 19: 
   var $121=HEAPF32[(($112)>>2)];
   var $_0 = $121;label = 21; break;
  case 20: 
   var $_sum250=((($110)+(2))|0);
   var $123=(($111+($_sum250<<2))|0);
   var $124=HEAPF32[(($123)>>2)];
   var $_0 = $124;label = 21; break;
  case 21: 
   var $_0;
   var $125=($_0238)-($_0);
   var $126=$125 < 0;
   if ($126) { label = 22; break; } else { var $129 = $125;label = 23; break; }
  case 22: 
   var $128=(-$125);
   var $129 = $128;label = 23; break;
  case 23: 
   var $129;
   var $130=$129 > 0.009999999776482582;
   if ($130) { var $storemerge2_i = $113;var $100 = $100;label = 15; break; } else { label = 24; break; }
  case 24: 
   __ZL17calcSlabEndPointsPKfS0_PfS1_i($112, $119, $18, $19, $64);
   var $132=HEAP32[(($15)>>2)];
   var $133=(($132+68)|0);
   var $134=HEAPF32[(($133)>>2)];
   var $135=HEAPF32[(($18)>>2)];
   var $136=($135)+(0.009999999776482582);
   var $137=$85 > $136;
   var $138=$137 ? $85 : $136;
   var $139=HEAPF32[(($19)>>2)];
   var $140=($139)-(0.009999999776482582);
   var $141=$87 < $140;
   var $142=$141 ? $87 : $140;
   var $143=$138 > $142;
   if ($143) { var $storemerge2_i = $113;var $100 = $132;label = 15; break; } else { label = 25; break; }
  case 25: 
   var $145=HEAPF32[(($20)>>2)];
   var $146=HEAPF32[(($21)>>2)];
   var $147=($145)-($146);
   var $148=($147)/($88);
   var $149=($148)*($84);
   var $150=($146)-($149);
   var $151=HEAPF32[(($22)>>2)];
   var $152=HEAPF32[(($23)>>2)];
   var $153=($151)-($152);
   var $154=($139)-($135);
   var $155=($153)/($154);
   var $156=($155)*($135);
   var $157=($152)-($156);
   var $158=($148)*($138);
   var $159=($158)+($150);
   var $160=($148)*($142);
   var $161=($160)+($150);
   var $162=($155)*($138);
   var $163=($162)+($157);
   var $164=($155)*($142);
   var $165=($164)+($157);
   var $166=($163)-($159);
   var $167=($165)-($161);
   var $168=($166)*($167);
   var $169=$168 < 0;
   if ($169) { label = 28; break; } else { label = 26; break; }
  case 26: 
   var $171=($134)*(2);
   var $172=($171)*($171);
   var $173=($166)*($166);
   var $174=$173 > $172;
   if ($174) { label = 27; break; } else { label = 28; break; }
  case 27: 
   var $176=($167)*($167);
   var $177=$176 > $172;
   if ($177) { var $storemerge2_i = $113;var $100 = $132;label = 15; break; } else { label = 28; break; }
  case 28: 
   var $179=(($n_i_0)|(0)) < 4;
   if ($179) { label = 29; break; } else { var $n_i_1 = $n_i_0;var $192 = $132;label = 30; break; }
  case 29: 
   var $181=$84 > $135;
   var $182=$181 ? $84 : $135;
   var $183=$n_i_0 << 1;
   var $184=(($neia+($183<<2))|0);
   HEAPF32[(($184)>>2)]=$182;
   var $185=$86 < $139;
   var $186=$185 ? $86 : $139;
   var $187=$183 | 1;
   var $188=(($neia+($187<<2))|0);
   HEAPF32[(($188)>>2)]=$186;
   var $189=$83 | $storemerge_i7;
   var $190=(($nei+($n_i_0<<2))|0);
   HEAP32[(($190)>>2)]=$189;
   var $191=((($n_i_0)+(1))|0);
   var $n_i_1 = $191;var $192 = $132;label = 30; break;
  case 30: 
   var $192;
   var $n_i_1;
   var $193=((($storemerge_i7)+(1))|0);
   var $storemerge_i7 = $193;var $n_i_0 = $n_i_1;var $91 = $192;label = 13; break;
  case 31: 
   var $storemerge1_i;
   var $194=(($storemerge1) & 255);
   var $195=(($44) & 255);
   var $_sum=((($53)+(2))|0);
   var $196=(($54+($_sum<<2))|0);
   var $_sum244=((($61)+(2))|0);
   var $197=(($54+($_sum244<<2))|0);
   var $198=(($48)|(0))==4;
   var $199=(($48)|(0))==2;
   var $200=(($48)|(0))==6;
   var $storemerge2 = 0;label = 32; break;
  case 32: 
   var $storemerge2;
   var $202=(($storemerge2)|(0)) < (($storemerge1_i)|(0));
   if ($202) { label = 33; break; } else { label = 46; break; }
  case 33: 
   var $204=HEAP32[(($11)>>2)];
   var $205=(($204)|(0))==-1;
   if ($205) { label = 45; break; } else { label = 34; break; }
  case 34: 
   var $207=HEAP32[(($12)>>2)];
   var $208=(($207+((($204)*(12))&-1)+4)|0);
   var $209=HEAP32[(($208)>>2)];
   HEAP32[(($11)>>2)]=$209;
   var $210=(($nei+($storemerge2<<2))|0);
   var $211=HEAP32[(($210)>>2)];
   var $212=(($207+((($204)*(12))&-1))|0);
   HEAP32[(($212)>>2)]=$211;
   var $213=(($207+((($204)*(12))&-1)+8)|0);
   HEAP8[($213)]=$194;
   var $214=(($207+((($204)*(12))&-1)+9)|0);
   HEAP8[($214)]=$195;
   var $215=HEAP32[(($39)>>2)];
   var $216=(($207+((($204)*(12))&-1)+4)|0);
   HEAP32[(($216)>>2)]=$215;
   HEAP32[(($39)>>2)]=$204;
   if ((($48)|(0))==0 | (($48)|(0))==4) {
    label = 35; break;
   }
   else if ((($48)|(0))==2 | (($48)|(0))==6) {
    label = 40; break;
   }
   else {
   label = 45; break;
   }
  case 35: 
   var $218=$storemerge2 << 1;
   var $219=(($neia+($218<<2))|0);
   var $220=HEAPF32[(($219)>>2)];
   var $221=HEAPF32[(($196)>>2)];
   var $222=($220)-($221);
   var $223=HEAPF32[(($197)>>2)];
   var $224=($223)-($221);
   var $225=($222)/($224);
   var $226=$218 | 1;
   var $227=(($neia+($226<<2))|0);
   var $228=HEAPF32[(($227)>>2)];
   var $229=($228)-($221);
   var $230=($229)/($224);
   var $231=$225 > $230;
   var $tmax_0=$231 ? $225 : $230;
   var $232=$231 ? $230 : $225;
   var $233=$232 < 0;
   if ($233) { var $237 = 0;label = 37; break; } else { label = 36; break; }
  case 36: 
   var $235=$232 > 1;
   var $_op247=($232)*(255);
   var $236=($_op247>=0 ? Math.floor($_op247) : Math.ceil($_op247));
   var $phitmp248=$235 ? -1 : $236;
   var $237 = $phitmp248;label = 37; break;
  case 37: 
   var $237;
   var $238=(($207+((($204)*(12))&-1)+10)|0);
   HEAP8[($238)]=$237;
   var $239=$tmax_0 < 0;
   if ($239) { var $243 = 0;label = 39; break; } else { label = 38; break; }
  case 38: 
   var $241=$tmax_0 > 1;
   var $tmax_0_op=($tmax_0)*(255);
   var $242=($tmax_0_op>=0 ? Math.floor($tmax_0_op) : Math.ceil($tmax_0_op));
   var $phitmp249=$241 ? -1 : $242;
   var $243 = $phitmp249;label = 39; break;
  case 39: 
   var $243;
   var $244=(($207+((($204)*(12))&-1)+11)|0);
   HEAP8[($244)]=$243;
   label = 45; break;
  case 40: 
   var $246=$storemerge2 << 1;
   var $247=(($neia+($246<<2))|0);
   var $248=HEAPF32[(($247)>>2)];
   var $249=HEAPF32[(($55)>>2)];
   var $250=($248)-($249);
   var $251=HEAPF32[(($62)>>2)];
   var $252=($251)-($249);
   var $253=($250)/($252);
   var $254=$246 | 1;
   var $255=(($neia+($254<<2))|0);
   var $256=HEAPF32[(($255)>>2)];
   var $257=($256)-($249);
   var $258=($257)/($252);
   var $259=$253 > $258;
   var $tmax2_0=$259 ? $253 : $258;
   var $260=$259 ? $258 : $253;
   var $261=$260 < 0;
   if ($261) { var $265 = 0;label = 42; break; } else { label = 41; break; }
  case 41: 
   var $263=$260 > 1;
   var $_op=($260)*(255);
   var $264=($_op>=0 ? Math.floor($_op) : Math.ceil($_op));
   var $phitmp245=$263 ? -1 : $264;
   var $265 = $phitmp245;label = 42; break;
  case 42: 
   var $265;
   var $266=(($207+((($204)*(12))&-1)+10)|0);
   HEAP8[($266)]=$265;
   var $267=$tmax2_0 < 0;
   if ($267) { var $271 = 0;label = 44; break; } else { label = 43; break; }
  case 43: 
   var $269=$tmax2_0 > 1;
   var $tmax2_0_op=($tmax2_0)*(255);
   var $270=($tmax2_0_op>=0 ? Math.floor($tmax2_0_op) : Math.ceil($tmax2_0_op));
   var $phitmp246=$269 ? -1 : $270;
   var $271 = $phitmp246;label = 44; break;
  case 44: 
   var $271;
   var $272=(($207+((($204)*(12))&-1)+11)|0);
   HEAP8[($272)]=$271;
   label = 45; break;
  case 45: 
   var $273=((($storemerge2)+(1))|0);
   var $storemerge2 = $273;label = 32; break;
  case 46: 
   var $274=((($storemerge1)+(1))|0);
   var $storemerge1 = $274;label = 5; break;
  case 47: 
   var $276=((($storemerge)+(1))|0);
   var $storemerge = $276;label = 3; break;
  case 48: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9dtNavMesh22connectExtOffMeshLinksEP10dtMeshTileS1_i($this, $tile, $target, $side) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $ext=sp;
   var $nearestPt=(sp)+(16);
   var $1=(($tile)|(0))==0;
   if ($1) { label = 18; break; } else { label = 2; break; }
  case 2: 
   var $3=(($side)|(0))==-1;
   if ($3) { var $_off0 = -1;label = 4; break; } else { label = 3; break; }
  case 3: 
   var $5=((($side)+(4))|0);
   var $_tr=(($5) & 255);
   var $extract_t=$_tr & 7;
   var $_off0 = $extract_t;label = 4; break;
  case 4: 
   var $_off0;
   var $7=(($target+8)|0);
   var $8=(($target+40)|0);
   var $9=(($target+12)|0);
   var $10=(($ext)|0);
   var $11=(($ext+4)|0);
   var $12=(($ext+8)|0);
   var $13=(($nearestPt)|0);
   var $14=(($nearestPt+8)|0);
   var $15=(($target+16)|0);
   var $16=(($nearestPt+4)|0);
   var $17=(($nearestPt+8)|0);
   var $18=(($target+4)|0);
   var $19=(($tile+4)|0);
   var $20=(($tile+20)|0);
   var $21=(($this+80)|0);
   var $22=(($tile+12)|0);
   var $23=(($target)|(0))==0;
   var $extract_t2=(($side) & 255);
   var $24=(($this+68)|0);
   var $25=$target;
   var $26=(($target)|0);
   var $27=(($this+76)|0);
   var $28=(($target+20)|0);
   var $storemerge = 0;label = 5; break;
  case 5: 
   var $storemerge;
   var $30=HEAP32[(($7)>>2)];
   var $31=(($30+52)|0);
   var $32=HEAP32[(($31)>>2)];
   var $33=(($storemerge)|(0)) < (($32)|(0));
   if ($33) { label = 6; break; } else { label = 18; break; }
  case 6: 
   var $35=HEAP32[(($8)>>2)];
   var $36=(($35+((($storemerge)*(36))&-1)+31)|0);
   var $37=HEAP8[($36)];
   var $38=(($37 << 24) >> 24)==(($_off0 << 24) >> 24);
   if ($38) { label = 7; break; } else { label = 17; break; }
  case 7: 
   var $40=(($35+((($storemerge)*(36))&-1)+28)|0);
   var $41=HEAP16[(($40)>>1)];
   var $42=(($41)&(65535));
   var $43=HEAP32[(($9)>>2)];
   var $44=(($43+($42<<5))|0);
   var $45=HEAP32[(($44)>>2)];
   var $46=(($45)|(0))==-1;
   if ($46) { label = 17; break; } else { label = 8; break; }
  case 8: 
   var $48=(($35+((($storemerge)*(36))&-1)+24)|0);
   var $49=HEAPF32[(($48)>>2)];
   HEAPF32[(($10)>>2)]=$49;
   var $50=(($30+68)|0);
   var $51=HEAPF32[(($50)>>2)];
   HEAPF32[(($11)>>2)]=$51;
   HEAPF32[(($12)>>2)]=$49;
   var $52=(($35+((($storemerge)*(36))&-1)+12)|0);
   var $53=__ZNK9dtNavMesh21findNearestPolyInTileEPK10dtMeshTilePKfS4_Pf($this, $tile, $52, $10, $13);
   var $54=(($53)|(0))==0;
   if ($54) { label = 17; break; } else { label = 9; break; }
  case 9: 
   var $56=HEAPF32[(($13)>>2)];
   var $57=HEAPF32[(($52)>>2)];
   var $58=($56)-($57);
   var $59=($58)*($58);
   var $60=HEAPF32[(($14)>>2)];
   var $61=(($35+((($storemerge)*(36))&-1)+20)|0);
   var $62=HEAPF32[(($61)>>2)];
   var $63=($60)-($62);
   var $64=($63)*($63);
   var $65=($59)+($64);
   var $66=HEAPF32[(($48)>>2)];
   var $67=($66)*($66);
   var $68=$65 > $67;
   if ($68) { label = 17; break; } else { label = 10; break; }
  case 10: 
   var $70=(($43+($42<<5)+6)|0);
   var $71=HEAP16[(($70)>>1)];
   var $72=(($71)&(65535));
   var $73=((($72)*(3))&-1);
   var $74=HEAP32[(($15)>>2)];
   var $75=(($74+($73<<2))|0);
   HEAPF32[(($75)>>2)]=$56;
   var $76=HEAPF32[(($16)>>2)];
   var $_sum=((($73)+(1))|0);
   var $77=(($74+($_sum<<2))|0);
   HEAPF32[(($77)>>2)]=$76;
   var $78=HEAPF32[(($17)>>2)];
   var $_sum75=((($73)+(2))|0);
   var $79=(($74+($_sum75<<2))|0);
   HEAPF32[(($79)>>2)]=$78;
   var $80=HEAP32[(($18)>>2)];
   var $81=(($80)|(0))==-1;
   if ($81) { label = 12; break; } else { label = 11; break; }
  case 11: 
   var $83=HEAP32[(($28)>>2)];
   var $84=(($83+((($80)*(12))&-1)+4)|0);
   var $85=HEAP32[(($84)>>2)];
   HEAP32[(($18)>>2)]=$85;
   var $86=(($83+((($80)*(12))&-1))|0);
   HEAP32[(($86)>>2)]=$53;
   var $87=(($83+((($80)*(12))&-1)+8)|0);
   HEAP8[($87)]=1;
   var $88=(($83+((($80)*(12))&-1)+9)|0);
   HEAP8[($88)]=$_off0;
   var $89=(($83+((($80)*(12))&-1)+11)|0);
   HEAP8[($89)]=0;
   var $90=(($83+((($80)*(12))&-1)+10)|0);
   HEAP8[($90)]=0;
   var $91=HEAP32[(($44)>>2)];
   var $92=(($83+((($80)*(12))&-1)+4)|0);
   HEAP32[(($92)>>2)]=$91;
   HEAP32[(($44)>>2)]=$80;
   label = 12; break;
  case 12: 
   var $93=(($35+((($storemerge)*(36))&-1)+30)|0);
   var $94=HEAP8[($93)];
   var $95=$94 & 1;
   var $96=(($95 << 24) >> 24)==0;
   if ($96) { label = 17; break; } else { label = 13; break; }
  case 13: 
   var $98=HEAP32[(($19)>>2)];
   var $99=(($98)|(0))==-1;
   if ($99) { label = 17; break; } else { label = 14; break; }
  case 14: 
   var $101=HEAP32[(($20)>>2)];
   var $102=(($101+((($98)*(12))&-1)+4)|0);
   var $103=HEAP32[(($102)>>2)];
   HEAP32[(($19)>>2)]=$103;
   var $104=HEAP32[(($21)>>2)];
   var $105=1 << $104;
   var $106=((($105)+(65535))|0);
   var $107=$106 & $53;
   var $108=$107 & 65535;
   var $109=HEAP32[(($22)>>2)];
   if ($23) { var $storemerge_i = 0;label = 16; break; } else { label = 15; break; }
  case 15: 
   var $111=HEAP32[(($24)>>2)];
   var $112=$111;
   var $113=((($25)-($112))|0);
   var $114=((((($113)|(0)))/(60))&-1);
   var $115=HEAP32[(($26)>>2)];
   var $116=HEAP32[(($27)>>2)];
   var $117=((($104)+($116))|0);
   var $118=$115 << $117;
   var $119=$114 << $104;
   var $120=$118 | $119;
   var $storemerge_i = $120;label = 16; break;
  case 16: 
   var $storemerge_i;
   var $121=HEAP16[(($40)>>1)];
   var $122=(($121)&(65535));
   var $123=$storemerge_i | $122;
   var $124=(($101+((($98)*(12))&-1))|0);
   HEAP32[(($124)>>2)]=$123;
   var $125=(($101+((($98)*(12))&-1)+8)|0);
   HEAP8[($125)]=-1;
   var $_extract_t2=$3 ? -1 : $extract_t2;
   var $126=(($101+((($98)*(12))&-1)+9)|0);
   HEAP8[($126)]=$_extract_t2;
   var $127=(($101+((($98)*(12))&-1)+11)|0);
   HEAP8[($127)]=0;
   var $128=(($101+((($98)*(12))&-1)+10)|0);
   HEAP8[($128)]=0;
   var $129=(($109+($108<<5))|0);
   var $130=HEAP32[(($129)>>2)];
   var $131=(($101+((($98)*(12))&-1)+4)|0);
   HEAP32[(($131)>>2)]=$130;
   HEAP32[(($129)>>2)]=$98;
   label = 17; break;
  case 17: 
   var $132=((($storemerge)+(1))|0);
   var $storemerge = $132;label = 5; break;
  case 18: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK9dtNavMesh10getTilesAtEiiPP10dtMeshTilei($this_0_6_val, $this_0_7_val, $x, $y, $tiles, $maxTiles) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(Math.imul($x,-1918454973)|0);
   var $2=(Math.imul($y,-669632447)|0);
   var $3=((($1)+($2))|0);
   var $4=$3 & $this_0_6_val;
   var $5=(($this_0_7_val+($4<<2))|0);
   var $storemerge_in = $5;var $n_0 = 0;label = 2; break;
  case 2: 
   var $n_0;
   var $storemerge_in;
   var $storemerge=HEAP32[(($storemerge_in)>>2)];
   var $7=(($storemerge)|(0))==0;
   if ($7) { label = 8; break; } else { label = 3; break; }
  case 3: 
   var $9=(($storemerge+8)|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=(($10)|(0))==0;
   if ($11) { var $n_1 = $n_0;label = 7; break; } else { label = 4; break; }
  case 4: 
   var $13=(($10+8)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($14)|(0))==(($x)|(0));
   if ($15) { label = 5; break; } else { var $n_1 = $n_0;label = 7; break; }
  case 5: 
   var $17=(($10+12)|0);
   var $18=HEAP32[(($17)>>2)];
   var $19=(($18)|(0))==(($y)|(0));
   var $20=(($n_0)|(0)) < (($maxTiles)|(0));
   var $or_cond=$19 & $20;
   if ($or_cond) { label = 6; break; } else { var $n_1 = $n_0;label = 7; break; }
  case 6: 
   var $22=((($n_0)+(1))|0);
   var $23=(($tiles+($n_0<<2))|0);
   HEAP32[(($23)>>2)]=$storemerge;
   var $n_1 = $22;label = 7; break;
  case 7: 
   var $n_1;
   var $25=(($storemerge+56)|0);
   var $storemerge_in = $25;var $n_0 = $n_1;label = 2; break;
  case 8: 
   return $n_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK9dtNavMesh21findNearestPolyInTileEPK10dtMeshTilePKfS4_Pf($this, $tile, $center, $extents, $nearestPt) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 648)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $verts_i=sp;
   var $edged_i=(sp)+(72);
   var $edget_i=(sp)+(96);
   var $v_i=(sp)+(120);
   var $polys=(sp)+(136);
   var $1=HEAPF32[(($center)>>2)];
   var $2=HEAPF32[(($extents)>>2)];
   var $3=($1)-($2);
   var $4=(($center+4)|0);
   var $5=HEAPF32[(($4)>>2)];
   var $6=(($extents+4)|0);
   var $7=HEAPF32[(($6)>>2)];
   var $8=($5)-($7);
   var $9=(($center+8)|0);
   var $10=HEAPF32[(($9)>>2)];
   var $11=(($extents+8)|0);
   var $12=HEAPF32[(($11)>>2)];
   var $13=($10)-($12);
   var $14=($1)+($2);
   var $15=($5)+($7);
   var $16=($10)+($12);
   var $17=(($tile+36)|0);
   var $18=HEAP32[(($17)>>2)];
   var $19=(($18)|(0))==0;
   if ($19) { label = 32; break; } else { label = 2; break; }
  case 2: 
   var $21=(($tile+8)|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=(($22+48)|0);
   var $24=HEAP32[(($23)>>2)];
   var $25=(($18+($24<<4))|0);
   var $26=(($22+72)|0);
   var $27=(($22+84)|0);
   var $28=(($22+96)|0);
   var $29=HEAPF32[(($28)>>2)];
   var $30=HEAPF32[(($26)>>2)];
   var $31=HEAPF32[(($27)>>2)];
   var $32=$3 < $30;
   if ($32) { var $36 = $30;label = 4; break; } else { label = 3; break; }
  case 3: 
   var $34=$3 > $31;
   var $35=$34 ? $31 : $3;
   var $36 = $35;label = 4; break;
  case 4: 
   var $36;
   var $37=($36)-($30);
   var $38=(($22+76)|0);
   var $39=HEAPF32[(($38)>>2)];
   var $40=(($22+88)|0);
   var $41=HEAPF32[(($40)>>2)];
   var $42=$8 < $39;
   if ($42) { var $46 = $39;label = 6; break; } else { label = 5; break; }
  case 5: 
   var $44=$8 > $41;
   var $45=$44 ? $41 : $8;
   var $46 = $45;label = 6; break;
  case 6: 
   var $46;
   var $47=($46)-($39);
   var $48=(($22+80)|0);
   var $49=HEAPF32[(($48)>>2)];
   var $50=(($22+92)|0);
   var $51=HEAPF32[(($50)>>2)];
   var $52=$13 < $49;
   if ($52) { var $56 = $49;label = 8; break; } else { label = 7; break; }
  case 7: 
   var $54=$13 > $51;
   var $55=$54 ? $51 : $13;
   var $56 = $55;label = 8; break;
  case 8: 
   var $56;
   var $57=($56)-($49);
   var $58=$14 < $30;
   if ($58) { var $62 = $30;label = 10; break; } else { label = 9; break; }
  case 9: 
   var $60=$14 > $31;
   var $61=$60 ? $31 : $14;
   var $62 = $61;label = 10; break;
  case 10: 
   var $62;
   var $63=($62)-($30);
   var $64=$15 < $39;
   if ($64) { var $68 = $39;label = 12; break; } else { label = 11; break; }
  case 11: 
   var $66=$15 > $41;
   var $67=$66 ? $41 : $15;
   var $68 = $67;label = 12; break;
  case 12: 
   var $68;
   var $69=($68)-($39);
   var $70=$16 < $49;
   if ($70) { var $74 = $49;label = 14; break; } else { label = 13; break; }
  case 13: 
   var $72=$16 > $51;
   var $73=$72 ? $51 : $16;
   var $74 = $73;label = 14; break;
  case 14: 
   var $74;
   var $75=($74)-($49);
   var $76=($29)*($37);
   var $77=($76>=0 ? Math.floor($76) : Math.ceil($76));
   var $78=$77 & -2;
   var $79=($29)*($47);
   var $80=($79>=0 ? Math.floor($79) : Math.ceil($79));
   var $81=$80 & -2;
   var $82=($29)*($57);
   var $83=($82>=0 ? Math.floor($82) : Math.ceil($82));
   var $84=$83 & -2;
   var $85=($29)*($63);
   var $86=($85)+(1);
   var $87=($86>=0 ? Math.floor($86) : Math.ceil($86));
   var $88=$87 | 1;
   var $89=($29)*($69);
   var $90=($89)+(1);
   var $91=($90>=0 ? Math.floor($90) : Math.ceil($90));
   var $92=$91 | 1;
   var $93=($29)*($75);
   var $94=($93)+(1);
   var $95=($94>=0 ? Math.floor($94) : Math.ceil($94));
   var $96=$95 | 1;
   var $97=(($tile)|(0))==0;
   if ($97) { var $storemerge_i5_i = 0;label = 16; break; } else { label = 15; break; }
  case 15: 
   var $99=(($this+68)|0);
   var $100=HEAP32[(($99)>>2)];
   var $101=$tile;
   var $102=$100;
   var $103=((($101)-($102))|0);
   var $104=((((($103)|(0)))/(60))&-1);
   var $105=(($tile)|0);
   var $106=HEAP32[(($105)>>2)];
   var $107=(($this+80)|0);
   var $108=HEAP32[(($107)>>2)];
   var $109=(($this+76)|0);
   var $110=HEAP32[(($109)>>2)];
   var $111=((($108)+($110))|0);
   var $112=$106 << $111;
   var $113=$104 << $108;
   var $114=$112 | $113;
   var $storemerge_i5_i = $114;label = 16; break;
  case 16: 
   var $storemerge_i5_i;
   var $node_i_0 = $18;var $n_i_0 = 0;label = 17; break;
  case 17: 
   var $n_i_0;
   var $node_i_0;
   var $116=(($node_i_0)>>>(0)) < (($25)>>>(0));
   if ($116) { label = 18; break; } else { label = 42; break; }
  case 18: 
   var $118=(($node_i_0+6)|0);
   var $119=HEAP16[(($118)>>1)];
   var $120=(($78)&(65535)) > (($119)&(65535));
   if ($120) { var $126 = 0;label = 20; break; } else { label = 19; break; }
  case 19: 
   var $122=(($node_i_0)|0);
   var $123=HEAP16[(($122)>>1)];
   var $124=(($88)&(65535)) < (($123)&(65535));
   var $_=$124 ? 0 : 1;
   var $126 = $_;label = 20; break;
  case 20: 
   var $126;
   var $127=(($node_i_0+8)|0);
   var $128=HEAP16[(($127)>>1)];
   var $129=(($81)&(65535)) > (($128)&(65535));
   if ($129) { var $135 = 0;label = 22; break; } else { label = 21; break; }
  case 21: 
   var $131=(($node_i_0+2)|0);
   var $132=HEAP16[(($131)>>1)];
   var $133=(($92)&(65535)) < (($132)&(65535));
   var $_650=$133 ? 0 : $126;
   var $135 = $_650;label = 22; break;
  case 22: 
   var $135;
   var $136=(($node_i_0+10)|0);
   var $137=HEAP16[(($136)>>1)];
   var $138=(($84)&(65535)) > (($137)&(65535));
   if ($138) { var $144 = 0;label = 24; break; } else { label = 23; break; }
  case 23: 
   var $140=(($node_i_0+4)|0);
   var $141=HEAP16[(($140)>>1)];
   var $142=(($96)&(65535)) < (($141)&(65535));
   var $143=$135 & 1;
   var $_651=$142 ? 0 : $143;
   var $144 = $_651;label = 24; break;
  case 24: 
   var $144;
   var $145=(($node_i_0+12)|0);
   var $146=HEAP32[(($145)>>2)];
   var $_lobit_i=$146 >>> 31;
   var $147=(($_lobit_i) & 255);
   var $148=(($147 << 24) >> 24)==1;
   if ($148) { var $n_i_1 = $n_i_0;label = 28; break; } else { label = 25; break; }
  case 25: 
   var $150=(($144 << 24) >> 24)==0;
   if ($150) { var $n_i_1647 = $n_i_0;label = 30; break; } else { label = 26; break; }
  case 26: 
   var $152=(($n_i_0)|(0)) < 128;
   if ($152) { label = 27; break; } else { var $n_i_1 = $n_i_0;label = 28; break; }
  case 27: 
   var $154=$storemerge_i5_i | $146;
   var $155=((($n_i_0)+(1))|0);
   var $156=(($polys+($n_i_0<<2))|0);
   HEAP32[(($156)>>2)]=$154;
   var $n_i_1 = $155;label = 28; break;
  case 28: 
   var $n_i_1;
   var $157=(($144 << 24) >> 24)==0;
   if ($157) { var $n_i_1648 = $n_i_1;label = 29; break; } else { var $n_i_1647 = $n_i_1;label = 30; break; }
  case 29: 
   var $n_i_1648;
   var $158=(($147 << 24) >> 24)==1;
   if ($158) { label = 31; break; } else { var $n_i_1647 = $n_i_1648;label = 30; break; }
  case 30: 
   var $n_i_1647;
   var $159=(($node_i_0+16)|0);
   var $node_i_0 = $159;var $n_i_0 = $n_i_1647;label = 17; break;
  case 31: 
   var $161=HEAP32[(($145)>>2)];
   var $162=(((-$161))|0);
   var $163=(($node_i_0+($162<<4))|0);
   var $node_i_0 = $163;var $n_i_0 = $n_i_1648;label = 17; break;
  case 32: 
   var $164=(($tile)|(0))==0;
   var $165=(($this+68)|0);
   var $166=HEAP32[(($165)>>2)];
   var $167=$tile;
   var $168=$166;
   var $169=((($167)-($168))|0);
   var $170=((((($169)|(0)))/(60))&-1);
   var $171=(($tile)|0);
   var $172=HEAP32[(($171)>>2)];
   var $173=(($this+80)|0);
   var $174=HEAP32[(($173)>>2)];
   var $175=(($this+76)|0);
   var $176=HEAP32[(($175)>>2)];
   var $177=((($174)+($176))|0);
   var $178=$172 << $177;
   var $179=$170 << $174;
   var $180=$178 | $179;
   var $181=(($tile+8)|0);
   var $182=HEAP32[(($181)>>2)];
   var $183=(($182+24)|0);
   var $184=HEAP32[(($183)>>2)];
   var $185=(($tile+12)|0);
   var $186=(($tile+16)|0);
   var $storemerge_i6 = 0;var $n3_i_0 = 0;label = 33; break;
  case 33: 
   var $n3_i_0;
   var $storemerge_i6;
   var $188=(($storemerge_i6)|(0)) < (($184)|(0));
   if ($188) { label = 34; break; } else { var $storemerge2_i8_in_sroa_speculated = $n3_i_0;var $_pre_phi = $185;var $_pre_phi623 = $186;label = 43; break; }
  case 34: 
   var $190=HEAP32[(($185)>>2)];
   var $191=(($190+($storemerge_i6<<5)+31)|0);
   var $192=HEAP8[($191)];
   var $_mask9=$192 & -64;
   var $193=(($_mask9 << 24) >> 24)==64;
   if ($193) { var $n3_i_1 = $n3_i_0;label = 41; break; } else { label = 35; break; }
  case 35: 
   var $195=(($190+($storemerge_i6<<5)+4)|0);
   var $196=HEAP16[(($195)>>1)];
   var $197=(($196)&(65535));
   var $198=((($197)*(3))&-1);
   var $199=HEAP32[(($186)>>2)];
   var $200=(($199+($198<<2))|0);
   var $201=HEAPF32[(($200)>>2)];
   var $_sum642=((($198)+(1))|0);
   var $202=(($199+($_sum642<<2))|0);
   var $203=HEAPF32[(($202)>>2)];
   var $_sum643=((($198)+(2))|0);
   var $204=(($199+($_sum643<<2))|0);
   var $205=HEAPF32[(($204)>>2)];
   var $206=(($190+($storemerge_i6<<5)+30)|0);
   var $207=HEAP8[($206)];
   var $208=(($207)&(255));
   var $storemerge1_i7 = 1;var $v0_i_i_sroa_2_0 = $205;var $v0_i_i_sroa_1_0 = $203;var $v0_i_i_sroa_0_0 = $201;var $v1_i_i_sroa_2_0 = $205;var $v1_i_i_sroa_1_0 = $203;var $v1_i_i_sroa_0_0 = $201;label = 36; break;
  case 36: 
   var $v1_i_i_sroa_0_0;
   var $v1_i_i_sroa_1_0;
   var $v1_i_i_sroa_2_0;
   var $v0_i_i_sroa_0_0;
   var $v0_i_i_sroa_1_0;
   var $v0_i_i_sroa_2_0;
   var $storemerge1_i7;
   var $210=(($storemerge1_i7)|(0)) < (($208)|(0));
   if ($210) { label = 37; break; } else { label = 38; break; }
  case 37: 
   var $212=(($190+($storemerge_i6<<5)+4+($storemerge1_i7<<1))|0);
   var $213=HEAP16[(($212)>>1)];
   var $214=(($213)&(65535));
   var $215=((($214)*(3))&-1);
   var $216=(($199+($215<<2))|0);
   var $217=HEAPF32[(($216)>>2)];
   var $218=$v0_i_i_sroa_0_0 < $217;
   var $219=$218 ? $v0_i_i_sroa_0_0 : $217;
   var $_sum644=((($215)+(1))|0);
   var $220=(($199+($_sum644<<2))|0);
   var $221=HEAPF32[(($220)>>2)];
   var $222=$v0_i_i_sroa_1_0 < $221;
   var $223=$222 ? $v0_i_i_sroa_1_0 : $221;
   var $_sum645=((($215)+(2))|0);
   var $224=(($199+($_sum645<<2))|0);
   var $225=HEAPF32[(($224)>>2)];
   var $226=$v0_i_i_sroa_2_0 < $225;
   var $227=$226 ? $v0_i_i_sroa_2_0 : $225;
   var $228=$v1_i_i_sroa_0_0 > $217;
   var $229=$228 ? $v1_i_i_sroa_0_0 : $217;
   var $230=$v1_i_i_sroa_1_0 > $221;
   var $231=$230 ? $v1_i_i_sroa_1_0 : $221;
   var $232=$v1_i_i_sroa_2_0 > $225;
   var $233=$232 ? $v1_i_i_sroa_2_0 : $225;
   var $234=((($storemerge1_i7)+(1))|0);
   var $storemerge1_i7 = $234;var $v0_i_i_sroa_2_0 = $227;var $v0_i_i_sroa_1_0 = $223;var $v0_i_i_sroa_0_0 = $219;var $v1_i_i_sroa_2_0 = $233;var $v1_i_i_sroa_1_0 = $231;var $v1_i_i_sroa_0_0 = $229;label = 36; break;
  case 38: 
   var $236=$3 > $v1_i_i_sroa_0_0;
   var $237=$14 < $v0_i_i_sroa_0_0;
   var $or_cond=$236 | $237;
   var $238=$or_cond ? 0 : 1;
   var $239=$8 > $v1_i_i_sroa_1_0;
   var $240=$15 < $v0_i_i_sroa_1_0;
   var $or_cond652=$239 | $240;
   var $241=$or_cond652 ? 0 : $238;
   var $242=$13 > $v1_i_i_sroa_2_0;
   var $243=$16 < $v0_i_i_sroa_2_0;
   var $or_cond653=$242 | $243;
   if ($or_cond653) { var $n3_i_1 = $n3_i_0;label = 41; break; } else { label = 39; break; }
  case 39: 
   var $244=$241 & 1;
   var $phitmp=(($244 << 24) >> 24)!=0;
   var $245=(($n3_i_0)|(0)) < 128;
   var $or_cond654=$phitmp & $245;
   if ($or_cond654) { label = 40; break; } else { var $n3_i_1 = $n3_i_0;label = 41; break; }
  case 40: 
   var $247=$180 | $storemerge_i6;
   var $248=((($n3_i_0)+(1))|0);
   var $249=(($polys+($n3_i_0<<2))|0);
   HEAP32[(($249)>>2)]=$247;
   var $n3_i_1 = $248;label = 41; break;
  case 41: 
   var $n3_i_1;
   var $250=((($storemerge_i6)+(1))|0);
   var $storemerge_i6 = $250;var $n3_i_0 = $n3_i_1;label = 33; break;
  case 42: 
   var $_pre621=(($tile+12)|0);
   var $_pre622=(($tile+16)|0);
   var $storemerge2_i8_in_sroa_speculated = $n_i_0;var $_pre_phi = $_pre621;var $_pre_phi623 = $_pre622;label = 43; break;
  case 43: 
   var $_pre_phi623;
   var $_pre_phi;
   var $storemerge2_i8_in_sroa_speculated;
   var $251=(($this+80)|0);
   var $252=$verts_i;
   var $253=$edged_i;
   var $254=$edget_i;
   var $255=$v_i;
   var $256=(($nearestPt)|(0))==0;
   var $257=(($nearestPt+4)|0);
   var $258=(($nearestPt+8)|0);
   var $259=(($tile+24)|0);
   var $260=(($tile+32)|0);
   var $261=(($tile+28)|0);
   var $262=(($v_i)|0);
   var $263=(($v_i+4)|0);
   var $264=(($v_i+8)|0);
   var $storemerge = 0;var $nearestDistanceSqr_0 = 3.4028234663852886e+38;var $nearest_0 = 0;var $h_i_0 = 0;label = 44; break;
  case 44: 
   var $h_i_0;
   var $nearest_0;
   var $nearestDistanceSqr_0;
   var $storemerge;
   var $266=(($storemerge)|(0)) < (($storemerge2_i8_in_sroa_speculated)|(0));
   if ($266) { label = 45; break; } else { label = 81; break; }
  case 45: 
   var $268=(($polys+($storemerge<<2))|0);
   var $269=HEAP32[(($268)>>2)];
   var $270=HEAP32[(($251)>>2)];
   var $271=1 << $270;
   var $272=((($271)-(1))|0);
   var $273=$272 & $269;
   var $274=HEAP32[(($_pre_phi)>>2)];
   var $275=(($274+($273<<5)+31)|0);
   var $276=HEAP8[($275)];
   var $_mask=$276 & -64;
   var $277=(($_mask << 24) >> 24)==64;
   if ($277) { label = 46; break; } else { label = 47; break; }
  case 46: 
   var $279=(($274+($273<<5)+4)|0);
   var $280=HEAP16[(($279)>>1)];
   var $281=(($280)&(65535));
   var $282=((($281)*(3))&-1);
   var $283=HEAP32[(($_pre_phi623)>>2)];
   var $284=(($283+($282<<2))|0);
   var $285=(($274+($273<<5)+6)|0);
   var $286=HEAP16[(($285)>>1)];
   var $287=(($286)&(65535));
   var $288=((($287)*(3))&-1);
   var $289=(($283+($288<<2))|0);
   var $290=HEAPF32[(($284)>>2)];
   var $291=HEAPF32[(($center)>>2)];
   var $292=($290)-($291);
   var $_sum638=((($282)+(1))|0);
   var $293=(($283+($_sum638<<2))|0);
   var $294=HEAPF32[(($293)>>2)];
   var $295=HEAPF32[(($4)>>2)];
   var $296=($294)-($295);
   var $_sum639=((($282)+(2))|0);
   var $297=(($283+($_sum639<<2))|0);
   var $298=HEAPF32[(($297)>>2)];
   var $299=HEAPF32[(($9)>>2)];
   var $300=($298)-($299);
   var $301=($292)*($292);
   var $302=($296)*($296);
   var $303=($301)+($302);
   var $304=($300)*($300);
   var $305=($303)+($304);
   var $306=Math.sqrt($305);
   var $307=HEAPF32[(($289)>>2)];
   var $308=($307)-($291);
   var $_sum640=((($288)+(1))|0);
   var $309=(($283+($_sum640<<2))|0);
   var $310=HEAPF32[(($309)>>2)];
   var $311=($310)-($295);
   var $_sum641=((($288)+(2))|0);
   var $312=(($283+($_sum641<<2))|0);
   var $313=HEAPF32[(($312)>>2)];
   var $314=($313)-($299);
   var $315=($308)*($308);
   var $316=($311)*($311);
   var $317=($315)+($316);
   var $318=($314)*($314);
   var $319=($317)+($318);
   var $320=Math.sqrt($319);
   var $321=($306)+($320);
   var $322=($306)/($321);
   var $323=($307)-($290);
   var $324=($323)*($322);
   var $325=($290)+($324);
   var $326=($310)-($294);
   var $327=($326)*($322);
   var $328=($294)+($327);
   var $329=($313)-($298);
   var $330=($329)*($322);
   var $331=($298)+($330);
   var $closestPtPoly_sroa_2_1 = $331;var $closestPtPoly_sroa_1_1 = $328;var $closestPtPoly_sroa_0_1 = $325;var $h_i_3 = $h_i_0;var $565 = $291;var $564 = $295;var $563 = $299;label = 78; break;
  case 47: 
   var $333=HEAP32[(($259)>>2)];
   var $334=(($274+($273<<5)+30)|0);
   var $335=HEAP8[($334)];
   var $336=(($335)&(255));
   var $storemerge_i = 0;label = 48; break;
  case 48: 
   var $storemerge_i;
   var $338=(($storemerge_i)|(0)) < (($336)|(0));
   if ($338) { label = 49; break; } else { label = 50; break; }
  case 49: 
   var $340=((($storemerge_i)*(3))&-1);
   var $341=(($verts_i+($340<<2))|0);
   var $342=(($274+($273<<5)+4+($storemerge_i<<1))|0);
   var $343=HEAP16[(($342)>>1)];
   var $344=(($343)&(65535));
   var $345=((($344)*(3))&-1);
   var $346=HEAP32[(($_pre_phi623)>>2)];
   var $347=(($346+($345<<2))|0);
   var $348=HEAPF32[(($347)>>2)];
   HEAPF32[(($341)>>2)]=$348;
   var $_sum634=((($345)+(1))|0);
   var $349=(($346+($_sum634<<2))|0);
   var $350=HEAPF32[(($349)>>2)];
   var $_sum635=((($340)+(1))|0);
   var $351=(($verts_i+($_sum635<<2))|0);
   HEAPF32[(($351)>>2)]=$350;
   var $_sum636=((($345)+(2))|0);
   var $352=(($346+($_sum636<<2))|0);
   var $353=HEAPF32[(($352)>>2)];
   var $_sum637=((($340)+(2))|0);
   var $354=(($verts_i+($_sum637<<2))|0);
   HEAPF32[(($354)>>2)]=$353;
   var $355=((($storemerge_i)+(1))|0);
   var $storemerge_i = $355;label = 48; break;
  case 50: 
   var $357=HEAPF32[(($center)>>2)];
   var $358=HEAPF32[(($4)>>2)];
   var $359=HEAPF32[(($9)>>2)];
   var $360=((($336)-(1))|0);
   var $storemerge_i4_i = $360;var $i_i_i_0 = 0;var $c_i_i_0 = 0;label = 51; break;
  case 51: 
   var $c_i_i_0;
   var $i_i_i_0;
   var $storemerge_i4_i;
   var $362=(($i_i_i_0)|(0)) < (($336)|(0));
   if ($362) { label = 52; break; } else { label = 63; break; }
  case 52: 
   var $364=((($i_i_i_0)*(3))&-1);
   var $365=(($verts_i+($364<<2))|0);
   var $366=((($storemerge_i4_i)*(3))&-1);
   var $367=(($verts_i+($366<<2))|0);
   var $_sum_i_i=((($364)+(2))|0);
   var $368=(($verts_i+($_sum_i_i<<2))|0);
   var $369=HEAPF32[(($368)>>2)];
   var $370=$369 > $359;
   var $_sum632=((($366)+(2))|0);
   var $371=(($verts_i+($_sum632<<2))|0);
   var $372=HEAPF32[(($371)>>2)];
   var $373=$372 > $359;
   var $374=$370 ^ $373;
   if ($374) { label = 54; break; } else { label = 53; break; }
  case 53: 
   var $_pre=HEAPF32[(($365)>>2)];
   var $_pre620=HEAPF32[(($367)>>2)];
   var $c_i_i_1 = $c_i_i_0;var $390 = $_pre;var $389 = $_pre620;label = 56; break;
  case 54: 
   var $376=HEAPF32[(($367)>>2)];
   var $377=HEAPF32[(($365)>>2)];
   var $378=($376)-($377);
   var $379=($359)-($369);
   var $380=($378)*($379);
   var $381=($372)-($369);
   var $382=($380)/($381);
   var $383=($382)+($377);
   var $384=$357 < $383;
   if ($384) { label = 55; break; } else { var $c_i_i_1 = $c_i_i_0;var $390 = $377;var $389 = $376;label = 56; break; }
  case 55: 
   var $386=$c_i_i_0 & 1;
   var $387=$386 ^ 1;
   var $c_i_i_1 = $387;var $390 = $377;var $389 = $376;label = 56; break;
  case 56: 
   var $389;
   var $390;
   var $c_i_i_1;
   var $391=(($edget_i+($storemerge_i4_i<<2))|0);
   var $392=($390)-($389);
   var $393=($369)-($372);
   var $394=($357)-($389);
   var $395=($359)-($372);
   var $396=($392)*($392);
   var $397=($393)*($393);
   var $398=($396)+($397);
   var $399=($392)*($394);
   var $400=($393)*($395);
   var $401=($399)+($400);
   var $402=$398 > 0;
   if ($402) { label = 57; break; } else { var $storemerge633 = $401;label = 58; break; }
  case 57: 
   var $404=($401)/($398);
   var $storemerge633 = $404;label = 58; break;
  case 58: 
   var $storemerge633;
   HEAPF32[(($391)>>2)]=$storemerge633;
   var $406=$storemerge633 < 0;
   if ($406) { label = 59; break; } else { label = 60; break; }
  case 59: 
   HEAPF32[(($391)>>2)]=0;
   var $411 = 0;label = 62; break;
  case 60: 
   var $409=$storemerge633 > 1;
   if ($409) { label = 61; break; } else { var $411 = $storemerge633;label = 62; break; }
  case 61: 
   HEAPF32[(($391)>>2)]=1;
   var $411 = 1;label = 62; break;
  case 62: 
   var $411;
   var $412=($411)*($392);
   var $413=($389)+($412);
   var $414=($413)-($357);
   var $415=($411)*($393);
   var $416=($372)+($415);
   var $417=($416)-($359);
   var $418=($414)*($414);
   var $419=($417)*($417);
   var $420=($418)+($419);
   var $421=(($edged_i+($storemerge_i4_i<<2))|0);
   HEAPF32[(($421)>>2)]=$420;
   var $422=((($i_i_i_0)+(1))|0);
   var $storemerge_i4_i = $i_i_i_0;var $i_i_i_0 = $422;var $c_i_i_0 = $c_i_i_1;label = 51; break;
  case 63: 
   var $423=$c_i_i_0 & 1;
   var $424=(($423 << 24) >> 24)==0;
   if ($424) { var $storemerge1_i = 0;var $dmin_i_0 = 3.4028234663852886e+38;var $imin_i_0 = -1;label = 64; break; } else { var $closestPtPoly_sroa_2_0_ph = $359;var $closestPtPoly_sroa_1_0_ph = $358;var $closestPtPoly_sroa_0_0_ph = $357;label = 67; break; }
  case 64: 
   var $imin_i_0;
   var $dmin_i_0;
   var $storemerge1_i;
   var $426=(($storemerge1_i)|(0)) < (($336)|(0));
   if ($426) { label = 65; break; } else { label = 66; break; }
  case 65: 
   var $428=(($edged_i+($storemerge1_i<<2))|0);
   var $429=HEAPF32[(($428)>>2)];
   var $430=$429 < $dmin_i_0;
   var $imin_i_1=$430 ? $storemerge1_i : $imin_i_0;
   var $dmin_i_1=$430 ? $429 : $dmin_i_0;
   var $431=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $431;var $dmin_i_0 = $dmin_i_1;var $imin_i_0 = $imin_i_1;label = 64; break;
  case 66: 
   var $433=((($imin_i_0)*(3))&-1);
   var $434=(($verts_i+($433<<2))|0);
   var $435=((($imin_i_0)+(1))|0);
   var $436=((((($435)|(0)))%((($336)|(0))))&-1);
   var $437=((($436)*(3))&-1);
   var $438=(($verts_i+($437<<2))|0);
   var $439=(($edget_i+($imin_i_0<<2))|0);
   var $440=HEAPF32[(($439)>>2)];
   var $441=HEAPF32[(($434)>>2)];
   var $442=HEAPF32[(($438)>>2)];
   var $443=($442)-($441);
   var $444=($443)*($440);
   var $445=($441)+($444);
   var $_sum628=((($433)+(1))|0);
   var $446=(($verts_i+($_sum628<<2))|0);
   var $447=HEAPF32[(($446)>>2)];
   var $_sum629=((($437)+(1))|0);
   var $448=(($verts_i+($_sum629<<2))|0);
   var $449=HEAPF32[(($448)>>2)];
   var $450=($449)-($447);
   var $451=($450)*($440);
   var $452=($447)+($451);
   var $_sum630=((($433)+(2))|0);
   var $453=(($verts_i+($_sum630<<2))|0);
   var $454=HEAPF32[(($453)>>2)];
   var $_sum631=((($437)+(2))|0);
   var $455=(($verts_i+($_sum631<<2))|0);
   var $456=HEAPF32[(($455)>>2)];
   var $457=($456)-($454);
   var $458=($457)*($440);
   var $459=($454)+($458);
   var $closestPtPoly_sroa_2_0_ph = $459;var $closestPtPoly_sroa_1_0_ph = $452;var $closestPtPoly_sroa_0_0_ph = $445;label = 67; break;
  case 67: 
   var $closestPtPoly_sroa_0_0_ph;
   var $closestPtPoly_sroa_1_0_ph;
   var $closestPtPoly_sroa_2_0_ph;
   var $460=(($333+((($273)*(12))&-1)+9)|0);
   var $461=HEAP8[($460)];
   var $462=(($461)&(255));
   var $463=(($333+((($273)*(12))&-1)+4)|0);
   var $464=(($333+((($273)*(12))&-1))|0);
   var $storemerge2_i = 0;var $h_i_1 = $h_i_0;label = 68; break;
  case 68: 
   var $h_i_1;
   var $storemerge2_i;
   var $466=(($storemerge2_i)|(0)) < (($462)|(0));
   if ($466) { label = 69; break; } else { var $closestPtPoly_sroa_2_1 = $closestPtPoly_sroa_2_0_ph;var $closestPtPoly_sroa_1_1 = $closestPtPoly_sroa_1_0_ph;var $closestPtPoly_sroa_0_1 = $closestPtPoly_sroa_0_0_ph;var $h_i_3 = $h_i_1;var $565 = $357;var $564 = $358;var $563 = $359;label = 78; break; }
  case 69: 
   var $468=HEAP32[(($463)>>2)];
   var $469=((($468)+($storemerge2_i))|0);
   var $470=$469 << 2;
   var $471=HEAP32[(($260)>>2)];
   var $storemerge3_i = 0;label = 70; break;
  case 70: 
   var $storemerge3_i;
   var $473=(($storemerge3_i)|(0)) < 3;
   if ($473) { label = 71; break; } else { label = 75; break; }
  case 71: 
   var $_sum=((($470)+($storemerge3_i))|0);
   var $475=(($471+$_sum)|0);
   var $476=HEAP8[($475)];
   var $477=(($476)&(255)) < (($335)&(255));
   if ($477) { label = 72; break; } else { label = 73; break; }
  case 72: 
   var $479=(($476)&(255));
   var $480=(($274+($273<<5)+4+($479<<1))|0);
   var $481=HEAP16[(($480)>>1)];
   var $482=(($481)&(65535));
   var $483=((($482)*(3))&-1);
   var $484=HEAP32[(($_pre_phi623)>>2)];
   var $485=(($484+($483<<2))|0);
   var $486=(($v_i+($storemerge3_i<<2))|0);
   HEAP32[(($486)>>2)]=$485;
   label = 74; break;
  case 73: 
   var $488=HEAP32[(($464)>>2)];
   var $489=(($476)&(255));
   var $490=((($489)-($336))|0);
   var $491=((($488)+($490))|0);
   var $492=((($491)*(3))&-1);
   var $493=HEAP32[(($261)>>2)];
   var $494=(($493+($492<<2))|0);
   var $495=(($v_i+($storemerge3_i<<2))|0);
   HEAP32[(($495)>>2)]=$494;
   label = 74; break;
  case 74: 
   var $497=((($storemerge3_i)+(1))|0);
   var $storemerge3_i = $497;label = 70; break;
  case 75: 
   var $499=HEAP32[(($262)>>2)];
   var $500=HEAP32[(($263)>>2)];
   var $501=HEAP32[(($264)>>2)];
   var $502=HEAPF32[(($501)>>2)];
   var $503=HEAPF32[(($499)>>2)];
   var $504=($502)-($503);
   var $505=(($501+4)|0);
   var $506=HEAPF32[(($505)>>2)];
   var $507=(($499+4)|0);
   var $508=HEAPF32[(($507)>>2)];
   var $509=($506)-($508);
   var $510=(($501+8)|0);
   var $511=HEAPF32[(($510)>>2)];
   var $512=(($499+8)|0);
   var $513=HEAPF32[(($512)>>2)];
   var $514=($511)-($513);
   var $515=HEAPF32[(($500)>>2)];
   var $516=($515)-($503);
   var $517=(($500+4)|0);
   var $518=HEAPF32[(($517)>>2)];
   var $519=($518)-($508);
   var $520=(($500+8)|0);
   var $521=HEAPF32[(($520)>>2)];
   var $522=($521)-($513);
   var $523=($357)-($503);
   var $524=($359)-($513);
   var $525=($504)*($504);
   var $526=($514)*($514);
   var $527=($525)+($526);
   var $528=($504)*($516);
   var $529=($514)*($522);
   var $530=($528)+($529);
   var $531=($504)*($523);
   var $532=($514)*($524);
   var $533=($531)+($532);
   var $534=($516)*($516);
   var $535=($522)*($522);
   var $536=($534)+($535);
   var $537=($516)*($523);
   var $538=($522)*($524);
   var $539=($537)+($538);
   var $540=($527)*($536);
   var $541=($530)*($530);
   var $542=($540)-($541);
   var $543=(1)/($542);
   var $544=($536)*($533);
   var $545=($530)*($539);
   var $546=($544)-($545);
   var $547=($546)*($543);
   var $548=($527)*($539);
   var $549=($530)*($533);
   var $550=($548)-($549);
   var $551=($550)*($543);
   var $552=$547 < -0.00009999999747378752;
   var $553=$551 < -0.00009999999747378752;
   var $or_cond655=$552 | $553;
   var $554=($547)+($551);
   var $555=$554 > 1.000100016593933;
   var $or_cond657=$or_cond655 | $555;
   if ($or_cond657) { label = 77; break; } else { label = 76; break; }
  case 76: 
   var $557=($509)*($547);
   var $558=($508)+($557);
   var $559=($519)*($551);
   var $560=($558)+($559);
   var $closestPtPoly_sroa_2_1 = $closestPtPoly_sroa_2_0_ph;var $closestPtPoly_sroa_1_1 = $560;var $closestPtPoly_sroa_0_1 = $closestPtPoly_sroa_0_0_ph;var $h_i_3 = $560;var $565 = $357;var $564 = $358;var $563 = $359;label = 78; break;
  case 77: 
   var $562=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $562;var $h_i_1 = $h_i_1;label = 68; break;
  case 78: 
   var $563;
   var $564;
   var $565;
   var $h_i_3;
   var $closestPtPoly_sroa_0_1;
   var $closestPtPoly_sroa_1_1;
   var $closestPtPoly_sroa_2_1;
   var $566=($closestPtPoly_sroa_0_1)-($565);
   var $567=($closestPtPoly_sroa_1_1)-($564);
   var $568=($closestPtPoly_sroa_2_1)-($563);
   var $569=($566)*($566);
   var $570=($567)*($567);
   var $571=($569)+($570);
   var $572=($568)*($568);
   var $573=($571)+($572);
   var $574=$573 < $nearestDistanceSqr_0;
   var $_not=$574 ^ 1;
   var $brmerge=$_not | $256;
   var $nearest_0_mux=$_not ? $nearest_0 : $269;
   var $nearestDistanceSqr_0_mux=$_not ? $nearestDistanceSqr_0 : $573;
   if ($brmerge) { var $nearestDistanceSqr_1 = $nearestDistanceSqr_0_mux;var $nearest_1 = $nearest_0_mux;label = 80; break; } else { label = 79; break; }
  case 79: 
   HEAPF32[(($nearestPt)>>2)]=$closestPtPoly_sroa_0_1;
   HEAPF32[(($257)>>2)]=$closestPtPoly_sroa_1_1;
   HEAPF32[(($258)>>2)]=$closestPtPoly_sroa_2_1;
   var $nearestDistanceSqr_1 = $573;var $nearest_1 = $269;label = 80; break;
  case 80: 
   var $nearest_1;
   var $nearestDistanceSqr_1;
   var $577=((($storemerge)+(1))|0);
   var $storemerge = $577;var $nearestDistanceSqr_0 = $nearestDistanceSqr_1;var $nearest_0 = $nearest_1;var $h_i_0 = $h_i_3;label = 44; break;
  case 81: 
   STACKTOP = sp;
   return $nearest_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK9dtNavMesh19getNeighbourTilesAtEiiiPP10dtMeshTilei($this, $x, $y, $side, $tiles) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   if ((($side)|(0))==0) {
    label = 2; break;
   }
   else if ((($side)|(0))==1) {
    label = 3; break;
   }
   else if ((($side)|(0))==2) {
    label = 4; break;
   }
   else if ((($side)|(0))==3) {
    label = 5; break;
   }
   else if ((($side)|(0))==4) {
    label = 6; break;
   }
   else if ((($side)|(0))==5) {
    label = 7; break;
   }
   else if ((($side)|(0))==6) {
    label = 8; break;
   }
   else if ((($side)|(0))==7) {
    label = 9; break;
   }
   else {
   var $ny_0 = $y;var $nx_0 = $x;label = 10; break;
   }
  case 2: 
   var $2=((($x)+(1))|0);
   var $ny_0 = $y;var $nx_0 = $2;label = 10; break;
  case 3: 
   var $4=((($x)+(1))|0);
   var $5=((($y)+(1))|0);
   var $ny_0 = $5;var $nx_0 = $4;label = 10; break;
  case 4: 
   var $7=((($y)+(1))|0);
   var $ny_0 = $7;var $nx_0 = $x;label = 10; break;
  case 5: 
   var $9=((($x)-(1))|0);
   var $10=((($y)+(1))|0);
   var $ny_0 = $10;var $nx_0 = $9;label = 10; break;
  case 6: 
   var $12=((($x)-(1))|0);
   var $ny_0 = $y;var $nx_0 = $12;label = 10; break;
  case 7: 
   var $14=((($x)-(1))|0);
   var $15=((($y)-(1))|0);
   var $ny_0 = $15;var $nx_0 = $14;label = 10; break;
  case 8: 
   var $17=((($y)-(1))|0);
   var $ny_0 = $17;var $nx_0 = $x;label = 10; break;
  case 9: 
   var $19=((($x)+(1))|0);
   var $20=((($y)-(1))|0);
   var $ny_0 = $20;var $nx_0 = $19;label = 10; break;
  case 10: 
   var $nx_0;
   var $ny_0;
   var $this_idx=(($this+56)|0);
   var $this_idx_val=HEAP32[(($this_idx)>>2)];
   var $this_idx1=(($this+60)|0);
   var $this_idx1_val=HEAP32[(($this_idx1)>>2)];
   var $22=__ZNK9dtNavMesh10getTilesAtEiiPP10dtMeshTilei($this_idx_val, $this_idx1_val, $nx_0, $ny_0, $tiles, 32);
   return $22;
  default: assert(0, "bad label: " + label);
 }
}
function __Z19dtCreateNavMeshDataP21dtNavMeshCreateParamsPPhPi($params, $outData, $outDataSize) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 40)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $curNode_i=sp;
   var $bmin=(sp)+(8);
   var $bmax=(sp)+(24);
   var $1=(($params+24)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0)) > 6;
   if ($3) { var $_0 = 0;label = 122; break; } else { label = 2; break; }
  case 2: 
   var $5=(($params+4)|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=(($6)|(0)) > 65534;
   var $8=(($6)|(0))==0;
   var $or_cond=$7 | $8;
   if ($or_cond) { var $_0 = 0;label = 122; break; } else { label = 3; break; }
  case 3: 
   var $10=(($params)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($11)|(0))==0;
   if ($12) { var $_0 = 0;label = 122; break; } else { label = 4; break; }
  case 4: 
   var $14=(($params+20)|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=(($15)|(0))==0;
   if ($16) { var $_0 = 0;label = 122; break; } else { label = 5; break; }
  case 5: 
   var $18=(($params+8)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==0;
   if ($20) { var $_0 = 0;label = 122; break; } else { label = 6; break; }
  case 6: 
   var $22=(($params+72)|0);
   var $23=HEAP32[(($22)>>2)];
   var $24=(($23)|(0)) > 0;
   if ($24) { label = 7; break; } else { var $offMeshConClass_0 = 0;var $storedOffMeshConCount_2 = 0;var $offMeshConLinkCount_3 = 0;var $121 = $15;var $120 = $6;label = 24; break; }
  case 7: 
   var $26=$23 << 1;
   var $27=_malloc($26);
   var $28=(($27)|(0))==0;
   if ($28) { var $_0 = 0;label = 122; break; } else { label = 8; break; }
  case 8: 
   var $30=(($params+32)|0);
   var $31=HEAP32[(($30)>>2)];
   var $32=(($31)|(0))==0;
   if ($32) { label = 9; break; } else { label = 10; break; }
  case 9: 
   var $33=HEAP32[(($5)>>2)];
   var $34=(($params+96)|0);
   var $35=(($params+132)|0);
   var $storemerge21 = 0;var $hmin_1 = 3.4028234663852886e+38;var $hmax_1 = -3.4028234663852886e+38;label = 13; break;
  case 10: 
   var $37=(($params+36)|0);
   var $38=HEAP32[(($37)>>2)];
   var $39=(($38)|(0))==0;
   if ($39) { label = 9; break; } else { var $storemerge24 = 0;var $hmin_0 = 3.4028234663852886e+38;var $hmax_0 = -3.4028234663852886e+38;label = 11; break; }
  case 11: 
   var $hmax_0;
   var $hmin_0;
   var $storemerge24;
   var $40=(($storemerge24)|(0)) < (($38)|(0));
   if ($40) { label = 12; break; } else { var $hmin_2 = $hmin_0;var $hmax_2 = $hmax_0;label = 15; break; }
  case 12: 
   var $42=((($storemerge24)*(3))&-1);
   var $43=((($42)+(1))|0);
   var $44=(($31+($43<<2))|0);
   var $45=HEAPF32[(($44)>>2)];
   var $46=$hmin_0 < $45;
   var $47=$46 ? $hmin_0 : $45;
   var $48=$hmax_0 > $45;
   var $49=$48 ? $hmax_0 : $45;
   var $50=((($storemerge24)+(1))|0);
   var $storemerge24 = $50;var $hmin_0 = $47;var $hmax_0 = $49;label = 11; break;
  case 13: 
   var $hmax_1;
   var $hmin_1;
   var $storemerge21;
   var $52=(($storemerge21)|(0)) < (($33)|(0));
   if ($52) { label = 14; break; } else { var $hmin_2 = $hmin_1;var $hmax_2 = $hmax_1;label = 15; break; }
  case 14: 
   var $54=((($storemerge21)*(3))&-1);
   var $55=HEAP32[(($10)>>2)];
   var $56=HEAPF32[(($34)>>2)];
   var $_sum23=((($54)+(1))|0);
   var $57=(($55+($_sum23<<1))|0);
   var $58=HEAP16[(($57)>>1)];
   var $59=(($58)&(65535));
   var $60=(($59)|(0));
   var $61=HEAPF32[(($35)>>2)];
   var $62=($60)*($61);
   var $63=($56)+($62);
   var $64=$hmin_1 < $63;
   var $65=$64 ? $hmin_1 : $63;
   var $66=$hmax_1 > $63;
   var $67=$66 ? $hmax_1 : $63;
   var $68=((($storemerge21)+(1))|0);
   var $storemerge21 = $68;var $hmin_1 = $65;var $hmax_1 = $67;label = 13; break;
  case 15: 
   var $hmax_2;
   var $hmin_2;
   var $69=(($params+124)|0);
   var $70=HEAPF32[(($69)>>2)];
   var $71=($hmin_2)-($70);
   var $72=($hmax_2)+($70);
   var $73=(($bmin)|0);
   var $74=(($params+92)|0);
   var $75=HEAPF32[(($74)>>2)];
   HEAPF32[(($73)>>2)]=$75;
   var $76=(($params+100)|0);
   var $77=HEAPF32[(($76)>>2)];
   var $78=(($bmin+8)|0);
   HEAPF32[(($78)>>2)]=$77;
   var $79=(($bmax)|0);
   var $80=(($params+104)|0);
   var $81=HEAPF32[(($80)>>2)];
   HEAPF32[(($79)>>2)]=$81;
   var $82=(($params+112)|0);
   var $83=HEAPF32[(($82)>>2)];
   var $84=(($bmax+8)|0);
   HEAPF32[(($84)>>2)]=$83;
   var $85=(($bmin+4)|0);
   HEAPF32[(($85)>>2)]=$71;
   var $86=(($bmax+4)|0);
   HEAPF32[(($86)>>2)]=$72;
   var $87=(($params+48)|0);
   var $storemerge22 = 0;var $storedOffMeshConCount_0 = 0;var $offMeshConLinkCount_0 = 0;label = 16; break;
  case 16: 
   var $offMeshConLinkCount_0;
   var $storedOffMeshConCount_0;
   var $storemerge22;
   var $89=HEAP32[(($22)>>2)];
   var $90=(($storemerge22)|(0)) < (($89)|(0));
   if ($90) { label = 17; break; } else { label = 23; break; }
  case 17: 
   var $92=((($storemerge22)*(6))&-1);
   var $93=HEAP32[(($87)>>2)];
   var $94=(($93+($92<<2))|0);
   var $95=$storemerge22 << 1;
   var $96=$95 | 1;
   var $97=((($96)*(3))&-1);
   var $98=(($93+($97<<2))|0);
   var $99=__ZL20classifyOffMeshPointPKfS0_S0_($94, $73, $79);
   var $100=(($27+$95)|0);
   HEAP8[($100)]=$99;
   var $101=__ZL20classifyOffMeshPointPKfS0_S0_($98, $73, $79);
   var $102=(($27+$96)|0);
   HEAP8[($102)]=$101;
   var $103=(($99 << 24) >> 24)==-1;
   if ($103) { label = 18; break; } else { var $_ph = $99;label = 20; break; }
  case 18: 
   var $_sum509510=$92 | 1;
   var $105=(($93+($_sum509510<<2))|0);
   var $106=HEAPF32[(($105)>>2)];
   var $107=$106 < $71;
   var $108=$106 > $72;
   var $or_cond513=$107 | $108;
   if ($or_cond513) { label = 19; break; } else { label = 21; break; }
  case 19: 
   HEAP8[($100)]=0;
   var $_ph = 0;label = 20; break;
  case 20: 
   var $_ph;
   var $110=(($_ph << 24) >> 24)==-1;
   var $offMeshConLinkCount_1 = $offMeshConLinkCount_0;var $114 = $110;label = 22; break;
  case 21: 
   var $112=((($offMeshConLinkCount_0)+(1))|0);
   var $offMeshConLinkCount_1 = $112;var $114 = 1;label = 22; break;
  case 22: 
   var $114;
   var $offMeshConLinkCount_1;
   var $115=(($101 << 24) >> 24)==-1;
   var $116=((($offMeshConLinkCount_1)+(1))|0);
   var $offMeshConLinkCount_2=$115 ? $116 : $offMeshConLinkCount_1;
   var $117=((($storedOffMeshConCount_0)+(1))|0);
   var $_storedOffMeshConCount_0=$114 ? $117 : $storedOffMeshConCount_0;
   var $118=((($storemerge22)+(1))|0);
   var $storemerge22 = $118;var $storedOffMeshConCount_0 = $_storedOffMeshConCount_0;var $offMeshConLinkCount_0 = $offMeshConLinkCount_2;label = 16; break;
  case 23: 
   var $_pre=HEAP32[(($14)>>2)];
   var $_pre478=HEAP32[(($5)>>2)];
   var $offMeshConClass_0 = $27;var $storedOffMeshConCount_2 = $storedOffMeshConCount_0;var $offMeshConLinkCount_3 = $offMeshConLinkCount_0;var $121 = $_pre;var $120 = $_pre478;label = 24; break;
  case 24: 
   var $120;
   var $121;
   var $offMeshConLinkCount_3;
   var $storedOffMeshConCount_2;
   var $offMeshConClass_0;
   var $122=((($121)+($storedOffMeshConCount_2))|0);
   var $123=$storedOffMeshConCount_2 << 1;
   var $124=((($120)+($123))|0);
   var $storemerge = 0;var $edgeCount_0 = 0;var $portalCount_0 = 0;label = 25; break;
  case 25: 
   var $portalCount_0;
   var $edgeCount_0;
   var $storemerge;
   var $126=(($storemerge)|(0)) < (($121)|(0));
   if ($126) { label = 26; break; } else { label = 31; break; }
  case 26: 
   var $128=$storemerge << 1;
   var $129=(Math.imul($128,$2)|0);
   var $130=HEAP32[(($18)>>2)];
   var $storemerge20 = 0;var $edgeCount_1 = $edgeCount_0;var $portalCount_1 = $portalCount_0;label = 27; break;
  case 27: 
   var $portalCount_1;
   var $edgeCount_1;
   var $storemerge20;
   var $132=(($storemerge20)|(0)) < (($2)|(0));
   if ($132) { label = 28; break; } else { label = 30; break; }
  case 28: 
   var $_sum507=((($129)+($storemerge20))|0);
   var $134=(($130+($_sum507<<1))|0);
   var $135=HEAP16[(($134)>>1)];
   var $136=(($135 << 16) >> 16)==-1;
   if ($136) { label = 30; break; } else { label = 29; break; }
  case 29: 
   var $138=((($edgeCount_1)+(1))|0);
   var $139=((($2)+($storemerge20))|0);
   var $_sum508=((($129)+($139))|0);
   var $140=(($130+($_sum508<<1))|0);
   var $141=HEAP16[(($140)>>1)];
   var $142=(($141 << 16) >> 16) >= 0;
   var $143=$141 & 15;
   var $144=(($143 << 16) >> 16)==15;
   var $or_cond515=$142 | $144;
   var $145=((($portalCount_1)+(1))|0);
   var $portalCount_2=$or_cond515 ? $portalCount_1 : $145;
   var $146=((($storemerge20)+(1))|0);
   var $storemerge20 = $146;var $edgeCount_1 = $138;var $portalCount_1 = $portalCount_2;label = 27; break;
  case 30: 
   var $148=((($storemerge)+(1))|0);
   var $storemerge = $148;var $edgeCount_0 = $edgeCount_1;var $portalCount_0 = $portalCount_1;label = 25; break;
  case 31: 
   var $150=$portalCount_0 << 1;
   var $151=((($edgeCount_0)+($150))|0);
   var $152=$offMeshConLinkCount_3 << 1;
   var $153=((($151)+($152))|0);
   var $154=(($params+28)|0);
   var $155=HEAP32[(($154)>>2)];
   var $156=(($155)|(0))==0;
   if ($156) { var $storemerge1 = 0;var $detailTriCount_0 = 0;label = 39; break; } else { label = 32; break; }
  case 32: 
   var $158=(($params+44)|0);
   var $159=HEAP32[(($158)>>2)];
   var $storemerge18 = 0;var $uniqueDetailVertCount_0 = 0;label = 33; break;
  case 33: 
   var $uniqueDetailVertCount_0;
   var $storemerge18;
   var $161=(($storemerge18)|(0)) < (($121)|(0));
   if ($161) { label = 34; break; } else { var $uniqueDetailVertCount_1 = $uniqueDetailVertCount_0;var $detailTriCount_1 = $159;label = 45; break; }
  case 34: 
   var $163=(Math.imul($storemerge18,$2)|0);
   var $164=$163 << 1;
   var $165=HEAP32[(($18)>>2)];
   var $166=$storemerge18 << 2;
   var $167=$166 | 1;
   var $168=(($155+($167<<2))|0);
   var $169=HEAP32[(($168)>>2)];
   var $storemerge19 = 0;var $nv_0 = 0;label = 35; break;
  case 35: 
   var $nv_0;
   var $storemerge19;
   var $171=(($storemerge19)|(0)) < (($2)|(0));
   if ($171) { label = 36; break; } else { label = 38; break; }
  case 36: 
   var $_sum505=((($164)+($storemerge19))|0);
   var $173=(($165+($_sum505<<1))|0);
   var $174=HEAP16[(($173)>>1)];
   var $175=(($174 << 16) >> 16)==-1;
   if ($175) { label = 38; break; } else { label = 37; break; }
  case 37: 
   var $177=((($nv_0)+(1))|0);
   var $178=((($storemerge19)+(1))|0);
   var $storemerge19 = $178;var $nv_0 = $177;label = 35; break;
  case 38: 
   var $180=((($169)-($nv_0))|0);
   var $181=((($uniqueDetailVertCount_0)+($180))|0);
   var $182=((($storemerge18)+(1))|0);
   var $storemerge18 = $182;var $uniqueDetailVertCount_0 = $181;label = 33; break;
  case 39: 
   var $detailTriCount_0;
   var $storemerge1;
   var $184=(($storemerge1)|(0)) < (($121)|(0));
   if ($184) { label = 40; break; } else { var $uniqueDetailVertCount_1 = 0;var $detailTriCount_1 = $detailTriCount_0;label = 45; break; }
  case 40: 
   var $186=(Math.imul($storemerge1,$2)|0);
   var $187=$186 << 1;
   var $188=HEAP32[(($18)>>2)];
   var $storemerge17 = 0;var $nv10_0 = 0;label = 41; break;
  case 41: 
   var $nv10_0;
   var $storemerge17;
   var $190=(($storemerge17)|(0)) < (($2)|(0));
   if ($190) { label = 42; break; } else { label = 44; break; }
  case 42: 
   var $_sum506=((($187)+($storemerge17))|0);
   var $192=(($188+($_sum506<<1))|0);
   var $193=HEAP16[(($192)>>1)];
   var $194=(($193 << 16) >> 16)==-1;
   if ($194) { label = 44; break; } else { label = 43; break; }
  case 43: 
   var $196=((($nv10_0)+(1))|0);
   var $197=((($storemerge17)+(1))|0);
   var $storemerge17 = $197;var $nv10_0 = $196;label = 41; break;
  case 44: 
   var $199=((($nv10_0)-(2))|0);
   var $200=((($detailTriCount_0)+($199))|0);
   var $201=((($storemerge1)+(1))|0);
   var $storemerge1 = $201;var $detailTriCount_0 = $200;label = 39; break;
  case 45: 
   var $detailTriCount_1;
   var $uniqueDetailVertCount_1;
   var $202=((($124)*(12))&-1);
   var $203=$122 << 5;
   var $204=((($153)*(12))&-1);
   var $205=((($121)*(12))&-1);
   var $206=((($uniqueDetailVertCount_1)*(12))&-1);
   var $207=$detailTriCount_1 << 2;
   var $208=(($params+136)|0);
   var $209=HEAP8[($208)];
   var $210=$209 & 1;
   var $211=(($210 << 24) >> 24)==0;
   var $212=$121 << 5;
   var $_=$211 ? 0 : $212;
   var $213=((($storedOffMeshConCount_2)*(36))&-1);
   var $214=((($202)+(100))|0);
   var $215=((($214)+($203))|0);
   var $216=((($215)+($204))|0);
   var $217=((($216)+($205))|0);
   var $218=((($217)+($206))|0);
   var $219=((($218)+($207))|0);
   var $220=((($219)+($_))|0);
   var $221=((($220)+($213))|0);
   var $222=_malloc($221);
   var $223=(($222)|(0))==0;
   if ($223) { label = 46; break; } else { label = 48; break; }
  case 46: 
   var $225=(($offMeshConClass_0)|(0))==0;
   if ($225) { var $_0 = 0;label = 122; break; } else { label = 47; break; }
  case 47: 
   _free($offMeshConClass_0);
   var $_0 = 0;label = 122; break;
  case 48: 
   _memset($222, 0, $221);
   var $228=(($222+100)|0);
   var $229=$228;
   var $230=(($222+$214)|0);
   var $231=$230;
   var $232=(($222+$216)|0);
   var $233=$232;
   var $234=(($222+$217)|0);
   var $235=$234;
   var $236=(($222+$218)|0);
   var $237=(($222+$219)|0);
   var $238=$237;
   var $239=(($222+$220)|0);
   var $240=$239;
   var $241=$222;
   HEAP32[(($241)>>2)]=1145979222;
   var $242=(($222+4)|0);
   var $243=$242;
   HEAP32[(($243)>>2)]=7;
   var $244=(($params+80)|0);
   var $245=HEAP32[(($244)>>2)];
   var $246=(($222+8)|0);
   var $247=$246;
   HEAP32[(($247)>>2)]=$245;
   var $248=(($params+84)|0);
   var $249=HEAP32[(($248)>>2)];
   var $250=(($222+12)|0);
   var $251=$250;
   HEAP32[(($251)>>2)]=$249;
   var $252=(($params+88)|0);
   var $253=HEAP32[(($252)>>2)];
   var $254=(($222+16)|0);
   var $255=$254;
   HEAP32[(($255)>>2)]=$253;
   var $256=(($params+76)|0);
   var $257=HEAP32[(($256)>>2)];
   var $258=(($222+20)|0);
   var $259=$258;
   HEAP32[(($259)>>2)]=$257;
   var $260=(($222+24)|0);
   var $261=$260;
   HEAP32[(($261)>>2)]=$122;
   var $262=(($222+28)|0);
   var $263=$262;
   HEAP32[(($263)>>2)]=$124;
   var $264=(($222+32)|0);
   var $265=$264;
   HEAP32[(($265)>>2)]=$153;
   var $266=(($222+72)|0);
   var $267=$266;
   var $268=(($params+92)|0);
   var $269=HEAPF32[(($268)>>2)];
   HEAPF32[(($267)>>2)]=$269;
   var $270=(($params+96)|0);
   var $271=HEAPF32[(($270)>>2)];
   var $272=(($222+76)|0);
   var $273=$272;
   HEAPF32[(($273)>>2)]=$271;
   var $274=(($params+100)|0);
   var $275=HEAPF32[(($274)>>2)];
   var $276=(($222+80)|0);
   var $277=$276;
   HEAPF32[(($277)>>2)]=$275;
   var $278=(($222+84)|0);
   var $279=$278;
   var $280=(($params+104)|0);
   var $281=HEAPF32[(($280)>>2)];
   HEAPF32[(($279)>>2)]=$281;
   var $282=(($params+108)|0);
   var $283=HEAPF32[(($282)>>2)];
   var $284=(($222+88)|0);
   var $285=$284;
   HEAPF32[(($285)>>2)]=$283;
   var $286=(($params+112)|0);
   var $287=HEAPF32[(($286)>>2)];
   var $288=(($222+92)|0);
   var $289=$288;
   HEAPF32[(($289)>>2)]=$287;
   var $290=HEAP32[(($14)>>2)];
   var $291=(($222+36)|0);
   var $292=$291;
   HEAP32[(($292)>>2)]=$290;
   var $293=(($222+40)|0);
   var $294=$293;
   HEAP32[(($294)>>2)]=$uniqueDetailVertCount_1;
   var $295=(($222+44)|0);
   var $296=$295;
   HEAP32[(($296)>>2)]=$detailTriCount_1;
   var $297=(($params+128)|0);
   var $298=HEAPF32[(($297)>>2)];
   var $299=(1)/($298);
   var $300=(($222+96)|0);
   var $301=$300;
   HEAPF32[(($301)>>2)]=$299;
   var $302=HEAP32[(($14)>>2)];
   var $303=(($222+56)|0);
   var $304=$303;
   HEAP32[(($304)>>2)]=$302;
   var $305=(($params+116)|0);
   var $306=HEAPF32[(($305)>>2)];
   var $307=(($222+60)|0);
   var $308=$307;
   HEAPF32[(($308)>>2)]=$306;
   var $309=(($params+120)|0);
   var $310=HEAPF32[(($309)>>2)];
   var $311=(($222+64)|0);
   var $312=$311;
   HEAPF32[(($312)>>2)]=$310;
   var $313=(($params+124)|0);
   var $314=HEAPF32[(($313)>>2)];
   var $315=(($222+68)|0);
   var $316=$315;
   HEAPF32[(($316)>>2)]=$314;
   var $317=(($222+52)|0);
   var $318=$317;
   HEAP32[(($318)>>2)]=$storedOffMeshConCount_2;
   var $319=HEAP8[($208)];
   var $320=$319 & 1;
   var $321=(($320 << 24) >> 24)==0;
   if ($321) { var $326 = 0;label = 50; break; } else { label = 49; break; }
  case 49: 
   var $323=HEAP32[(($14)>>2)];
   var $324=$323 << 1;
   var $326 = $324;label = 50; break;
  case 50: 
   var $326;
   var $327=(($222+48)|0);
   var $328=$327;
   HEAP32[(($328)>>2)]=$326;
   var $329=HEAP32[(($5)>>2)];
   var $330=HEAP32[(($14)>>2)];
   var $331=(($params+96)|0);
   var $332=(($params+132)|0);
   var $333=(($params+100)|0);
   var $storemerge8 = 0;var $335 = $329;label = 51; break;
  case 51: 
   var $335;
   var $storemerge8;
   var $336=(($storemerge8)|(0)) < (($335)|(0));
   if ($336) { label = 52; break; } else { label = 53; break; }
  case 52: 
   var $338=((($storemerge8)*(3))&-1);
   var $339=HEAP32[(($10)>>2)];
   var $340=(($339+($338<<1))|0);
   var $341=(($229+($338<<2))|0);
   var $342=HEAPF32[(($268)>>2)];
   var $343=HEAP16[(($340)>>1)];
   var $344=(($343)&(65535));
   var $345=(($344)|(0));
   var $346=HEAPF32[(($297)>>2)];
   var $347=($345)*($346);
   var $348=($342)+($347);
   HEAPF32[(($341)>>2)]=$348;
   var $349=HEAPF32[(($331)>>2)];
   var $_sum501=((($338)+(1))|0);
   var $350=(($339+($_sum501<<1))|0);
   var $351=HEAP16[(($350)>>1)];
   var $352=(($351)&(65535));
   var $353=(($352)|(0));
   var $354=HEAPF32[(($332)>>2)];
   var $355=($353)*($354);
   var $356=($349)+($355);
   var $_sum502=((($338)+(1))|0);
   var $357=(($229+($_sum502<<2))|0);
   HEAPF32[(($357)>>2)]=$356;
   var $358=HEAPF32[(($333)>>2)];
   var $_sum503=((($338)+(2))|0);
   var $359=(($339+($_sum503<<1))|0);
   var $360=HEAP16[(($359)>>1)];
   var $361=(($360)&(65535));
   var $362=(($361)|(0));
   var $363=HEAPF32[(($297)>>2)];
   var $364=($362)*($363);
   var $365=($358)+($364);
   var $_sum504=((($338)+(2))|0);
   var $366=(($229+($_sum504<<2))|0);
   HEAPF32[(($366)>>2)]=$365;
   var $367=((($storemerge8)+(1))|0);
   var $_pre479=HEAP32[(($5)>>2)];
   var $storemerge8 = $367;var $335 = $_pre479;label = 51; break;
  case 53: 
   var $369=(($params+48)|0);
   var $storemerge9 = 0;var $n_0 = 0;label = 54; break;
  case 54: 
   var $n_0;
   var $storemerge9;
   var $371=HEAP32[(($22)>>2)];
   var $372=(($storemerge9)|(0)) < (($371)|(0));
   if ($372) { label = 55; break; } else { label = 58; break; }
  case 55: 
   var $374=$storemerge9 << 1;
   var $375=(($offMeshConClass_0+$374)|0);
   var $376=HEAP8[($375)];
   var $377=(($376 << 24) >> 24)==-1;
   if ($377) { label = 56; break; } else { var $n_1 = $n_0;label = 57; break; }
  case 56: 
   var $379=((($storemerge9)*(6))&-1);
   var $380=HEAP32[(($369)>>2)];
   var $381=(($380+($379<<2))|0);
   var $382=$n_0 << 1;
   var $383=((($329)+($382))|0);
   var $384=((($383)*(3))&-1);
   var $385=(($229+($384<<2))|0);
   var $386=HEAPF32[(($381)>>2)];
   HEAPF32[(($385)>>2)]=$386;
   var $_sum490491=$379 | 1;
   var $387=(($380+($_sum490491<<2))|0);
   var $388=HEAPF32[(($387)>>2)];
   var $_sum492=((($384)+(1))|0);
   var $389=(($229+($_sum492<<2))|0);
   HEAPF32[(($389)>>2)]=$388;
   var $_sum493=((($379)+(2))|0);
   var $390=(($380+($_sum493<<2))|0);
   var $391=HEAPF32[(($390)>>2)];
   var $_sum494=((($384)+(2))|0);
   var $392=(($229+($_sum494<<2))|0);
   HEAPF32[(($392)>>2)]=$391;
   var $_sum495=((($384)+(3))|0);
   var $393=(($229+($_sum495<<2))|0);
   var $_sum496=((($379)+(3))|0);
   var $394=(($380+($_sum496<<2))|0);
   var $395=HEAPF32[(($394)>>2)];
   HEAPF32[(($393)>>2)]=$395;
   var $_sum497=((($379)+(4))|0);
   var $396=(($380+($_sum497<<2))|0);
   var $397=HEAPF32[(($396)>>2)];
   var $_sum498=((($384)+(4))|0);
   var $398=(($229+($_sum498<<2))|0);
   HEAPF32[(($398)>>2)]=$397;
   var $_sum499=((($379)+(5))|0);
   var $399=(($380+($_sum499<<2))|0);
   var $400=HEAPF32[(($399)>>2)];
   var $_sum500=((($384)+(5))|0);
   var $401=(($229+($_sum500<<2))|0);
   HEAPF32[(($401)>>2)]=$400;
   var $402=((($n_0)+(1))|0);
   var $n_1 = $402;label = 57; break;
  case 57: 
   var $n_1;
   var $404=((($storemerge9)+(1))|0);
   var $storemerge9 = $404;var $n_0 = $n_1;label = 54; break;
  case 58: 
   var $406=HEAP32[(($18)>>2)];
   var $407=(($params+12)|0);
   var $408=(($params+16)|0);
   var $409=$2 << 1;
   var $storemerge10 = 0;var $src_0 = $406;label = 59; break;
  case 59: 
   var $src_0;
   var $storemerge10;
   var $411=HEAP32[(($14)>>2)];
   var $412=(($storemerge10)|(0)) < (($411)|(0));
   if ($412) { label = 60; break; } else { label = 73; break; }
  case 60: 
   var $414=(($231+($storemerge10<<5)+30)|0);
   HEAP8[($414)]=0;
   var $415=HEAP32[(($407)>>2)];
   var $416=(($415+($storemerge10<<1))|0);
   var $417=HEAP16[(($416)>>1)];
   var $418=(($231+($storemerge10<<5)+28)|0);
   HEAP16[(($418)>>1)]=$417;
   var $419=HEAP32[(($408)>>2)];
   var $420=(($419+$storemerge10)|0);
   var $421=HEAP8[($420)];
   var $422=(($231+($storemerge10<<5)+31)|0);
   var $423=$421 & 63;
   HEAP8[($422)]=$423;
   var $424=(($231+($storemerge10<<5)+30)|0);
   var $storemerge16 = 0;label = 61; break;
  case 61: 
   var $storemerge16;
   var $426=(($storemerge16)|(0)) < (($2)|(0));
   if ($426) { label = 62; break; } else { label = 72; break; }
  case 62: 
   var $428=(($src_0+($storemerge16<<1))|0);
   var $429=HEAP16[(($428)>>1)];
   var $430=(($429 << 16) >> 16)==-1;
   if ($430) { label = 72; break; } else { label = 63; break; }
  case 63: 
   var $432=(($231+($storemerge10<<5)+4+($storemerge16<<1))|0);
   HEAP16[(($432)>>1)]=$429;
   var $433=((($2)+($storemerge16))|0);
   var $434=(($src_0+($433<<1))|0);
   var $435=HEAP16[(($434)>>1)];
   var $436=(($435 << 16) >> 16) < 0;
   if ($436) { label = 64; break; } else { label = 70; break; }
  case 64: 
   var $438=$435 & 15;
   if ((($438 << 16) >> 16)==15) {
    label = 65; break;
   }
   else if ((($438 << 16) >> 16)==0) {
    label = 66; break;
   }
   else if ((($438 << 16) >> 16)==1) {
    label = 67; break;
   }
   else if ((($438 << 16) >> 16)==2) {
    label = 68; break;
   }
   else if ((($438 << 16) >> 16)==3) {
    label = 69; break;
   }
   else {
   label = 71; break;
   }
  case 65: 
   var $440=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($440)>>1)]=0;
   label = 71; break;
  case 66: 
   var $442=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($442)>>1)]=-32764;
   label = 71; break;
  case 67: 
   var $444=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($444)>>1)]=-32766;
   label = 71; break;
  case 68: 
   var $446=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($446)>>1)]=-32768;
   label = 71; break;
  case 69: 
   var $448=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($448)>>1)]=-32762;
   label = 71; break;
  case 70: 
   var $450=((($435)+(1))&65535);
   var $451=(($231+($storemerge10<<5)+16+($storemerge16<<1))|0);
   HEAP16[(($451)>>1)]=$450;
   label = 71; break;
  case 71: 
   var $453=HEAP8[($424)];
   var $454=((($453)+(1))&255);
   HEAP8[($424)]=$454;
   var $455=((($storemerge16)+(1))|0);
   var $storemerge16 = $455;label = 61; break;
  case 72: 
   var $457=(($src_0+($409<<1))|0);
   var $458=((($storemerge10)+(1))|0);
   var $storemerge10 = $458;var $src_0 = $457;label = 59; break;
  case 73: 
   var $460=(($params+56)|0);
   var $461=(($params+60)|0);
   var $storemerge11 = 0;var $n_2 = 0;label = 74; break;
  case 74: 
   var $n_2;
   var $storemerge11;
   var $463=HEAP32[(($22)>>2)];
   var $464=(($storemerge11)|(0)) < (($463)|(0));
   if ($464) { label = 75; break; } else { label = 78; break; }
  case 75: 
   var $466=$storemerge11 << 1;
   var $467=(($offMeshConClass_0+$466)|0);
   var $468=HEAP8[($467)];
   var $469=(($468 << 24) >> 24)==-1;
   if ($469) { label = 76; break; } else { var $n_3 = $n_2;label = 77; break; }
  case 76: 
   var $471=((($330)+($n_2))|0);
   var $472=(($231+($471<<5)+30)|0);
   HEAP8[($472)]=2;
   var $473=$n_2 << 1;
   var $474=((($329)+($473))|0);
   var $475=(($474) & 65535);
   var $476=(($231+($471<<5)+4)|0);
   HEAP16[(($476)>>1)]=$475;
   var $477=((($474)+(1))|0);
   var $478=(($477) & 65535);
   var $479=(($231+($471<<5)+6)|0);
   HEAP16[(($479)>>1)]=$478;
   var $480=HEAP32[(($460)>>2)];
   var $481=(($480+($storemerge11<<1))|0);
   var $482=HEAP16[(($481)>>1)];
   var $483=(($231+($471<<5)+28)|0);
   HEAP16[(($483)>>1)]=$482;
   var $484=HEAP32[(($461)>>2)];
   var $485=(($484+$storemerge11)|0);
   var $486=HEAP8[($485)];
   var $487=(($231+($471<<5)+31)|0);
   var $488=$486 & 63;
   var $489=$488 | 64;
   HEAP8[($487)]=$489;
   var $490=((($n_2)+(1))|0);
   var $n_3 = $490;label = 77; break;
  case 77: 
   var $n_3;
   var $492=((($storemerge11)+(1))|0);
   var $storemerge11 = $492;var $n_2 = $n_3;label = 74; break;
  case 78: 
   var $494=HEAP32[(($154)>>2)];
   var $495=(($494)|(0))==0;
   if ($495) { var $storemerge12 = 0;var $tbase_0 = 0;label = 85; break; } else { label = 79; break; }
  case 79: 
   var $497=(($params+32)|0);
   var $storemerge15 = 0;var $vbase_0 = 0;label = 80; break;
  case 80: 
   var $vbase_0;
   var $storemerge15;
   var $499=HEAP32[(($14)>>2)];
   var $500=(($storemerge15)|(0)) < (($499)|(0));
   if ($500) { label = 81; break; } else { label = 84; break; }
  case 81: 
   var $502=$storemerge15 << 2;
   var $503=HEAP32[(($154)>>2)];
   var $504=(($503+($502<<2))|0);
   var $505=HEAP32[(($504)>>2)];
   var $506=$502 | 1;
   var $507=(($503+($506<<2))|0);
   var $508=HEAP32[(($507)>>2)];
   var $509=(($231+($storemerge15<<5)+30)|0);
   var $510=HEAP8[($509)];
   var $511=(($510)&(255));
   var $512=(($vbase_0)&(65535));
   var $513=(($233+((($storemerge15)*(12))&-1))|0);
   HEAP32[(($513)>>2)]=$512;
   var $514=((($508)-($511))|0);
   var $515=(($514) & 255);
   var $516=(($233+((($storemerge15)*(12))&-1)+8)|0);
   HEAP8[($516)]=$515;
   var $517=$502 | 2;
   var $518=HEAP32[(($154)>>2)];
   var $519=(($518+($517<<2))|0);
   var $520=HEAP32[(($519)>>2)];
   var $521=(($233+((($storemerge15)*(12))&-1)+4)|0);
   HEAP32[(($521)>>2)]=$520;
   var $522=$502 | 3;
   var $523=HEAP32[(($154)>>2)];
   var $524=(($523+($522<<2))|0);
   var $525=HEAP32[(($524)>>2)];
   var $526=(($525) & 255);
   var $527=(($233+((($storemerge15)*(12))&-1)+9)|0);
   HEAP8[($527)]=$526;
   var $528=(($508)|(0))==(($511)|(0));
   if ($528) { var $vbase_1 = $vbase_0;label = 83; break; } else { label = 82; break; }
  case 82: 
   var $530=((($512)*(3))&-1);
   var $531=(($235+($530<<2))|0);
   var $532=$531;
   var $533=((($505)+($511))|0);
   var $534=((($533)*(3))&-1);
   var $535=HEAP32[(($497)>>2)];
   var $536=(($535+($534<<2))|0);
   var $537=$536;
   var $538=((($514)*(12))&-1);
   assert($538 % 1 === 0);(_memcpy($532, $537, $538)|0);
   var $539=((($512)+($514))|0);
   var $540=(($539) & 65535);
   var $vbase_1 = $540;label = 83; break;
  case 83: 
   var $vbase_1;
   var $542=((($storemerge15)+(1))|0);
   var $storemerge15 = $542;var $vbase_0 = $vbase_1;label = 80; break;
  case 84: 
   var $544=(($params+40)|0);
   var $545=HEAP32[(($544)>>2)];
   var $546=(($params+44)|0);
   var $547=HEAP32[(($546)>>2)];
   var $548=$547 << 2;
   assert($548 % 1 === 0);(_memcpy($236, $545, $548)|0);
   label = 90; break;
  case 85: 
   var $tbase_0;
   var $storemerge12;
   var $550=HEAP32[(($14)>>2)];
   var $551=(($storemerge12)|(0)) < (($550)|(0));
   if ($551) { label = 86; break; } else { label = 90; break; }
  case 86: 
   var $553=(($231+($storemerge12<<5)+30)|0);
   var $554=HEAP8[($553)];
   var $555=(($554)&(255));
   var $556=(($233+((($storemerge12)*(12))&-1))|0);
   HEAP32[(($556)>>2)]=0;
   var $557=(($233+((($storemerge12)*(12))&-1)+8)|0);
   HEAP8[($557)]=0;
   var $558=(($233+((($storemerge12)*(12))&-1)+4)|0);
   HEAP32[(($558)>>2)]=$tbase_0;
   var $559=((($554)-(2))&255);
   var $560=(($233+((($storemerge12)*(12))&-1)+9)|0);
   HEAP8[($560)]=$559;
   var $561=((($555)-(1))|0);
   var $storemerge14 = 2;var $tbase_1 = $tbase_0;label = 87; break;
  case 87: 
   var $tbase_1;
   var $storemerge14;
   var $563=(($storemerge14)|(0)) < (($555)|(0));
   if ($563) { label = 88; break; } else { label = 89; break; }
  case 88: 
   var $565=$tbase_1 << 2;
   var $_sum485=((($218)+($565))|0);
   var $566=(($222+$_sum485)|0);
   HEAP8[($566)]=0;
   var $567=((($storemerge14)+(255))|0);
   var $568=(($567) & 255);
   var $_sum486=((($_sum485)+(1))|0);
   var $569=(($222+$_sum486)|0);
   HEAP8[($569)]=$568;
   var $570=(($storemerge14) & 255);
   var $_sum487=((($_sum485)+(2))|0);
   var $571=(($222+$_sum487)|0);
   HEAP8[($571)]=$570;
   var $_sum488=((($_sum485)+(3))|0);
   var $572=(($222+$_sum488)|0);
   var $573=(($storemerge14)|(0))==2;
   var $_516=$573 ? 5 : 4;
   var $_517=$573 ? 21 : 20;
   var $574=(($storemerge14)|(0))==(($561)|(0));
   var $storemerge511=$574 ? $_517 : $_516;
   HEAP8[($572)]=$storemerge511;
   var $575=((($tbase_1)+(1))|0);
   var $576=((($storemerge14)+(1))|0);
   var $storemerge14 = $576;var $tbase_1 = $575;label = 87; break;
  case 89: 
   var $578=((($storemerge12)+(1))|0);
   var $storemerge12 = $578;var $tbase_0 = $tbase_1;label = 85; break;
  case 90: 
   var $579=HEAP8[($208)];
   var $580=$579 & 1;
   var $581=(($580 << 24) >> 24)==0;
   if ($581) { label = 112; break; } else { label = 91; break; }
  case 91: 
   var $583=HEAP32[(($10)>>2)];
   var $584=HEAP32[(($18)>>2)];
   var $585=HEAP32[(($14)>>2)];
   var $586=HEAPF32[(($297)>>2)];
   var $587=HEAPF32[(($332)>>2)];
   var $588=$curNode_i;
   var $589=$585 << 4;
   var $590=_malloc($589);
   var $591=$590;
   var $storemerge_i = 0;label = 92; break;
  case 92: 
   var $storemerge_i;
   var $593=(($storemerge_i)|(0)) < (($585)|(0));
   if ($593) { label = 93; break; } else { label = 110; break; }
  case 93: 
   var $595=(($591+($storemerge_i<<4)+12)|0);
   HEAP32[(($595)>>2)]=$storemerge_i;
   var $596=(Math.imul($storemerge_i,$2)|0);
   var $597=$596 << 1;
   var $598=(($584+($597<<1))|0);
   var $599=HEAP16[(($598)>>1)];
   var $600=(($599)&(65535));
   var $601=((($600)*(3))&-1);
   var $602=(($583+($601<<1))|0);
   var $603=HEAP16[(($602)>>1)];
   var $604=(($591+($storemerge_i<<4)+6)|0);
   HEAP16[(($604)>>1)]=$603;
   var $605=(($591+($storemerge_i<<4))|0);
   HEAP16[(($605)>>1)]=$603;
   var $606=HEAP16[(($598)>>1)];
   var $607=(($606)&(65535));
   var $608=((($607)*(3))&-1);
   var $609=((($608)+(1))|0);
   var $610=(($583+($609<<1))|0);
   var $611=HEAP16[(($610)>>1)];
   var $612=(($591+($storemerge_i<<4)+8)|0);
   HEAP16[(($612)>>1)]=$611;
   var $613=(($591+($storemerge_i<<4)+2)|0);
   HEAP16[(($613)>>1)]=$611;
   var $614=HEAP16[(($598)>>1)];
   var $615=(($614)&(65535));
   var $616=((($615)*(3))&-1);
   var $617=((($616)+(2))|0);
   var $618=(($583+($617<<1))|0);
   var $619=HEAP16[(($618)>>1)];
   var $620=(($591+($storemerge_i<<4)+10)|0);
   HEAP16[(($620)>>1)]=$619;
   var $621=(($591+($storemerge_i<<4)+4)|0);
   HEAP16[(($621)>>1)]=$619;
   var $storemerge1_i = 1;var $628 = $603;var $627 = $611;var $626 = $619;var $625 = $603;var $624 = $611;var $623 = $619;label = 94; break;
  case 94: 
   var $623;
   var $624;
   var $625;
   var $626;
   var $627;
   var $628;
   var $storemerge1_i;
   var $629=(($storemerge1_i)|(0)) < (($2)|(0));
   if ($629) { label = 95; break; } else { label = 109; break; }
  case 95: 
   var $_sum484=((($597)+($storemerge1_i))|0);
   var $631=(($584+($_sum484<<1))|0);
   var $632=HEAP16[(($631)>>1)];
   var $633=(($632 << 16) >> 16)==-1;
   if ($633) { label = 109; break; } else { label = 96; break; }
  case 96: 
   var $635=(($632)&(65535));
   var $636=((($635)*(3))&-1);
   var $637=(($583+($636<<1))|0);
   var $638=HEAP16[(($637)>>1)];
   var $639=((($636)+(1))|0);
   var $640=(($583+($639<<1))|0);
   var $641=HEAP16[(($640)>>1)];
   var $642=((($636)+(2))|0);
   var $643=(($583+($642<<1))|0);
   var $644=HEAP16[(($643)>>1)];
   var $645=(($638)&(65535)) < (($628)&(65535));
   if ($645) { label = 97; break; } else { var $648 = $628;label = 98; break; }
  case 97: 
   HEAP16[(($605)>>1)]=$638;
   var $648 = $638;label = 98; break;
  case 98: 
   var $648;
   var $649=(($641)&(65535)) < (($627)&(65535));
   if ($649) { label = 99; break; } else { var $652 = $627;label = 100; break; }
  case 99: 
   HEAP16[(($613)>>1)]=$641;
   var $652 = $641;label = 100; break;
  case 100: 
   var $652;
   var $653=(($644)&(65535)) < (($626)&(65535));
   if ($653) { label = 101; break; } else { var $656 = $626;label = 102; break; }
  case 101: 
   HEAP16[(($621)>>1)]=$644;
   var $656 = $644;label = 102; break;
  case 102: 
   var $656;
   var $657=(($638)&(65535)) > (($625)&(65535));
   if ($657) { label = 103; break; } else { var $660 = $625;label = 104; break; }
  case 103: 
   HEAP16[(($604)>>1)]=$638;
   var $660 = $638;label = 104; break;
  case 104: 
   var $660;
   var $661=(($641)&(65535)) > (($624)&(65535));
   if ($661) { label = 105; break; } else { var $664 = $624;label = 106; break; }
  case 105: 
   HEAP16[(($612)>>1)]=$641;
   var $664 = $641;label = 106; break;
  case 106: 
   var $664;
   var $665=(($644)&(65535)) > (($623)&(65535));
   if ($665) { label = 107; break; } else { var $668 = $623;label = 108; break; }
  case 107: 
   HEAP16[(($620)>>1)]=$644;
   var $668 = $644;label = 108; break;
  case 108: 
   var $668;
   var $669=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $669;var $628 = $648;var $627 = $652;var $626 = $656;var $625 = $660;var $624 = $664;var $623 = $668;label = 94; break;
  case 109: 
   var $671=(($627)&(65535));
   var $672=($671)*($587);
   var $673=($672)/($586);
   var $674=Math.floor($673);
   var $675=($674>=0 ? Math.floor($674) : Math.ceil($674));
   HEAP16[(($613)>>1)]=$675;
   var $676=(($624)&(65535));
   var $677=($676)*($587);
   var $678=($677)/($586);
   var $679=Math.ceil($678);
   var $680=($679>=0 ? Math.floor($679) : Math.ceil($679));
   HEAP16[(($612)>>1)]=$680;
   var $681=((($storemerge_i)+(1))|0);
   var $storemerge_i = $681;label = 92; break;
  case 110: 
   HEAP32[(($curNode_i)>>2)]=0;
   __ZL9subdivideP6BVItemiiiRiP8dtBVNode($591, $585, 0, $585, $curNode_i, $238);
   var $683=(($590)|(0))==0;
   if ($683) { label = 112; break; } else { label = 111; break; }
  case 111: 
   _free($590);
   label = 112; break;
  case 112: 
   var $685=(($params+52)|0);
   var $686=(($params+64)|0);
   var $687=(($params+68)|0);
   var $storemerge13 = 0;var $n_4 = 0;label = 113; break;
  case 113: 
   var $n_4;
   var $storemerge13;
   var $689=HEAP32[(($22)>>2)];
   var $690=(($storemerge13)|(0)) < (($689)|(0));
   if ($690) { label = 114; break; } else { label = 119; break; }
  case 114: 
   var $692=$storemerge13 << 1;
   var $693=(($offMeshConClass_0+$692)|0);
   var $694=HEAP8[($693)];
   var $695=(($694 << 24) >> 24)==-1;
   if ($695) { label = 115; break; } else { var $n_5 = $n_4;label = 118; break; }
  case 115: 
   var $697=((($330)+($n_4))|0);
   var $698=(($697) & 65535);
   var $699=(($240+((($n_4)*(36))&-1)+28)|0);
   HEAP16[(($699)>>1)]=$698;
   var $700=((($storemerge13)*(6))&-1);
   var $701=HEAP32[(($369)>>2)];
   var $702=(($701+($700<<2))|0);
   var $703=(($240+((($n_4)*(36))&-1))|0);
   var $704=HEAPF32[(($702)>>2)];
   HEAPF32[(($703)>>2)]=$704;
   var $_sum480=$700 | 1;
   var $705=(($701+($_sum480<<2))|0);
   var $706=HEAPF32[(($705)>>2)];
   var $707=(($240+((($n_4)*(36))&-1)+4)|0);
   HEAPF32[(($707)>>2)]=$706;
   var $_sum=((($700)+(2))|0);
   var $708=(($701+($_sum<<2))|0);
   var $709=HEAPF32[(($708)>>2)];
   var $710=(($240+((($n_4)*(36))&-1)+8)|0);
   HEAPF32[(($710)>>2)]=$709;
   var $711=(($240+((($n_4)*(36))&-1)+12)|0);
   var $_sum481=((($700)+(3))|0);
   var $712=(($701+($_sum481<<2))|0);
   var $713=HEAPF32[(($712)>>2)];
   HEAPF32[(($711)>>2)]=$713;
   var $_sum482=((($700)+(4))|0);
   var $714=(($701+($_sum482<<2))|0);
   var $715=HEAPF32[(($714)>>2)];
   var $716=(($240+((($n_4)*(36))&-1)+16)|0);
   HEAPF32[(($716)>>2)]=$715;
   var $_sum483=((($700)+(5))|0);
   var $717=(($701+($_sum483<<2))|0);
   var $718=HEAPF32[(($717)>>2)];
   var $719=(($240+((($n_4)*(36))&-1)+20)|0);
   HEAPF32[(($719)>>2)]=$718;
   var $720=HEAP32[(($685)>>2)];
   var $721=(($720+($storemerge13<<2))|0);
   var $722=HEAPF32[(($721)>>2)];
   var $723=(($240+((($n_4)*(36))&-1)+24)|0);
   HEAPF32[(($723)>>2)]=$722;
   var $724=HEAP32[(($686)>>2)];
   var $725=(($724+$storemerge13)|0);
   var $726=HEAP8[($725)];
   var $727=(($726 << 24) >> 24)!=0;
   var $728=(($727)&(1));
   var $729=(($240+((($n_4)*(36))&-1)+30)|0);
   HEAP8[($729)]=$728;
   var $730=$692 | 1;
   var $731=(($offMeshConClass_0+$730)|0);
   var $732=HEAP8[($731)];
   var $733=(($240+((($n_4)*(36))&-1)+31)|0);
   HEAP8[($733)]=$732;
   var $734=HEAP32[(($687)>>2)];
   var $735=(($734)|(0))==0;
   if ($735) { label = 117; break; } else { label = 116; break; }
  case 116: 
   var $737=(($734+($storemerge13<<2))|0);
   var $738=HEAP32[(($737)>>2)];
   var $739=(($240+((($n_4)*(36))&-1)+32)|0);
   HEAP32[(($739)>>2)]=$738;
   label = 117; break;
  case 117: 
   var $741=((($n_4)+(1))|0);
   var $n_5 = $741;label = 118; break;
  case 118: 
   var $n_5;
   var $743=((($storemerge13)+(1))|0);
   var $storemerge13 = $743;var $n_4 = $n_5;label = 113; break;
  case 119: 
   var $745=(($offMeshConClass_0)|(0))==0;
   if ($745) { label = 121; break; } else { label = 120; break; }
  case 120: 
   _free($offMeshConClass_0);
   label = 121; break;
  case 121: 
   HEAP32[(($outData)>>2)]=$222;
   HEAP32[(($outDataSize)>>2)]=$221;
   var $_0 = 1;label = 122; break;
  case 122: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12compareItemXPKvS0_($va, $vb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=$va;
   var $2=HEAP16[(($1)>>1)];
   var $3=$vb;
   var $4=HEAP16[(($3)>>1)];
   var $5=(($2)&(65535)) < (($4)&(65535));
   if ($5) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $7=(($2)&(65535)) > (($4)&(65535));
   var $_=$7 ? 1 : 0;
   return $_;
  case 3: 
   return -1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL20classifyOffMeshPointPKfS0_S0_($pt, $bmin, $bmax) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAPF32[(($pt)>>2)];
   var $2=HEAPF32[(($bmax)>>2)];
   var $3=$1 >= $2;
   var $4=(($3)&(1));
   var $5=(($pt+8)|0);
   var $6=HEAPF32[(($5)>>2)];
   var $7=(($bmax+8)|0);
   var $8=HEAPF32[(($7)>>2)];
   var $9=$6 >= $8;
   var $10=$9 ? 2 : 0;
   var $11=$4 | $10;
   var $12=HEAPF32[(($bmin)>>2)];
   var $13=$1 < $12;
   var $14=$13 ? 4 : 0;
   var $15=$11 | $14;
   var $16=(($bmin+8)|0);
   var $17=HEAPF32[(($16)>>2)];
   var $18=$6 < $17;
   var $19=$18 ? 8 : 0;
   var $20=$15 | $19;
   var $21=(($20)&(255));
   if ((($21)|(0))==3) {
    label = 2; break;
   }
   else if ((($21)|(0))==2) {
    label = 3; break;
   }
   else if ((($21)|(0))==6) {
    label = 4; break;
   }
   else if ((($21)|(0))==4) {
    label = 5; break;
   }
   else if ((($21)|(0))==12) {
    label = 6; break;
   }
   else if ((($21)|(0))==8) {
    label = 7; break;
   }
   else if ((($21)|(0))==9) {
    label = 8; break;
   }
   else if ((($21)|(0))==1) {
    var $_0 = 0;label = 10; break;
   }
   else {
   label = 9; break;
   }
  case 2: 
   var $_0 = 1;label = 10; break;
  case 3: 
   var $_0 = 2;label = 10; break;
  case 4: 
   var $_0 = 3;label = 10; break;
  case 5: 
   var $_0 = 4;label = 10; break;
  case 6: 
   var $_0 = 5;label = 10; break;
  case 7: 
   var $_0 = 6;label = 10; break;
  case 8: 
   var $_0 = 7;label = 10; break;
  case 9: 
   var $_0 = -1;label = 10; break;
  case 10: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12compareItemYPKvS0_($va, $vb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($va+2)|0);
   var $2=$1;
   var $3=HEAP16[(($2)>>1)];
   var $4=(($vb+2)|0);
   var $5=$4;
   var $6=HEAP16[(($5)>>1)];
   var $7=(($3)&(65535)) < (($6)&(65535));
   if ($7) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $9=(($3)&(65535)) > (($6)&(65535));
   var $_=$9 ? 1 : 0;
   return $_;
  case 3: 
   return -1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12compareItemZPKvS0_($va, $vb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($va+4)|0);
   var $2=$1;
   var $3=HEAP16[(($2)>>1)];
   var $4=(($vb+4)|0);
   var $5=$4;
   var $6=HEAP16[(($5)>>1)];
   var $7=(($3)&(65535)) < (($6)&(65535));
   if ($7) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $9=(($3)&(65535)) > (($6)&(65535));
   var $_=$9 ? 1 : 0;
   return $_;
  case 3: 
   return -1;
  default: assert(0, "bad label: " + label);
 }
}
function __Z12rcCalcBoundsPKfiPfS1_($verts, $nv, $bmin, $bmax) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAPF32[(($verts)>>2)];
   HEAPF32[(($bmin)>>2)]=$1;
   var $2=(($verts+4)|0);
   var $3=HEAPF32[(($2)>>2)];
   var $4=(($bmin+4)|0);
   HEAPF32[(($4)>>2)]=$3;
   var $5=(($verts+8)|0);
   var $6=HEAPF32[(($5)>>2)];
   var $7=(($bmin+8)|0);
   HEAPF32[(($7)>>2)]=$6;
   var $8=HEAPF32[(($verts)>>2)];
   HEAPF32[(($bmax)>>2)]=$8;
   var $9=HEAPF32[(($2)>>2)];
   var $10=(($bmax+4)|0);
   HEAPF32[(($10)>>2)]=$9;
   var $11=HEAPF32[(($5)>>2)];
   var $12=(($bmax+8)|0);
   HEAPF32[(($12)>>2)]=$11;
   var $storemerge = 1;label = 2; break;
  case 2: 
   var $storemerge;
   var $14=(($storemerge)|(0)) < (($nv)|(0));
   if ($14) { label = 3; break; } else { label = 4; break; }
  case 3: 
   var $16=((($storemerge)*(3))&-1);
   var $17=(($verts+($16<<2))|0);
   var $18=HEAPF32[(($bmin)>>2)];
   var $19=HEAPF32[(($17)>>2)];
   var $20=$18 < $19;
   var $21=$20 ? $18 : $19;
   HEAPF32[(($bmin)>>2)]=$21;
   var $22=HEAPF32[(($4)>>2)];
   var $_sum=((($16)+(1))|0);
   var $23=(($verts+($_sum<<2))|0);
   var $24=HEAPF32[(($23)>>2)];
   var $25=$22 < $24;
   var $26=$25 ? $22 : $24;
   HEAPF32[(($4)>>2)]=$26;
   var $27=HEAPF32[(($7)>>2)];
   var $_sum42=((($16)+(2))|0);
   var $28=(($verts+($_sum42<<2))|0);
   var $29=HEAPF32[(($28)>>2)];
   var $30=$27 < $29;
   var $31=$30 ? $27 : $29;
   HEAPF32[(($7)>>2)]=$31;
   var $32=HEAPF32[(($bmax)>>2)];
   var $33=HEAPF32[(($17)>>2)];
   var $34=$32 > $33;
   var $35=$34 ? $32 : $33;
   HEAPF32[(($bmax)>>2)]=$35;
   var $36=HEAPF32[(($10)>>2)];
   var $37=HEAPF32[(($23)>>2)];
   var $38=$36 > $37;
   var $39=$38 ? $36 : $37;
   HEAPF32[(($10)>>2)]=$39;
   var $40=HEAPF32[(($12)>>2)];
   var $41=HEAPF32[(($28)>>2)];
   var $42=$40 > $41;
   var $43=$42 ? $40 : $41;
   HEAPF32[(($12)>>2)]=$43;
   var $44=((($storemerge)+(1))|0);
   var $storemerge = $44;label = 2; break;
  case 4: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL9subdivideP6BVItemiiiRiP8dtBVNode($items, $nitems, $imin, $imax, $curNode, $nodes) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=((($imax)-($imin))|0);
   var $2=HEAP32[(($curNode)>>2)];
   var $3=((($2)+(1))|0);
   HEAP32[(($curNode)>>2)]=$3;
   var $4=(($nodes+($2<<4))|0);
   var $5=(($1)|(0))==1;
   if ($5) { label = 2; break; } else { label = 3; break; }
  case 2: 
   var $7=(($items+($imin<<4))|0);
   var $8=HEAP16[(($7)>>1)];
   var $9=(($4)|0);
   HEAP16[(($9)>>1)]=$8;
   var $10=(($items+($imin<<4)+2)|0);
   var $11=HEAP16[(($10)>>1)];
   var $12=(($nodes+($2<<4)+2)|0);
   HEAP16[(($12)>>1)]=$11;
   var $13=(($items+($imin<<4)+4)|0);
   var $14=HEAP16[(($13)>>1)];
   var $15=(($nodes+($2<<4)+4)|0);
   HEAP16[(($15)>>1)]=$14;
   var $16=(($items+($imin<<4)+6)|0);
   var $17=HEAP16[(($16)>>1)];
   var $18=(($nodes+($2<<4)+6)|0);
   HEAP16[(($18)>>1)]=$17;
   var $19=(($items+($imin<<4)+8)|0);
   var $20=HEAP16[(($19)>>1)];
   var $21=(($nodes+($2<<4)+8)|0);
   HEAP16[(($21)>>1)]=$20;
   var $22=(($items+($imin<<4)+10)|0);
   var $23=HEAP16[(($22)>>1)];
   var $24=(($nodes+($2<<4)+10)|0);
   HEAP16[(($24)>>1)]=$23;
   var $25=(($items+($imin<<4)+12)|0);
   var $26=HEAP32[(($25)>>2)];
   var $27=(($nodes+($2<<4)+12)|0);
   HEAP32[(($27)>>2)]=$26;
   label = 23; break;
  case 3: 
   var $29=(($4)|0);
   var $30=(($nodes+($2<<4)+6)|0);
   var $31=(($items+($imin<<4))|0);
   var $32=HEAP16[(($31)>>1)];
   HEAP16[(($29)>>1)]=$32;
   var $33=(($items+($imin<<4)+2)|0);
   var $34=HEAP16[(($33)>>1)];
   var $35=(($nodes+($2<<4)+2)|0);
   HEAP16[(($35)>>1)]=$34;
   var $36=(($items+($imin<<4)+4)|0);
   var $37=HEAP16[(($36)>>1)];
   var $38=(($nodes+($2<<4)+4)|0);
   HEAP16[(($38)>>1)]=$37;
   var $39=(($items+($imin<<4)+6)|0);
   var $40=HEAP16[(($39)>>1)];
   HEAP16[(($30)>>1)]=$40;
   var $41=(($items+($imin<<4)+8)|0);
   var $42=HEAP16[(($41)>>1)];
   var $43=(($nodes+($2<<4)+8)|0);
   HEAP16[(($43)>>1)]=$42;
   var $44=(($items+($imin<<4)+10)|0);
   var $45=HEAP16[(($44)>>1)];
   var $46=(($nodes+($2<<4)+10)|0);
   HEAP16[(($46)>>1)]=$45;
   var $storemerge_in_i_in_sroa_speculated = $imin;var $52 = $32;var $51 = $34;var $50 = $37;var $49 = $40;var $48 = $42;var $47 = $45;label = 4; break;
  case 4: 
   var $47;
   var $48;
   var $49;
   var $50;
   var $51;
   var $52;
   var $storemerge_in_i_in_sroa_speculated;
   var $storemerge_i=((($storemerge_in_i_in_sroa_speculated)+(1))|0);
   var $53=(($storemerge_i)|(0)) < (($imax)|(0));
   if ($53) { label = 5; break; } else { label = 17; break; }
  case 5: 
   var $55=(($items+($storemerge_i<<4))|0);
   var $56=HEAP16[(($55)>>1)];
   var $57=(($56)&(65535)) < (($52)&(65535));
   if ($57) { label = 6; break; } else { var $60 = $52;label = 7; break; }
  case 6: 
   HEAP16[(($29)>>1)]=$56;
   var $60 = $56;label = 7; break;
  case 7: 
   var $60;
   var $61=(($items+($storemerge_i<<4)+2)|0);
   var $62=HEAP16[(($61)>>1)];
   var $63=(($62)&(65535)) < (($51)&(65535));
   if ($63) { label = 8; break; } else { var $66 = $51;label = 9; break; }
  case 8: 
   HEAP16[(($35)>>1)]=$62;
   var $66 = $62;label = 9; break;
  case 9: 
   var $66;
   var $67=(($items+($storemerge_i<<4)+4)|0);
   var $68=HEAP16[(($67)>>1)];
   var $69=(($68)&(65535)) < (($50)&(65535));
   if ($69) { label = 10; break; } else { var $72 = $50;label = 11; break; }
  case 10: 
   HEAP16[(($38)>>1)]=$68;
   var $72 = $68;label = 11; break;
  case 11: 
   var $72;
   var $73=(($items+($storemerge_i<<4)+6)|0);
   var $74=HEAP16[(($73)>>1)];
   var $75=(($74)&(65535)) > (($49)&(65535));
   if ($75) { label = 12; break; } else { var $78 = $49;label = 13; break; }
  case 12: 
   HEAP16[(($30)>>1)]=$74;
   var $78 = $74;label = 13; break;
  case 13: 
   var $78;
   var $79=(($items+($storemerge_i<<4)+8)|0);
   var $80=HEAP16[(($79)>>1)];
   var $81=(($80)&(65535)) > (($48)&(65535));
   if ($81) { label = 14; break; } else { var $84 = $48;label = 15; break; }
  case 14: 
   HEAP16[(($43)>>1)]=$80;
   var $84 = $80;label = 15; break;
  case 15: 
   var $84;
   var $85=(($items+($storemerge_i<<4)+10)|0);
   var $86=HEAP16[(($85)>>1)];
   var $87=(($86)&(65535)) > (($47)&(65535));
   if ($87) { label = 16; break; } else { var $storemerge_in_i_in_sroa_speculated = $storemerge_i;var $52 = $60;var $51 = $66;var $50 = $72;var $49 = $78;var $48 = $84;var $47 = $47;label = 4; break; }
  case 16: 
   HEAP16[(($46)>>1)]=$86;
   var $storemerge_in_i_in_sroa_speculated = $storemerge_i;var $52 = $60;var $51 = $66;var $50 = $72;var $49 = $78;var $48 = $84;var $47 = $86;label = 4; break;
  case 17: 
   var $89=((($49)-($52))&65535);
   var $90=((($48)-($51))&65535);
   var $91=((($47)-($50))&65535);
   var $92=(($90)&(65535)) > (($89)&(65535));
   var $_=$92 ? $90 : $89;
   var $_114=$92 ? 1 : 0;
   var $93=(($91)&(65535)) > (($_)&(65535));
   if ($93) { label = 21; break; } else { label = 18; break; }
  case 18: 
   var $94=(($_114)|(0))==0;
   var $95=(($items+($imin<<4))|0);
   var $96=$95;
   if ($94) { label = 19; break; } else { label = 20; break; }
  case 19: 
   _qsort($96, $1, 16, 42);
   label = 22; break;
  case 20: 
   _qsort($96, $1, 16, 18);
   label = 22; break;
  case 21: 
   var $100=(($items+($imin<<4))|0);
   var $101=$100;
   _qsort($101, $1, 16, 86);
   label = 22; break;
  case 22: 
   var $103=((((($1)|(0)))/(2))&-1);
   var $104=((($103)+($imin))|0);
   __ZL9subdivideP6BVItemiiiRiP8dtBVNode($items, $nitems, $imin, $104, $curNode, $nodes);
   __ZL9subdivideP6BVItemiiiRiP8dtBVNode($items, $nitems, $104, $imax, $curNode, $nodes);
   var $105=HEAP32[(($curNode)>>2)];
   var $106=((($2)-($105))|0);
   var $107=(($nodes+($2<<4)+12)|0);
   HEAP32[(($107)>>2)]=$106;
   label = 23; break;
  case 23: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN9rcContext3logE13rcLogCategoryPKcz($this, $category, $format, varrp) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 528)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $msg=sp;
   var $ap=(sp)+(512);
   var $1=(($this+4)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 5; break; } else { label = 2; break; }
  case 2: 
   var $6=$ap;
   HEAP32[(($6)>>2)]=varrp;HEAP32[((($6)+(4))>>2)]=0;
   var $7=(($msg)|0);
   var $8=(($ap)|0);
   var $9=_vsnprintf($7, 512, $format, $8);
   var $10=(($9)|(0)) > 511;
   if ($10) { label = 3; break; } else { var $len_0 = $9;label = 4; break; }
  case 3: 
   var $12=(($msg+511)|0);
   HEAP8[($12)]=0;
   var $len_0 = 511;label = 4; break;
  case 4: 
   var $len_0;
   var $14=$this;
   var $15=HEAP32[(($14)>>2)];
   var $16=(($15+12)|0);
   var $17=HEAP32[(($16)>>2)];
   FUNCTION_TABLE[$17]($this, $category, $7, $len_0);
   label = 5; break;
  case 5: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z24rcFreeCompactHeightfieldP20rcCompactHeightfield($chf) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($chf)|(0))==0;
   if ($1) { label = 11; break; } else { label = 2; break; }
  case 2: 
   var $3=(($chf+60)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($4)|(0))==0;
   if ($5) { label = 4; break; } else { label = 3; break; }
  case 3: 
   var $7=(($4)|0);
   _free($7);
   label = 4; break;
  case 4: 
   var $8=(($chf+64)|0);
   var $9=HEAP32[(($8)>>2)];
   var $10=(($9)|(0))==0;
   if ($10) { label = 6; break; } else { label = 5; break; }
  case 5: 
   var $12=$9;
   _free($12);
   label = 6; break;
  case 6: 
   var $13=(($chf+68)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($14)|(0))==0;
   if ($15) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $17=$14;
   _free($17);
   label = 8; break;
  case 8: 
   var $18=(($chf+72)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==0;
   if ($20) { label = 10; break; } else { label = 9; break; }
  case 9: 
   _free($19);
   label = 10; break;
  case 10: 
   var $22=$chf;
   _free($22);
   label = 11; break;
  case 11: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z16rcFreeContourSetP12rcContourSet($cset) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($cset)|(0))==0;
   if ($1) { label = 12; break; } else { label = 2; break; }
  case 2: 
   var $2=(($cset+4)|0);
   var $3=(($cset)|0);
   var $storemerge = 0;label = 3; break;
  case 3: 
   var $storemerge;
   var $5=HEAP32[(($2)>>2)];
   var $6=(($storemerge)|(0)) < (($5)|(0));
   var $7=HEAP32[(($3)>>2)];
   if ($6) { label = 4; break; } else { label = 9; break; }
  case 4: 
   var $9=(($7+((($storemerge)*(20))&-1))|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=(($10)|(0))==0;
   if ($11) { var $14 = $7;label = 6; break; } else { label = 5; break; }
  case 5: 
   var $13=$10;
   _free($13);
   var $_pre=HEAP32[(($3)>>2)];
   var $14 = $_pre;label = 6; break;
  case 6: 
   var $14;
   var $15=(($14+((($storemerge)*(20))&-1)+8)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=(($16)|(0))==0;
   if ($17) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $19=$16;
   _free($19);
   label = 8; break;
  case 8: 
   var $21=((($storemerge)+(1))|0);
   var $storemerge = $21;label = 3; break;
  case 9: 
   var $23=(($7)|(0))==0;
   if ($23) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $25=$7;
   _free($25);
   label = 11; break;
  case 11: 
   var $26=$cset;
   _free($26);
   label = 12; break;
  case 12: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z14rcFreePolyMeshP10rcPolyMesh($pmesh) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($pmesh)|(0))==0;
   if ($1) { label = 13; break; } else { label = 2; break; }
  case 2: 
   var $3=(($pmesh)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($4)|(0))==0;
   if ($5) { label = 4; break; } else { label = 3; break; }
  case 3: 
   var $7=$4;
   _free($7);
   label = 4; break;
  case 4: 
   var $8=(($pmesh+4)|0);
   var $9=HEAP32[(($8)>>2)];
   var $10=(($9)|(0))==0;
   if ($10) { label = 6; break; } else { label = 5; break; }
  case 5: 
   var $12=$9;
   _free($12);
   label = 6; break;
  case 6: 
   var $13=(($pmesh+8)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($14)|(0))==0;
   if ($15) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $17=$14;
   _free($17);
   label = 8; break;
  case 8: 
   var $18=(($pmesh+12)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==0;
   if ($20) { label = 10; break; } else { label = 9; break; }
  case 9: 
   var $22=$19;
   _free($22);
   label = 10; break;
  case 10: 
   var $23=(($pmesh+16)|0);
   var $24=HEAP32[(($23)>>2)];
   var $25=(($24)|(0))==0;
   if ($25) { label = 12; break; } else { label = 11; break; }
  case 11: 
   _free($24);
   label = 12; break;
  case 12: 
   var $27=$pmesh;
   _free($27);
   label = 13; break;
  case 13: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z19rcCreateHeightfieldP9rcContextR13rcHeightfieldiiPKfS4_ff($hf, $width, $height, $bmin, $bmax, $cs, $ch) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($hf)|0);
   HEAP32[(($1)>>2)]=$width;
   var $2=(($hf+4)|0);
   HEAP32[(($2)>>2)]=$height;
   var $3=(($hf+8)|0);
   var $4=HEAPF32[(($bmin)>>2)];
   HEAPF32[(($3)>>2)]=$4;
   var $5=(($bmin+4)|0);
   var $6=HEAPF32[(($5)>>2)];
   var $7=(($hf+12)|0);
   HEAPF32[(($7)>>2)]=$6;
   var $8=(($bmin+8)|0);
   var $9=HEAPF32[(($8)>>2)];
   var $10=(($hf+16)|0);
   HEAPF32[(($10)>>2)]=$9;
   var $11=(($hf+20)|0);
   var $12=HEAPF32[(($bmax)>>2)];
   HEAPF32[(($11)>>2)]=$12;
   var $13=(($bmax+4)|0);
   var $14=HEAPF32[(($13)>>2)];
   var $15=(($hf+24)|0);
   HEAPF32[(($15)>>2)]=$14;
   var $16=(($bmax+8)|0);
   var $17=HEAPF32[(($16)>>2)];
   var $18=(($hf+28)|0);
   HEAPF32[(($18)>>2)]=$17;
   var $19=(($hf+32)|0);
   HEAPF32[(($19)>>2)]=$cs;
   var $20=(($hf+36)|0);
   HEAPF32[(($20)>>2)]=$ch;
   var $21=$width << 2;
   var $22=(Math.imul($21,$height)|0);
   var $23=_malloc($22);
   var $24=$23;
   var $25=(($hf+40)|0);
   HEAP32[(($25)>>2)]=$24;
   var $26=(($23)|(0))==0;
   if ($26) { var $storemerge = 0;label = 3; break; } else { label = 2; break; }
  case 2: 
   var $28=HEAP32[(($1)>>2)];
   var $29=$28 << 2;
   var $30=HEAP32[(($2)>>2)];
   var $31=(Math.imul($29,$30)|0);
   _memset($23, 0, $31);
   var $storemerge = 1;label = 3; break;
  case 3: 
   var $storemerge;
   return $storemerge;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN14dtNavMeshQuery4initEPK9dtNavMeshi($this, $nav) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   HEAP32[(($1)>>2)]=$nav;
   var $2=(($this+56)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|(0))==0;
   if ($4) { label = 12; break; } else { label = 2; break; }
  case 2: 
   var $6=(($3+12)|0);
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7)|(0)) < 2048;
   if ($8) { label = 3; break; } else { label = 15; break; }
  case 3: 
   var $10=(($3)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($11)|(0))==0;
   if ($12) { label = 5; break; } else { label = 4; break; }
  case 4: 
   var $14=$11;
   _free($14);
   label = 5; break;
  case 5: 
   var $15=(($3+8)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=(($16)|(0))==0;
   if ($17) { label = 7; break; } else { label = 6; break; }
  case 6: 
   var $19=$16;
   _free($19);
   label = 7; break;
  case 7: 
   var $20=(($3+4)|0);
   var $21=HEAP32[(($20)>>2)];
   var $22=(($21)|(0))==0;
   if ($22) { label = 9; break; } else { label = 8; break; }
  case 8: 
   var $24=$21;
   _free($24);
   label = 9; break;
  case 9: 
   var $25=HEAP32[(($2)>>2)];
   var $26=(($25)|(0))==0;
   if ($26) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $28=$25;
   _free($28);
   label = 11; break;
  case 11: 
   HEAP32[(($2)>>2)]=0;
   label = 12; break;
  case 12: 
   var $29=_malloc(24);
   var $30=(($29)|(0))==0;
   if ($30) { label = 14; break; } else { label = 13; break; }
  case 13: 
   var $32=$29;
   __ZN10dtNodePoolC2Eii($32, 2048, 512);
   HEAP32[(($2)>>2)]=$32;
   var $33=(($29)|(0))==0;
   label = 16; break;
  case 14: 
   HEAP32[(($2)>>2)]=0;
   var $_0 = -2147483644;label = 33; break;
  case 15: 
   var $36=(($3+4)|0);
   var $37=HEAP32[(($36)>>2)];
   var $38=$37;
   var $39=(($3+16)|0);
   var $40=HEAP32[(($39)>>2)];
   var $41=$40 << 1;
   _memset($38, -1, $41);
   var $42=(($3+20)|0);
   HEAP32[(($42)>>2)]=0;
   label = 16; break;
  case 16: 
   var $44=(($this+52)|0);
   var $45=HEAP32[(($44)>>2)];
   var $46=(($45)|(0))==0;
   if ($46) { label = 17; break; } else { label = 20; break; }
  case 17: 
   var $48=_malloc(24);
   var $49=(($48)|(0))==0;
   if ($49) { label = 19; break; } else { label = 18; break; }
  case 18: 
   var $51=$48;
   __ZN10dtNodePoolC2Eii($51, 64, 32);
   HEAP32[(($44)>>2)]=$51;
   var $52=(($48)|(0))==0;
   label = 21; break;
  case 19: 
   HEAP32[(($44)>>2)]=0;
   var $_0 = -2147483644;label = 33; break;
  case 20: 
   var $55=(($45+4)|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=$56;
   var $58=(($45+16)|0);
   var $59=HEAP32[(($58)>>2)];
   var $60=$59 << 1;
   _memset($57, -1, $60);
   var $61=(($45+20)|0);
   HEAP32[(($61)>>2)]=0;
   label = 21; break;
  case 21: 
   var $63=(($this+60)|0);
   var $64=HEAP32[(($63)>>2)];
   var $65=(($64)|(0))==0;
   if ($65) { label = 27; break; } else { label = 22; break; }
  case 22: 
   var $67=(($64+4)|0);
   var $68=HEAP32[(($67)>>2)];
   var $69=(($68)|(0)) < 2048;
   if ($69) { label = 23; break; } else { label = 32; break; }
  case 23: 
   var $71=(($64)|0);
   var $72=HEAP32[(($71)>>2)];
   var $73=(($72)|(0))==0;
   if ($73) { var $76 = $64;label = 25; break; } else { label = 24; break; }
  case 24: 
   var $74=$72;
   _free($74);
   var $_pre=HEAP32[(($63)>>2)];
   var $75=(($_pre)|(0))==0;
   if ($75) { label = 26; break; } else { var $76 = $_pre;label = 25; break; }
  case 25: 
   var $76;
   var $77=$76;
   _free($77);
   label = 26; break;
  case 26: 
   HEAP32[(($63)>>2)]=0;
   label = 27; break;
  case 27: 
   var $78=_malloc(12);
   var $79=(($78)|(0))==0;
   if ($79) { label = 31; break; } else { label = 28; break; }
  case 28: 
   var $81=$78;
   var $82=$78;
   HEAP32[(($82)>>2)]=0;
   var $83=(($78+4)|0);
   var $84=$83;
   HEAP32[(($84)>>2)]=2048;
   var $85=(($78+8)|0);
   var $86=$85;
   HEAP32[(($86)>>2)]=0;
   var $87=_malloc(8196);
   var $88=$87;
   HEAP32[(($82)>>2)]=$88;
   var $89=(($87)|(0))==0;
   if ($89) { label = 29; break; } else { label = 30; break; }
  case 29: 
   ___assert_func(((720)|0), 128, ((6408)|0), ((592)|0));
   throw "Reached an unreachable!";
  case 30: 
   HEAP32[(($63)>>2)]=$81;
   var $92=(($78)|(0))==0;
   var $_0 = 1073741824;label = 33; break;
  case 31: 
   HEAP32[(($63)>>2)]=0;
   var $_0 = -2147483644;label = 33; break;
  case 32: 
   var $95=(($64+8)|0);
   HEAP32[(($95)>>2)]=0;
   var $_0 = 1073741824;label = 33; break;
  case 33: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10dtNodePoolC2Eii($this, $maxNodes, $hashSize) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   HEAP32[(($1)>>2)]=0;
   var $2=(($this+4)|0);
   HEAP32[(($2)>>2)]=0;
   var $3=(($this+8)|0);
   HEAP32[(($3)>>2)]=0;
   var $4=(($this+12)|0);
   HEAP32[(($4)>>2)]=$maxNodes;
   var $5=(($this+16)|0);
   HEAP32[(($5)>>2)]=$hashSize;
   var $6=(($this+20)|0);
   HEAP32[(($6)>>2)]=0;
   var $7=((($hashSize)-(1))|0);
   var $8=$7 >>> 1;
   var $9=$7 | $8;
   var $10=$9 >>> 2;
   var $11=$9 | $10;
   var $12=$11 >>> 4;
   var $13=$11 | $12;
   var $14=$13 >>> 8;
   var $15=$13 | $14;
   var $16=$15 >>> 16;
   var $17=$15 | $16;
   var $18=((($17)+(1))|0);
   var $19=(($18)|(0))==(($hashSize)|(0));
   if ($19) { label = 3; break; } else { label = 2; break; }
  case 2: 
   ___assert_func(((720)|0), 45, ((6440)|0), ((5128)|0));
   throw "Reached an unreachable!";
  case 3: 
   var $22=(($maxNodes)|(0)) > 0;
   if ($22) { label = 5; break; } else { label = 4; break; }
  case 4: 
   ___assert_func(((720)|0), 46, ((6440)|0), ((4096)|0));
   throw "Reached an unreachable!";
  case 5: 
   var $25=((($maxNodes)*(28))&-1);
   var $26=_malloc($25);
   var $27=$26;
   HEAP32[(($1)>>2)]=$27;
   var $28=HEAP32[(($4)>>2)];
   var $29=$28 << 1;
   var $30=_malloc($29);
   var $31=$30;
   HEAP32[(($3)>>2)]=$31;
   var $32=$hashSize << 1;
   var $33=_malloc($32);
   var $34=$33;
   HEAP32[(($2)>>2)]=$34;
   var $35=HEAP32[(($1)>>2)];
   var $36=(($35)|(0))==0;
   if ($36) { label = 6; break; } else { label = 7; break; }
  case 6: 
   ___assert_func(((720)|0), 52, ((6440)|0), ((3176)|0));
   throw "Reached an unreachable!";
  case 7: 
   var $39=HEAP32[(($3)>>2)];
   var $40=(($39)|(0))==0;
   if ($40) { label = 8; break; } else { label = 9; break; }
  case 8: 
   ___assert_func(((720)|0), 53, ((6440)|0), ((2216)|0));
   throw "Reached an unreachable!";
  case 9: 
   var $43=(($33)|(0))==0;
   if ($43) { label = 10; break; } else { label = 11; break; }
  case 10: 
   ___assert_func(((720)|0), 54, ((6440)|0), ((1472)|0));
   throw "Reached an unreachable!";
  case 11: 
   var $46=HEAP32[(($5)>>2)];
   var $47=$46 << 1;
   _memset($33, -1, $47);
   var $48=HEAP32[(($3)>>2)];
   var $49=$48;
   var $50=HEAP32[(($4)>>2)];
   var $51=$50 << 1;
   _memset($49, -1, $51);
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z23rcMarkWalkableTrianglesP9rcContextfPKfiPKiiPh($walkableSlopeAngle, $verts, $0, $tris, $nt, $areas) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $2=($walkableSlopeAngle)/(180);
   var $3=($2)*(3.1415927410125732);
   var $4=Math.cos($3);
   var $storemerge = 0;label = 2; break;
  case 2: 
   var $storemerge;
   var $6=(($storemerge)|(0)) < (($nt)|(0));
   if ($6) { label = 3; break; } else { label = 6; break; }
  case 3: 
   var $8=((($storemerge)*(3))&-1);
   var $9=(($tris+($8<<2))|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=((($10)*(3))&-1);
   var $12=(($verts+($11<<2))|0);
   var $_sum=((($8)+(1))|0);
   var $13=(($tris+($_sum<<2))|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=((($14)*(3))&-1);
   var $16=(($verts+($15<<2))|0);
   var $_sum79=((($8)+(2))|0);
   var $17=(($tris+($_sum79<<2))|0);
   var $18=HEAP32[(($17)>>2)];
   var $19=((($18)*(3))&-1);
   var $20=(($verts+($19<<2))|0);
   var $21=HEAPF32[(($16)>>2)];
   var $22=HEAPF32[(($12)>>2)];
   var $23=($21)-($22);
   var $_sum80=((($15)+(1))|0);
   var $24=(($verts+($_sum80<<2))|0);
   var $25=HEAPF32[(($24)>>2)];
   var $_sum81=((($11)+(1))|0);
   var $26=(($verts+($_sum81<<2))|0);
   var $27=HEAPF32[(($26)>>2)];
   var $28=($25)-($27);
   var $_sum82=((($15)+(2))|0);
   var $29=(($verts+($_sum82<<2))|0);
   var $30=HEAPF32[(($29)>>2)];
   var $_sum83=((($11)+(2))|0);
   var $31=(($verts+($_sum83<<2))|0);
   var $32=HEAPF32[(($31)>>2)];
   var $33=($30)-($32);
   var $34=HEAPF32[(($20)>>2)];
   var $35=($34)-($22);
   var $_sum84=((($19)+(1))|0);
   var $36=(($verts+($_sum84<<2))|0);
   var $37=HEAPF32[(($36)>>2)];
   var $38=($37)-($27);
   var $_sum85=((($19)+(2))|0);
   var $39=(($verts+($_sum85<<2))|0);
   var $40=HEAPF32[(($39)>>2)];
   var $41=($40)-($32);
   var $42=($28)*($41);
   var $43=($33)*($38);
   var $44=($42)-($43);
   var $45=($33)*($35);
   var $46=($23)*($41);
   var $47=($45)-($46);
   var $48=($23)*($38);
   var $49=($28)*($35);
   var $50=($48)-($49);
   var $51=($44)*($44);
   var $52=($47)*($47);
   var $53=($51)+($52);
   var $54=($50)*($50);
   var $55=($53)+($54);
   var $56=Math.sqrt($55);
   var $57=(1)/($56);
   var $58=($47)*($57);
   var $59=$58 > $4;
   if ($59) { label = 4; break; } else { label = 5; break; }
  case 4: 
   var $61=(($areas+$storemerge)|0);
   HEAP8[($61)]=63;
   label = 5; break;
  case 5: 
   var $63=((($storemerge)+(1))|0);
   var $storemerge = $63;label = 2; break;
  case 6: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z25rcBuildCompactHeightfieldP9rcContextiiR13rcHeightfieldR20rcCompactHeightfield($ctx, $walkableHeight, $walkableClimb, $hf, $chf) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 3);
   label = 3; break;
  case 3: 
   var $10=(($hf)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($hf+4)|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($hf+40)|0);
   var $storemerge_i = 0;var $spanCount_i_0 = 0;label = 4; break;
  case 4: 
   var $spanCount_i_0;
   var $storemerge_i;
   var $16=(($storemerge_i)|(0)) < (($13)|(0));
   if ($16) { label = 5; break; } else { label = 12; break; }
  case 5: 
   var $17=(Math.imul($storemerge_i,$11)|0);
   var $storemerge1_i = 0;var $spanCount_i_1 = $spanCount_i_0;label = 6; break;
  case 6: 
   var $spanCount_i_1;
   var $storemerge1_i;
   var $19=(($storemerge1_i)|(0)) < (($11)|(0));
   if ($19) { label = 7; break; } else { label = 11; break; }
  case 7: 
   var $21=((($storemerge1_i)+($17))|0);
   var $22=HEAP32[(($14)>>2)];
   var $23=(($22+($21<<2))|0);
   var $storemerge2_in_i = $23;var $spanCount_i_2 = $spanCount_i_1;label = 8; break;
  case 8: 
   var $spanCount_i_2;
   var $storemerge2_in_i;
   var $storemerge2_i=HEAP32[(($storemerge2_in_i)>>2)];
   var $25=(($storemerge2_i)|(0))==0;
   if ($25) { label = 10; break; } else { label = 9; break; }
  case 9: 
   var $27=$storemerge2_i;
   var $28=HEAP32[(($27)>>2)];
   var $29=(($28)>>>(0)) > 67108863;
   var $30=((($spanCount_i_2)+(1))|0);
   var $_spanCount_i_2=$29 ? $30 : $spanCount_i_2;
   var $31=(($storemerge2_i+4)|0);
   var $storemerge2_in_i = $31;var $spanCount_i_2 = $_spanCount_i_2;label = 8; break;
  case 10: 
   var $33=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $33;var $spanCount_i_1 = $spanCount_i_2;label = 6; break;
  case 11: 
   var $35=((($storemerge_i)+(1))|0);
   var $storemerge_i = $35;var $spanCount_i_0 = $spanCount_i_1;label = 4; break;
  case 12: 
   var $36=(($chf)|0);
   HEAP32[(($36)>>2)]=$11;
   var $37=(($chf+4)|0);
   HEAP32[(($37)>>2)]=$13;
   var $38=(($chf+8)|0);
   HEAP32[(($38)>>2)]=$spanCount_i_0;
   var $39=(($chf+12)|0);
   HEAP32[(($39)>>2)]=$walkableHeight;
   var $40=(($chf+16)|0);
   HEAP32[(($40)>>2)]=$walkableClimb;
   var $41=(($chf+26)|0);
   HEAP16[(($41)>>1)]=0;
   var $42=(($chf+28)|0);
   var $43=(($hf+8)|0);
   var $44=HEAPF32[(($43)>>2)];
   HEAPF32[(($42)>>2)]=$44;
   var $45=(($hf+12)|0);
   var $46=HEAPF32[(($45)>>2)];
   var $47=(($chf+32)|0);
   HEAPF32[(($47)>>2)]=$46;
   var $48=(($hf+16)|0);
   var $49=HEAPF32[(($48)>>2)];
   var $50=(($chf+36)|0);
   HEAPF32[(($50)>>2)]=$49;
   var $51=(($chf+40)|0);
   var $52=(($hf+20)|0);
   var $53=HEAPF32[(($52)>>2)];
   HEAPF32[(($51)>>2)]=$53;
   var $54=(($hf+24)|0);
   var $55=HEAPF32[(($54)>>2)];
   var $56=(($chf+44)|0);
   HEAPF32[(($56)>>2)]=$55;
   var $57=(($hf+28)|0);
   var $58=HEAPF32[(($57)>>2)];
   var $59=(($chf+48)|0);
   HEAPF32[(($59)>>2)]=$58;
   var $60=(($walkableHeight)|(0));
   var $61=(($hf+36)|0);
   var $62=HEAPF32[(($61)>>2)];
   var $63=($60)*($62);
   var $64=(($chf+44)|0);
   var $65=($55)+($63);
   HEAPF32[(($64)>>2)]=$65;
   var $66=(($hf+32)|0);
   var $67=HEAPF32[(($66)>>2)];
   var $68=(($chf+52)|0);
   HEAPF32[(($68)>>2)]=$67;
   var $69=HEAPF32[(($61)>>2)];
   var $70=(($chf+56)|0);
   HEAPF32[(($70)>>2)]=$69;
   var $71=$11 << 2;
   var $72=(Math.imul($71,$13)|0);
   var $73=_malloc($72);
   var $74=$73;
   var $75=(($chf+60)|0);
   HEAP32[(($75)>>2)]=$74;
   var $76=(($73)|(0))==0;
   if ($76) { label = 13; break; } else { label = 14; break; }
  case 13: 
   var $78=(Math.imul($11,$13)|0);
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4600)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$78,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 59; break;
  case 14: 
   _memset($73, 0, $72);
   var $80=$spanCount_i_0 << 3;
   var $81=_malloc($80);
   var $82=$81;
   var $83=(($chf+64)|0);
   HEAP32[(($83)>>2)]=$82;
   var $84=(($81)|(0))==0;
   if ($84) { label = 15; break; } else { label = 16; break; }
  case 15: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((6048)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$spanCount_i_0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 59; break;
  case 16: 
   _memset($81, 0, $80);
   var $87=_malloc($spanCount_i_0);
   var $88=(($chf+72)|0);
   HEAP32[(($88)>>2)]=$87;
   var $89=(($87)|(0))==0;
   if ($89) { label = 17; break; } else { label = 18; break; }
  case 17: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4824)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$spanCount_i_0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 59; break;
  case 18: 
   _memset($87, 0, $spanCount_i_0);
   var $storemerge = 0;var $idx_0 = 0;label = 19; break;
  case 19: 
   var $idx_0;
   var $storemerge;
   var $93=(($storemerge)|(0)) < (($13)|(0));
   if ($93) { label = 20; break; } else { var $storemerge1 = 0;var $tooHighNeighbour_0 = 0;label = 35; break; }
  case 20: 
   var $94=(Math.imul($storemerge,$11)|0);
   var $storemerge4 = 0;var $idx_1 = $idx_0;label = 21; break;
  case 21: 
   var $idx_1;
   var $storemerge4;
   var $96=(($storemerge4)|(0)) < (($11)|(0));
   if ($96) { label = 22; break; } else { label = 34; break; }
  case 22: 
   var $98=((($storemerge4)+($94))|0);
   var $99=HEAP32[(($14)>>2)];
   var $100=(($99+($98<<2))|0);
   var $101=HEAP32[(($100)>>2)];
   var $102=(($101)|(0))==0;
   if ($102) { var $idx_4 = $idx_1;label = 33; break; } else { label = 23; break; }
  case 23: 
   var $104=HEAP32[(($75)>>2)];
   var $105=(($104+($98<<2))|0);
   var $106=$105;
   var $107=$idx_1 & 16777215;
   HEAP32[(($106)>>2)]=$107;
   var $idx_2 = $idx_1;var $s_0 = $101;label = 24; break;
  case 24: 
   var $s_0;
   var $idx_2;
   var $109=(($s_0)|(0))==0;
   if ($109) { var $idx_4 = $idx_2;label = 33; break; } else { label = 25; break; }
  case 25: 
   var $111=$s_0;
   var $112=HEAP32[(($111)>>2)];
   var $113=(($112)>>>(0)) > 67108863;
   if ($113) { label = 27; break; } else { label = 26; break; }
  case 26: 
   var $_pre=(($s_0+4)|0);
   var $idx_3 = $idx_2;var $_pre_phi = $_pre;label = 32; break;
  case 27: 
   var $115=$112 >>> 13;
   var $116=$115 & 8191;
   var $117=(($s_0+4)|0);
   var $118=HEAP32[(($117)>>2)];
   var $119=(($118)|(0))==0;
   if ($119) { var $124 = 65535;label = 29; break; } else { label = 28; break; }
  case 28: 
   var $121=$118;
   var $122=HEAP32[(($121)>>2)];
   var $123=$122 & 8191;
   var $124 = $123;label = 29; break;
  case 29: 
   var $124;
   var $extract_t7=(($116) & 65535);
   var $125=HEAP32[(($83)>>2)];
   var $126=(($125+($idx_2<<3))|0);
   HEAP16[(($126)>>1)]=$extract_t7;
   var $127=((($124)-($116))|0);
   var $128=(($127)|(0)) < 0;
   if ($128) { var $131 = 0;label = 31; break; } else { label = 30; break; }
  case 30: 
   var $130=(($127)|(0)) > 255;
   var $_op=$127 << 24;
   var $phitmp=$130 ? -16777216 : $_op;
   var $131 = $phitmp;label = 31; break;
  case 31: 
   var $131;
   var $132=HEAP32[(($83)>>2)];
   var $133=(($132+($idx_2<<3)+4)|0);
   var $134=$133;
   var $135=HEAP32[(($134)>>2)];
   var $136=$135 & 16777215;
   var $137=$136 | $131;
   HEAP32[(($134)>>2)]=$137;
   var $138=HEAP32[(($111)>>2)];
   var $139=$138 >>> 26;
   var $140=(($139) & 255);
   var $141=HEAP32[(($88)>>2)];
   var $142=(($141+$idx_2)|0);
   HEAP8[($142)]=$140;
   var $143=((($idx_2)+(1))|0);
   var $144=HEAP32[(($106)>>2)];
   var $145=((($144)+(16777216))|0);
   HEAP32[(($106)>>2)]=$145;
   var $idx_3 = $143;var $_pre_phi = $117;label = 32; break;
  case 32: 
   var $_pre_phi;
   var $idx_3;
   var $147=HEAP32[(($_pre_phi)>>2)];
   var $idx_2 = $idx_3;var $s_0 = $147;label = 24; break;
  case 33: 
   var $idx_4;
   var $148=((($storemerge4)+(1))|0);
   var $storemerge4 = $148;var $idx_1 = $idx_4;label = 21; break;
  case 34: 
   var $150=((($storemerge)+(1))|0);
   var $storemerge = $150;var $idx_0 = $idx_1;label = 19; break;
  case 35: 
   var $tooHighNeighbour_0;
   var $storemerge1;
   var $152=(($storemerge1)|(0)) < (($13)|(0));
   if ($152) { label = 36; break; } else { label = 55; break; }
  case 36: 
   var $153=(Math.imul($storemerge1,$11)|0);
   var $storemerge2 = 0;var $tooHighNeighbour_1 = $tooHighNeighbour_0;label = 37; break;
  case 37: 
   var $tooHighNeighbour_1;
   var $storemerge2;
   var $155=(($storemerge2)|(0)) < (($11)|(0));
   if ($155) { label = 38; break; } else { label = 54; break; }
  case 38: 
   var $157=((($storemerge2)+($153))|0);
   var $158=HEAP32[(($75)>>2)];
   var $159=(($158+($157<<2))|0);
   var $160=$159;
   var $161=HEAP32[(($160)>>2)];
   var $162=$161 & 16777215;
   var $163=$161 >>> 24;
   var $164=((($162)+($163))|0);
   var $tooHighNeighbour_2 = $tooHighNeighbour_1;var $i_0 = $162;label = 39; break;
  case 39: 
   var $i_0;
   var $tooHighNeighbour_2;
   var $166=(($i_0)|(0)) < (($164)|(0));
   if ($166) { label = 40; break; } else { label = 53; break; }
  case 40: 
   var $168=HEAP32[(($83)>>2)];
   var $169=(($168+($i_0<<3)+4)|0);
   var $170=$169;
   var $171=(($168+($i_0<<3))|0);
   var $storemerge3 = 0;var $tooHighNeighbour_3 = $tooHighNeighbour_2;label = 41; break;
  case 41: 
   var $tooHighNeighbour_3;
   var $storemerge3;
   var $173=(($storemerge3)|(0)) < 4;
   if ($173) { label = 42; break; } else { label = 52; break; }
  case 42: 
   var $175=((($storemerge3)*(6))&-1);
   var $176=HEAP32[(($170)>>2)];
   var $177=63 << $175;
   var $178=$177 ^ 16777215;
   var $179=$176 & $178;
   var $180=$179 | $177;
   var $181=$180 & 16777215;
   var $182=$176 & -16777216;
   var $183=$182 | $181;
   HEAP32[(($170)>>2)]=$183;
   var $184=$storemerge3 & 3;
   var $185=((6640+($184<<2))|0);
   var $186=HEAP32[(($185)>>2)];
   var $187=((($storemerge2)+($186))|0);
   var $188=((6624+($184<<2))|0);
   var $189=HEAP32[(($188)>>2)];
   var $190=((($storemerge1)+($189))|0);
   var $191=(($187)|(0)) < 0;
   var $192=(($190)|(0)) < 0;
   var $or_cond=$191 | $192;
   var $or_cond_not=$or_cond ^ 1;
   var $193=(($187)|(0)) < (($11)|(0));
   var $or_cond193=$or_cond_not & $193;
   var $194=(($190)|(0)) < (($13)|(0));
   var $or_cond194=$or_cond193 & $194;
   if ($or_cond194) { label = 43; break; } else { var $tooHighNeighbour_6 = $tooHighNeighbour_3;label = 51; break; }
  case 43: 
   var $196=(Math.imul($190,$11)|0);
   var $197=((($187)+($196))|0);
   var $198=HEAP32[(($75)>>2)];
   var $199=(($198+($197<<2))|0);
   var $200=$199;
   var $201=HEAP32[(($200)>>2)];
   var $202=$201 & 16777215;
   var $203=$201 >>> 24;
   var $204=((($202)+($203))|0);
   var $k_0 = $202;var $tooHighNeighbour_4 = $tooHighNeighbour_3;label = 44; break;
  case 44: 
   var $tooHighNeighbour_4;
   var $k_0;
   var $206=(($k_0)|(0)) < (($204)|(0));
   if ($206) { label = 45; break; } else { var $tooHighNeighbour_6 = $tooHighNeighbour_4;label = 51; break; }
  case 45: 
   var $208=HEAP32[(($83)>>2)];
   var $209=HEAP16[(($171)>>1)];
   var $210=(($208+($k_0<<3))|0);
   var $211=HEAP16[(($210)>>1)];
   var $212=(($209)&(65535)) > (($211)&(65535));
   var $213=$212 ? $209 : $211;
   var $214=(($213)&(65535));
   var $215=(($209)&(65535));
   var $216=$176 >>> 24;
   var $217=((($215)+($216))|0);
   var $218=(($211)&(65535));
   var $219=(($208+($k_0<<3)+4)|0);
   var $220=$219;
   var $221=HEAP32[(($220)>>2)];
   var $222=$221 >>> 24;
   var $223=((($218)+($222))|0);
   var $224=(($217)|(0)) < (($223)|(0));
   var $225=$224 ? $217 : $223;
   var $226=((($225)-($214))|0);
   var $227=(($226)|(0)) < (($walkableHeight)|(0));
   if ($227) { var $tooHighNeighbour_5 = $tooHighNeighbour_4;label = 50; break; } else { label = 46; break; }
  case 46: 
   var $228=((($218)-($215))|0);
   var $229=(($228)|(0)) < 0;
   var $230=(((-$228))|0);
   var $_=$229 ? $230 : $228;
   var $231=(($_)|(0)) > (($walkableClimb)|(0));
   if ($231) { var $tooHighNeighbour_5 = $tooHighNeighbour_4;label = 50; break; } else { label = 47; break; }
  case 47: 
   var $233=((($k_0)-($202))|0);
   var $234=(($233)|(0)) < 0;
   var $235=(($233)|(0)) > 62;
   var $or_cond195=$234 | $235;
   if ($or_cond195) { label = 48; break; } else { label = 49; break; }
  case 48: 
   var $237=(($tooHighNeighbour_4)|(0)) > (($233)|(0));
   var $238=$237 ? $tooHighNeighbour_4 : $233;
   var $tooHighNeighbour_5 = $238;label = 50; break;
  case 49: 
   var $240=$180 & $178;
   var $241=$233 & 63;
   var $242=$241 << $175;
   var $243=$240 | $242;
   var $244=$243 & 16777215;
   var $245=$182 | $244;
   HEAP32[(($170)>>2)]=$245;
   var $tooHighNeighbour_6 = $tooHighNeighbour_4;label = 51; break;
  case 50: 
   var $tooHighNeighbour_5;
   var $247=((($k_0)+(1))|0);
   var $k_0 = $247;var $tooHighNeighbour_4 = $tooHighNeighbour_5;label = 44; break;
  case 51: 
   var $tooHighNeighbour_6;
   var $248=((($storemerge3)+(1))|0);
   var $storemerge3 = $248;var $tooHighNeighbour_3 = $tooHighNeighbour_6;label = 41; break;
  case 52: 
   var $250=((($i_0)+(1))|0);
   var $tooHighNeighbour_2 = $tooHighNeighbour_3;var $i_0 = $250;label = 39; break;
  case 53: 
   var $252=((($storemerge2)+(1))|0);
   var $storemerge2 = $252;var $tooHighNeighbour_1 = $tooHighNeighbour_2;label = 37; break;
  case 54: 
   var $254=((($storemerge1)+(1))|0);
   var $storemerge1 = $254;var $tooHighNeighbour_0 = $tooHighNeighbour_1;label = 35; break;
  case 55: 
   var $256=(($tooHighNeighbour_0)|(0)) > 62;
   if ($256) { label = 56; break; } else { label = 57; break; }
  case 56: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3848)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$tooHighNeighbour_0,HEAP32[(((tempVarArgs)+(8))>>2)]=62,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 57; break;
  case 57: 
   var $259=HEAP8[($1)];
   var $260=$259 & 1;
   var $261=(($260 << 24) >> 24)==0;
   if ($261) { var $_0 = 1;label = 59; break; } else { label = 58; break; }
  case 58: 
   var $263=$ctx;
   var $264=HEAP32[(($263)>>2)];
   var $265=(($264+24)|0);
   var $266=HEAP32[(($265)>>2)];
   FUNCTION_TABLE[$266]($ctx, 3);
   var $_0 = 1;label = 59; break;
  case 59: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10rcIntArray6resizeEi($this, $n) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this+8)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0)) < (($n)|(0));
   if ($3) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $_pre=(($this+4)|0);
   var $_pre_phi = $_pre;label = 12; break;
  case 3: 
   var $5=(($2)|(0))==0;
   if ($5) { label = 4; break; } else { var $7 = $2;label = 5; break; }
  case 4: 
   HEAP32[(($1)>>2)]=$n;
   var $7 = $n;label = 5; break;
  case 5: 
   var $7;
   var $8=(($7)|(0)) < (($n)|(0));
   if ($8) { label = 6; break; } else { label = 7; break; }
  case 6: 
   var $10=$7 << 1;
   HEAP32[(($1)>>2)]=$10;
   var $7 = $10;label = 5; break;
  case 7: 
   var $12=$7 << 2;
   var $13=_malloc($12);
   var $14=$13;
   var $15=(($this+4)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=(($16)|(0))==0;
   var $18=(($13)|(0))==0;
   var $or_cond=$17 | $18;
   if ($or_cond) { label = 9; break; } else { label = 8; break; }
  case 8: 
   var $20=(($this)|0);
   var $21=HEAP32[(($20)>>2)];
   var $22=$21;
   var $23=$16 << 2;
   assert($23 % 1 === 0);(_memcpy($13, $22, $23)|0);
   label = 9; break;
  case 9: 
   var $25=(($this)|0);
   var $26=HEAP32[(($25)>>2)];
   var $27=(($26)|(0))==0;
   if ($27) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $29=$26;
   _free($29);
   label = 11; break;
  case 11: 
   HEAP32[(($25)>>2)]=$14;
   var $_pre_phi = $15;label = 12; break;
  case 12: 
   var $_pre_phi;
   HEAP32[(($_pre_phi)>>2)]=$n;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z19rcErodeWalkableAreaP9rcContextiR20rcCompactHeightfield($ctx, $radius, $chf) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($chf)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($chf+4)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($ctx+5)|0);
   var $6=HEAP8[($5)];
   var $7=$6 & 1;
   var $8=(($7 << 24) >> 24)==0;
   if ($8) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $10=$ctx;
   var $11=HEAP32[(($10)>>2)];
   var $12=(($11+20)|0);
   var $13=HEAP32[(($12)>>2)];
   FUNCTION_TABLE[$13]($ctx, 13);
   label = 3; break;
  case 3: 
   var $14=(($chf+8)|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=_malloc($15);
   var $17=(($16)|(0))==0;
   var $18=HEAP32[(($14)>>2)];
   if ($17) { label = 4; break; } else { label = 5; break; }
  case 4: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4464)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$18,tempVarArgs)); STACKTOP=tempVarArgs;
   var $storemerge4 = 0;label = 69; break;
  case 5: 
   _memset($16, -1, $18);
   var $21=(($chf+60)|0);
   var $22=(($chf+72)|0);
   var $23=(($chf+64)|0);
   var $storemerge = 0;label = 6; break;
  case 6: 
   var $storemerge;
   var $25=(($storemerge)|(0)) < (($4)|(0));
   if ($25) { label = 7; break; } else { var $storemerge1 = 0;label = 23; break; }
  case 7: 
   var $26=(Math.imul($storemerge,$2)|0);
   var $storemerge7 = 0;label = 8; break;
  case 8: 
   var $storemerge7;
   var $28=(($storemerge7)|(0)) < (($2)|(0));
   if ($28) { label = 9; break; } else { label = 22; break; }
  case 9: 
   var $30=((($storemerge7)+($26))|0);
   var $31=HEAP32[(($21)>>2)];
   var $32=(($31+($30<<2))|0);
   var $33=$32;
   var $34=HEAP32[(($33)>>2)];
   var $35=$34 & 16777215;
   var $36=$34 >>> 24;
   var $37=((($35)+($36))|0);
   var $i_0 = $35;label = 10; break;
  case 10: 
   var $i_0;
   var $39=(($i_0)|(0)) < (($37)|(0));
   if ($39) { label = 11; break; } else { label = 21; break; }
  case 11: 
   var $41=HEAP32[(($22)>>2)];
   var $42=(($41+$i_0)|0);
   var $43=HEAP8[($42)];
   var $44=(($43 << 24) >> 24)==0;
   if ($44) { label = 12; break; } else { label = 13; break; }
  case 12: 
   var $46=(($16+$i_0)|0);
   HEAP8[($46)]=0;
   label = 20; break;
  case 13: 
   var $48=HEAP32[(($23)>>2)];
   var $49=(($48+($i_0<<3)+4)|0);
   var $50=$49;
   var $storemerge8 = 0;var $nc_0 = 0;label = 14; break;
  case 14: 
   var $nc_0;
   var $storemerge8;
   var $52=(($storemerge8)|(0)) < 4;
   if ($52) { label = 15; break; } else { label = 18; break; }
  case 15: 
   var $54=((($storemerge8)*(6))&-1);
   var $55=HEAP32[(($50)>>2)];
   var $56=$55 & 16777215;
   var $57=$56 >>> (($54)>>>(0));
   var $58=$57 & 63;
   var $59=(($58)|(0))==63;
   if ($59) { var $nc_1 = $nc_0;label = 17; break; } else { label = 16; break; }
  case 16: 
   var $61=$storemerge8 & 3;
   var $62=((6640+($61<<2))|0);
   var $63=HEAP32[(($62)>>2)];
   var $64=((($storemerge7)+($63))|0);
   var $65=((6624+($61<<2))|0);
   var $66=HEAP32[(($65)>>2)];
   var $67=((($storemerge)+($66))|0);
   var $68=(Math.imul($67,$2)|0);
   var $69=((($64)+($68))|0);
   var $70=HEAP32[(($21)>>2)];
   var $71=(($70+($69<<2))|0);
   var $72=$71;
   var $73=HEAP32[(($72)>>2)];
   var $74=$73 & 16777215;
   var $75=((($74)+($58))|0);
   var $76=(($41+$75)|0);
   var $77=HEAP8[($76)];
   var $78=(($77 << 24) >> 24)==0;
   var $79=((($nc_0)+(1))|0);
   var $nc_0_=$78 ? $nc_0 : $79;
   var $nc_1 = $nc_0_;label = 17; break;
  case 17: 
   var $nc_1;
   var $81=((($storemerge8)+(1))|0);
   var $storemerge8 = $81;var $nc_0 = $nc_1;label = 14; break;
  case 18: 
   var $83=(($nc_0)|(0))==4;
   if ($83) { label = 20; break; } else { label = 19; break; }
  case 19: 
   var $85=(($16+$i_0)|0);
   HEAP8[($85)]=0;
   label = 20; break;
  case 20: 
   var $87=((($i_0)+(1))|0);
   var $i_0 = $87;label = 10; break;
  case 21: 
   var $89=((($storemerge7)+(1))|0);
   var $storemerge7 = $89;label = 8; break;
  case 22: 
   var $91=((($storemerge)+(1))|0);
   var $storemerge = $91;label = 6; break;
  case 23: 
   var $storemerge1;
   var $92=(($storemerge1)|(0)) < (($4)|(0));
   if ($92) { label = 24; break; } else { var $storemerge2_in = $4;label = 43; break; }
  case 24: 
   var $93=(Math.imul($storemerge1,$2)|0);
   var $94=((($storemerge1)-(1))|0);
   var $95=(Math.imul($94,$2)|0);
   var $storemerge6 = 0;label = 25; break;
  case 25: 
   var $storemerge6;
   var $97=(($storemerge6)|(0)) < (($2)|(0));
   if ($97) { label = 26; break; } else { label = 42; break; }
  case 26: 
   var $99=((($storemerge6)+($93))|0);
   var $100=HEAP32[(($21)>>2)];
   var $101=(($100+($99<<2))|0);
   var $102=$101;
   var $103=HEAP32[(($102)>>2)];
   var $104=$103 & 16777215;
   var $105=$103 >>> 24;
   var $106=((($104)+($105))|0);
   var $107=((($storemerge6)+($95))|0);
   var $108=((($storemerge6)+(1))|0);
   var $109=((($108)+($95))|0);
   var $110=((($storemerge6)-(1))|0);
   var $111=((($110)+($93))|0);
   var $112=((($110)+($95))|0);
   var $i4_0 = $104;label = 27; break;
  case 27: 
   var $i4_0;
   var $114=(($i4_0)|(0)) < (($106)|(0));
   if ($114) { label = 28; break; } else { var $storemerge6 = $108;label = 25; break; }
  case 28: 
   var $116=HEAP32[(($23)>>2)];
   var $117=(($116+($i4_0<<3)+4)|0);
   var $118=$117;
   var $119=HEAP32[(($118)>>2)];
   var $120=$119 & 63;
   var $121=(($120)|(0))==63;
   if ($121) { label = 29; break; } else { label = 30; break; }
  case 29: 
   var $_pre=(($116+($i4_0<<3)+4)|0);
   var $_pre161=$_pre;
   var $_pre_phi162 = $_pre161;label = 35; break;
  case 30: 
   var $123=HEAP32[(($21)>>2)];
   var $124=(($123+($111<<2))|0);
   var $125=$124;
   var $126=HEAP32[(($125)>>2)];
   var $127=$126 & 16777215;
   var $128=(($116+($i4_0<<3)+4)|0);
   var $129=$128;
   var $130=((($127)+($120))|0);
   var $131=(($16+$130)|0);
   var $132=HEAP8[($131)];
   var $133=(($132)&(255));
   var $134=((($133)+(2))|0);
   var $135=(($134)>>>(0)) < 255;
   var $136=$135 ? $134 : 255;
   var $137=(($136) & 255);
   var $138=$136 & 255;
   var $139=(($16+$i4_0)|0);
   var $140=HEAP8[($139)];
   var $141=(($140)&(255));
   var $142=(($138)>>>(0)) < (($141)>>>(0));
   if ($142) { label = 31; break; } else { var $145 = $140;label = 32; break; }
  case 31: 
   HEAP8[($139)]=$137;
   var $145 = $137;label = 32; break;
  case 32: 
   var $145;
   var $146=(($116+($130<<3)+4)|0);
   var $147=$146;
   var $148=HEAP32[(($147)>>2)];
   var $149=$148 & 16515072;
   var $150=(($149)|(0))==16515072;
   if ($150) { var $_pre_phi162 = $129;label = 35; break; } else { label = 33; break; }
  case 33: 
   var $152=HEAP32[(($21)>>2)];
   var $153=(($152+($112<<2))|0);
   var $154=$153;
   var $155=HEAP32[(($154)>>2)];
   var $156=$155 & 16777215;
   var $157=$148 >>> 18;
   var $158=$157 & 63;
   var $159=((($156)+($158))|0);
   var $160=(($16+$159)|0);
   var $161=HEAP8[($160)];
   var $162=(($161)&(255));
   var $163=((($162)+(3))|0);
   var $164=(($163)>>>(0)) < 255;
   var $165=$164 ? $163 : 255;
   var $166=$165 & 255;
   var $167=(($145)&(255));
   var $168=(($166)>>>(0)) < (($167)>>>(0));
   if ($168) { label = 34; break; } else { var $_pre_phi162 = $129;label = 35; break; }
  case 34: 
   var $170=(($165) & 255);
   HEAP8[($139)]=$170;
   var $_pre_phi162 = $129;label = 35; break;
  case 35: 
   var $_pre_phi162;
   var $171=HEAP32[(($_pre_phi162)>>2)];
   var $172=$171 & 16515072;
   var $173=(($172)|(0))==16515072;
   if ($173) { label = 41; break; } else { label = 36; break; }
  case 36: 
   var $175=HEAP32[(($21)>>2)];
   var $176=(($175+($107<<2))|0);
   var $177=$176;
   var $178=HEAP32[(($177)>>2)];
   var $179=$178 & 16777215;
   var $180=$171 >>> 18;
   var $181=$180 & 63;
   var $182=((($179)+($181))|0);
   var $183=HEAP32[(($23)>>2)];
   var $184=(($16+$182)|0);
   var $185=HEAP8[($184)];
   var $186=(($185)&(255));
   var $187=((($186)+(2))|0);
   var $188=(($187)>>>(0)) < 255;
   var $189=$188 ? $187 : 255;
   var $190=(($189) & 255);
   var $191=$189 & 255;
   var $192=(($16+$i4_0)|0);
   var $193=HEAP8[($192)];
   var $194=(($193)&(255));
   var $195=(($191)>>>(0)) < (($194)>>>(0));
   if ($195) { label = 37; break; } else { var $198 = $193;label = 38; break; }
  case 37: 
   HEAP8[($192)]=$190;
   var $198 = $190;label = 38; break;
  case 38: 
   var $198;
   var $199=(($183+($182<<3)+4)|0);
   var $200=$199;
   var $201=HEAP32[(($200)>>2)];
   var $202=$201 & 258048;
   var $203=(($202)|(0))==258048;
   if ($203) { label = 41; break; } else { label = 39; break; }
  case 39: 
   var $205=HEAP32[(($21)>>2)];
   var $206=(($205+($109<<2))|0);
   var $207=$206;
   var $208=HEAP32[(($207)>>2)];
   var $209=$208 & 16777215;
   var $210=$201 >>> 12;
   var $211=$210 & 63;
   var $212=((($209)+($211))|0);
   var $213=(($16+$212)|0);
   var $214=HEAP8[($213)];
   var $215=(($214)&(255));
   var $216=((($215)+(3))|0);
   var $217=(($216)>>>(0)) < 255;
   var $218=$217 ? $216 : 255;
   var $219=$218 & 255;
   var $220=(($198)&(255));
   var $221=(($219)>>>(0)) < (($220)>>>(0));
   if ($221) { label = 40; break; } else { label = 41; break; }
  case 40: 
   var $223=(($218) & 255);
   HEAP8[($192)]=$223;
   label = 41; break;
  case 41: 
   var $225=((($i4_0)+(1))|0);
   var $i4_0 = $225;label = 27; break;
  case 42: 
   var $227=((($storemerge1)+(1))|0);
   var $storemerge1 = $227;label = 23; break;
  case 43: 
   var $storemerge2_in;
   var $storemerge2=((($storemerge2_in)-(1))|0);
   var $229=(($storemerge2_in)|(0)) > 0;
   if ($229) { label = 44; break; } else { label = 62; break; }
  case 44: 
   var $231=(Math.imul($storemerge2,$2)|0);
   var $232=(Math.imul($storemerge2_in,$2)|0);
   var $storemerge5_in = $2;label = 45; break;
  case 45: 
   var $storemerge5_in;
   var $storemerge5=((($storemerge5_in)-(1))|0);
   var $234=(($storemerge5_in)|(0)) > 0;
   if ($234) { label = 46; break; } else { var $storemerge2_in = $storemerge2;label = 43; break; }
  case 46: 
   var $236=((($storemerge5)+($231))|0);
   var $237=HEAP32[(($21)>>2)];
   var $238=(($237+($236<<2))|0);
   var $239=$238;
   var $240=HEAP32[(($239)>>2)];
   var $241=$240 & 16777215;
   var $242=$240 >>> 24;
   var $243=((($241)+($242))|0);
   var $244=((($storemerge5)+($232))|0);
   var $245=((($storemerge5_in)-(2))|0);
   var $246=((($245)+($232))|0);
   var $247=((($storemerge5_in)+($231))|0);
   var $248=((($storemerge5_in)+($232))|0);
   var $i17_0 = $241;label = 47; break;
  case 47: 
   var $i17_0;
   var $250=(($i17_0)|(0)) < (($243)|(0));
   if ($250) { label = 48; break; } else { var $storemerge5_in = $storemerge5;label = 45; break; }
  case 48: 
   var $252=HEAP32[(($23)>>2)];
   var $253=(($252+($i17_0<<3)+4)|0);
   var $254=$253;
   var $255=HEAP32[(($254)>>2)];
   var $256=$255 & 258048;
   var $257=(($256)|(0))==258048;
   if ($257) { label = 49; break; } else { label = 50; break; }
  case 49: 
   var $_pre163=(($252+($i17_0<<3)+4)|0);
   var $_pre165=$_pre163;
   var $_pre_phi166 = $_pre165;label = 55; break;
  case 50: 
   var $259=HEAP32[(($21)>>2)];
   var $260=(($259+($247<<2))|0);
   var $261=$260;
   var $262=HEAP32[(($261)>>2)];
   var $263=$262 & 16777215;
   var $264=(($252+($i17_0<<3)+4)|0);
   var $265=$264;
   var $266=$255 >>> 12;
   var $267=$266 & 63;
   var $268=((($263)+($267))|0);
   var $269=(($16+$268)|0);
   var $270=HEAP8[($269)];
   var $271=(($270)&(255));
   var $272=((($271)+(2))|0);
   var $273=(($272)>>>(0)) < 255;
   var $274=$273 ? $272 : 255;
   var $275=(($274) & 255);
   var $276=$274 & 255;
   var $277=(($16+$i17_0)|0);
   var $278=HEAP8[($277)];
   var $279=(($278)&(255));
   var $280=(($276)>>>(0)) < (($279)>>>(0));
   if ($280) { label = 51; break; } else { var $283 = $278;label = 52; break; }
  case 51: 
   HEAP8[($277)]=$275;
   var $283 = $275;label = 52; break;
  case 52: 
   var $283;
   var $284=(($252+($268<<3)+4)|0);
   var $285=$284;
   var $286=HEAP32[(($285)>>2)];
   var $287=$286 & 4032;
   var $288=(($287)|(0))==4032;
   if ($288) { var $_pre_phi166 = $265;label = 55; break; } else { label = 53; break; }
  case 53: 
   var $290=HEAP32[(($21)>>2)];
   var $291=(($290+($248<<2))|0);
   var $292=$291;
   var $293=HEAP32[(($292)>>2)];
   var $294=$293 & 16777215;
   var $295=$286 >>> 6;
   var $296=$295 & 63;
   var $297=((($294)+($296))|0);
   var $298=(($16+$297)|0);
   var $299=HEAP8[($298)];
   var $300=(($299)&(255));
   var $301=((($300)+(3))|0);
   var $302=(($301)>>>(0)) < 255;
   var $303=$302 ? $301 : 255;
   var $304=$303 & 255;
   var $305=(($283)&(255));
   var $306=(($304)>>>(0)) < (($305)>>>(0));
   if ($306) { label = 54; break; } else { var $_pre_phi166 = $265;label = 55; break; }
  case 54: 
   var $308=(($303) & 255);
   HEAP8[($277)]=$308;
   var $_pre_phi166 = $265;label = 55; break;
  case 55: 
   var $_pre_phi166;
   var $309=HEAP32[(($_pre_phi166)>>2)];
   var $310=$309 & 4032;
   var $311=(($310)|(0))==4032;
   if ($311) { label = 61; break; } else { label = 56; break; }
  case 56: 
   var $313=HEAP32[(($21)>>2)];
   var $314=(($313+($244<<2))|0);
   var $315=$314;
   var $316=HEAP32[(($315)>>2)];
   var $317=$316 & 16777215;
   var $318=$309 >>> 6;
   var $319=$318 & 63;
   var $320=((($317)+($319))|0);
   var $321=HEAP32[(($23)>>2)];
   var $322=(($16+$320)|0);
   var $323=HEAP8[($322)];
   var $324=(($323)&(255));
   var $325=((($324)+(2))|0);
   var $326=(($325)>>>(0)) < 255;
   var $327=$326 ? $325 : 255;
   var $328=(($327) & 255);
   var $329=$327 & 255;
   var $330=(($16+$i17_0)|0);
   var $331=HEAP8[($330)];
   var $332=(($331)&(255));
   var $333=(($329)>>>(0)) < (($332)>>>(0));
   if ($333) { label = 57; break; } else { var $336 = $331;label = 58; break; }
  case 57: 
   HEAP8[($330)]=$328;
   var $336 = $328;label = 58; break;
  case 58: 
   var $336;
   var $337=(($321+($320<<3)+4)|0);
   var $338=$337;
   var $339=HEAP32[(($338)>>2)];
   var $340=$339 & 63;
   var $341=(($340)|(0))==63;
   if ($341) { label = 61; break; } else { label = 59; break; }
  case 59: 
   var $343=HEAP32[(($21)>>2)];
   var $344=(($343+($246<<2))|0);
   var $345=$344;
   var $346=HEAP32[(($345)>>2)];
   var $347=$346 & 16777215;
   var $348=((($347)+($340))|0);
   var $349=(($16+$348)|0);
   var $350=HEAP8[($349)];
   var $351=(($350)&(255));
   var $352=((($351)+(3))|0);
   var $353=(($352)>>>(0)) < 255;
   var $354=$353 ? $352 : 255;
   var $355=$354 & 255;
   var $356=(($336)&(255));
   var $357=(($355)>>>(0)) < (($356)>>>(0));
   if ($357) { label = 60; break; } else { label = 61; break; }
  case 60: 
   var $359=(($354) & 255);
   HEAP8[($330)]=$359;
   label = 61; break;
  case 61: 
   var $361=((($i17_0)+(1))|0);
   var $i17_0 = $361;label = 47; break;
  case 62: 
   var $363=$radius << 1;
   var $364=(($363) & 255);
   var $storemerge3 = 0;label = 63; break;
  case 63: 
   var $storemerge3;
   var $366=HEAP32[(($14)>>2)];
   var $367=(($storemerge3)|(0)) < (($366)|(0));
   if ($367) { label = 64; break; } else { label = 67; break; }
  case 64: 
   var $369=(($16+$storemerge3)|0);
   var $370=HEAP8[($369)];
   var $371=(($370)&(255)) < (($364)&(255));
   if ($371) { label = 65; break; } else { label = 66; break; }
  case 65: 
   var $373=HEAP32[(($22)>>2)];
   var $374=(($373+$storemerge3)|0);
   HEAP8[($374)]=0;
   label = 66; break;
  case 66: 
   var $376=((($storemerge3)+(1))|0);
   var $storemerge3 = $376;label = 63; break;
  case 67: 
   _free($16);
   var $377=HEAP8[($5)];
   var $378=$377 & 1;
   var $379=(($378 << 24) >> 24)==0;
   if ($379) { var $storemerge4 = 1;label = 69; break; } else { label = 68; break; }
  case 68: 
   var $381=$ctx;
   var $382=HEAP32[(($381)>>2)];
   var $383=(($382+24)|0);
   var $384=HEAP32[(($383)>>2)];
   FUNCTION_TABLE[$384]($ctx, 13);
   var $storemerge4 = 1;label = 69; break;
  case 69: 
   var $storemerge4;
   STACKTOP = sp;
   return $storemerge4;
  default: assert(0, "bad label: " + label);
 }
}
function __Z20rcMarkConvexPolyAreaP9rcContextPKfiffhR20rcCompactHeightfield($ctx, $verts, $nverts, $hmin, $hmax, $areaId, $chf) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 16);
   label = 3; break;
  case 3: 
   var $10=HEAPF32[(($verts)>>2)];
   var $11=(($verts+4)|0);
   var $12=HEAPF32[(($11)>>2)];
   var $13=(($verts+8)|0);
   var $14=HEAPF32[(($13)>>2)];
   var $storemerge = 1;var $bmin_sroa_2_0 = $14;var $bmin_sroa_1_0 = $12;var $bmin_sroa_0_0 = $10;var $bmax_sroa_0_0 = $10;var $bmax_sroa_1_0 = $12;var $bmax_sroa_2_0 = $14;label = 4; break;
  case 4: 
   var $bmax_sroa_2_0;
   var $bmax_sroa_1_0;
   var $bmax_sroa_0_0;
   var $bmin_sroa_0_0;
   var $bmin_sroa_1_0;
   var $bmin_sroa_2_0;
   var $storemerge;
   var $16=(($storemerge)|(0)) < (($nverts)|(0));
   if ($16) { label = 5; break; } else { label = 6; break; }
  case 5: 
   var $18=((($storemerge)*(3))&-1);
   var $19=(($verts+($18<<2))|0);
   var $20=HEAPF32[(($19)>>2)];
   var $21=$bmin_sroa_0_0 < $20;
   var $22=$21 ? $bmin_sroa_0_0 : $20;
   var $_sum121=((($18)+(1))|0);
   var $23=(($verts+($_sum121<<2))|0);
   var $24=HEAPF32[(($23)>>2)];
   var $25=$bmin_sroa_1_0 < $24;
   var $26=$25 ? $bmin_sroa_1_0 : $24;
   var $_sum122=((($18)+(2))|0);
   var $27=(($verts+($_sum122<<2))|0);
   var $28=HEAPF32[(($27)>>2)];
   var $29=$bmin_sroa_2_0 < $28;
   var $30=$29 ? $bmin_sroa_2_0 : $28;
   var $31=$bmax_sroa_0_0 > $20;
   var $32=$31 ? $bmax_sroa_0_0 : $20;
   var $33=$bmax_sroa_1_0 > $24;
   var $34=$33 ? $bmax_sroa_1_0 : $24;
   var $35=$bmax_sroa_2_0 > $28;
   var $36=$35 ? $bmax_sroa_2_0 : $28;
   var $37=((($storemerge)+(1))|0);
   var $storemerge = $37;var $bmin_sroa_2_0 = $30;var $bmin_sroa_1_0 = $26;var $bmin_sroa_0_0 = $22;var $bmax_sroa_0_0 = $32;var $bmax_sroa_1_0 = $34;var $bmax_sroa_2_0 = $36;label = 4; break;
  case 6: 
   var $39=(($chf+28)|0);
   var $40=HEAPF32[(($39)>>2)];
   var $41=($bmin_sroa_0_0)-($40);
   var $42=(($chf+52)|0);
   var $43=HEAPF32[(($42)>>2)];
   var $44=($41)/($43);
   var $45=(($44)&-1);
   var $46=(($chf+32)|0);
   var $47=HEAPF32[(($46)>>2)];
   var $48=($hmin)-($47);
   var $49=(($chf+56)|0);
   var $50=HEAPF32[(($49)>>2)];
   var $51=($48)/($50);
   var $52=(($51)&-1);
   var $53=(($chf+36)|0);
   var $54=HEAPF32[(($53)>>2)];
   var $55=($bmin_sroa_2_0)-($54);
   var $56=($55)/($43);
   var $57=(($56)&-1);
   var $58=($bmax_sroa_0_0)-($40);
   var $59=($58)/($43);
   var $60=(($59)&-1);
   var $61=($hmax)-($47);
   var $62=($61)/($50);
   var $63=(($62)&-1);
   var $64=($bmax_sroa_2_0)-($54);
   var $65=($64)/($43);
   var $66=(($65)&-1);
   var $67=(($60)|(0)) < 0;
   if ($67) { label = 30; break; } else { label = 7; break; }
  case 7: 
   var $69=(($chf)|0);
   var $70=HEAP32[(($69)>>2)];
   var $71=(($45)|(0)) >= (($70)|(0));
   var $72=(($66)|(0)) < 0;
   var $or_cond=$71 | $72;
   if ($or_cond) { label = 30; break; } else { label = 8; break; }
  case 8: 
   var $74=(($chf+4)|0);
   var $75=HEAP32[(($74)>>2)];
   var $76=(($57)|(0)) < (($75)|(0));
   if ($76) { label = 9; break; } else { label = 30; break; }
  case 9: 
   var $78=(($45)|(0)) < 0;
   var $_=$78 ? 0 : $45;
   var $79=(($60)|(0)) < (($70)|(0));
   var $80=((($70)-(1))|0);
   var $maxx_0=$79 ? $60 : $80;
   var $81=(($57)|(0)) < 0;
   var $_123=$81 ? 0 : $57;
   var $82=(($66)|(0)) < (($75)|(0));
   var $83=((($75)-(1))|0);
   var $maxz_0=$82 ? $66 : $83;
   var $84=(($chf+60)|0);
   var $85=(($chf+64)|0);
   var $86=(($chf+72)|0);
   var $87=((($nverts)-(1))|0);
   var $storemerge1 = $_123;label = 10; break;
  case 10: 
   var $storemerge1;
   var $89=(($storemerge1)|(0)) > (($maxz_0)|(0));
   if ($89) { label = 28; break; } else { label = 11; break; }
  case 11: 
   var $91=(($storemerge1)|(0));
   var $92=($91)+(0.5);
   var $storemerge2 = $_;label = 12; break;
  case 12: 
   var $storemerge2;
   var $94=(($storemerge2)|(0)) > (($maxx_0)|(0));
   if ($94) { label = 27; break; } else { label = 13; break; }
  case 13: 
   var $96=HEAP32[(($69)>>2)];
   var $97=(Math.imul($storemerge1,$96)|0);
   var $98=((($storemerge2)+($97))|0);
   var $99=HEAP32[(($84)>>2)];
   var $100=(($99+($98<<2))|0);
   var $101=$100;
   var $102=HEAP32[(($101)>>2)];
   var $103=$102 & 16777215;
   var $104=$102 >>> 24;
   var $105=((($103)+($104))|0);
   var $106=(($storemerge2)|(0));
   var $107=($106)+(0.5);
   var $i1_0 = $103;label = 14; break;
  case 14: 
   var $i1_0;
   var $109=(($i1_0)|(0)) < (($105)|(0));
   if ($109) { label = 15; break; } else { label = 26; break; }
  case 15: 
   var $111=HEAP32[(($86)>>2)];
   var $112=(($111+$i1_0)|0);
   var $113=HEAP8[($112)];
   var $114=(($113 << 24) >> 24)==0;
   if ($114) { label = 25; break; } else { label = 16; break; }
  case 16: 
   var $116=HEAP32[(($85)>>2)];
   var $117=(($116+($i1_0<<3))|0);
   var $118=HEAP16[(($117)>>1)];
   var $119=(($118)&(65535));
   var $120=(($119)|(0)) < (($52)|(0));
   var $121=(($119)|(0)) > (($63)|(0));
   var $or_cond124=$120 | $121;
   if ($or_cond124) { label = 25; break; } else { label = 17; break; }
  case 17: 
   var $123=HEAPF32[(($39)>>2)];
   var $124=HEAPF32[(($42)>>2)];
   var $125=($107)*($124);
   var $126=($123)+($125);
   var $127=HEAPF32[(($53)>>2)];
   var $128=($92)*($124);
   var $129=($127)+($128);
   var $storemerge_i = $87;var $i_i_0 = 0;var $c_i_0 = 0;label = 18; break;
  case 18: 
   var $c_i_0;
   var $i_i_0;
   var $storemerge_i;
   var $131=(($i_i_0)|(0)) < (($nverts)|(0));
   if ($131) { label = 19; break; } else { label = 23; break; }
  case 19: 
   var $133=((($i_i_0)*(3))&-1);
   var $134=((($storemerge_i)*(3))&-1);
   var $_sum_i=((($133)+(2))|0);
   var $135=(($verts+($_sum_i<<2))|0);
   var $136=HEAPF32[(($135)>>2)];
   var $137=$136 > $129;
   var $_sum=((($134)+(2))|0);
   var $138=(($verts+($_sum<<2))|0);
   var $139=HEAPF32[(($138)>>2)];
   var $140=$139 > $129;
   var $141=$137 ^ $140;
   if ($141) { label = 20; break; } else { var $c_i_1 = $c_i_0;label = 22; break; }
  case 20: 
   var $143=(($verts+($134<<2))|0);
   var $144=(($verts+($133<<2))|0);
   var $145=HEAPF32[(($143)>>2)];
   var $146=HEAPF32[(($144)>>2)];
   var $147=($145)-($146);
   var $148=($129)-($136);
   var $149=($147)*($148);
   var $150=($139)-($136);
   var $151=($149)/($150);
   var $152=($151)+($146);
   var $153=$126 < $152;
   if ($153) { label = 21; break; } else { var $c_i_1 = $c_i_0;label = 22; break; }
  case 21: 
   var $155=(($c_i_0)|(0))==0;
   var $156=(($155)&(1));
   var $c_i_1 = $156;label = 22; break;
  case 22: 
   var $c_i_1;
   var $158=((($i_i_0)+(1))|0);
   var $storemerge_i = $i_i_0;var $i_i_0 = $158;var $c_i_0 = $c_i_1;label = 18; break;
  case 23: 
   var $159=(($c_i_0)|(0))==0;
   if ($159) { label = 25; break; } else { label = 24; break; }
  case 24: 
   HEAP8[($112)]=$areaId;
   label = 25; break;
  case 25: 
   var $162=((($i1_0)+(1))|0);
   var $i1_0 = $162;label = 14; break;
  case 26: 
   var $164=((($storemerge2)+(1))|0);
   var $storemerge2 = $164;label = 12; break;
  case 27: 
   var $166=((($storemerge1)+(1))|0);
   var $storemerge1 = $166;label = 10; break;
  case 28: 
   var $168=HEAP8[($1)];
   var $169=$168 & 1;
   var $170=(($169 << 24) >> 24)==0;
   if ($170) { label = 30; break; } else { label = 29; break; }
  case 29: 
   var $172=$ctx;
   var $173=HEAP32[(($172)>>2)];
   var $174=(($173+24)|0);
   var $175=HEAP32[(($174)>>2)];
   FUNCTION_TABLE[$175]($ctx, 16);
   label = 30; break;
  case 30: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z15rcBuildContoursP9rcContextR20rcCompactHeightfieldfiR12rcContourSeti($ctx, $chf, $maxError, $maxEdgeLen, $cset) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 48)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $regs_i_i=sp;
   var $verts=(sp)+(16);
   var $simplified=(sp)+(32);
   var $1=(($chf)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($chf+4)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($chf+20)|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=(($ctx+5)|0);
   var $8=HEAP8[($7)];
   var $9=$8 & 1;
   var $10=(($9 << 24) >> 24)==0;
   if ($10) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $12=$ctx;
   var $13=HEAP32[(($12)>>2)];
   var $14=(($13+20)|0);
   var $15=HEAP32[(($14)>>2)];
   FUNCTION_TABLE[$15]($ctx, 4);
   label = 3; break;
  case 3: 
   var $16=(($cset+8)|0);
   var $17=(($chf+28)|0);
   var $18=HEAPF32[(($17)>>2)];
   HEAPF32[(($16)>>2)]=$18;
   var $19=(($chf+32)|0);
   var $20=HEAPF32[(($19)>>2)];
   var $21=(($cset+12)|0);
   HEAPF32[(($21)>>2)]=$20;
   var $22=(($chf+36)|0);
   var $23=HEAPF32[(($22)>>2)];
   var $24=(($cset+16)|0);
   HEAPF32[(($24)>>2)]=$23;
   var $25=(($cset+20)|0);
   var $26=(($chf+40)|0);
   var $27=HEAPF32[(($26)>>2)];
   HEAPF32[(($25)>>2)]=$27;
   var $28=(($chf+44)|0);
   var $29=HEAPF32[(($28)>>2)];
   var $30=(($cset+24)|0);
   HEAPF32[(($30)>>2)]=$29;
   var $31=(($chf+48)|0);
   var $32=HEAPF32[(($31)>>2)];
   var $33=(($cset+28)|0);
   HEAPF32[(($33)>>2)]=$32;
   var $34=(($6)|(0)) > 0;
   if ($34) { label = 5; break; } else { label = 4; break; }
  case 4: 
   var $_pre1037=(($chf+52)|0);
   var $_pre_phi = $_pre1037;label = 6; break;
  case 5: 
   var $36=(($6)|(0));
   var $37=(($chf+52)|0);
   var $38=HEAPF32[(($37)>>2)];
   var $39=($36)*($38);
   var $40=($18)+($39);
   HEAPF32[(($16)>>2)]=$40;
   var $41=(($cset+16)|0);
   var $42=($23)+($39);
   HEAPF32[(($41)>>2)]=$42;
   var $43=($27)-($39);
   HEAPF32[(($25)>>2)]=$43;
   var $44=(($cset+28)|0);
   var $45=($32)-($39);
   HEAPF32[(($44)>>2)]=$45;
   var $_pre_phi = $37;label = 6; break;
  case 6: 
   var $_pre_phi;
   var $47=HEAPF32[(($_pre_phi)>>2)];
   var $48=(($cset+32)|0);
   HEAPF32[(($48)>>2)]=$47;
   var $49=(($chf+56)|0);
   var $50=HEAPF32[(($49)>>2)];
   var $51=(($cset+36)|0);
   HEAPF32[(($51)>>2)]=$50;
   var $52=HEAP32[(($1)>>2)];
   var $53=HEAP32[(($5)>>2)];
   var $54=$53 << 1;
   var $55=((($52)-($54))|0);
   var $56=(($cset+40)|0);
   HEAP32[(($56)>>2)]=$55;
   var $57=HEAP32[(($3)>>2)];
   var $58=HEAP32[(($5)>>2)];
   var $59=$58 << 1;
   var $60=((($57)-($59))|0);
   var $61=(($cset+44)|0);
   HEAP32[(($61)>>2)]=$60;
   var $62=HEAP32[(($5)>>2)];
   var $63=(($cset+48)|0);
   HEAP32[(($63)>>2)]=$62;
   var $64=(($chf+26)|0);
   var $65=HEAP16[(($64)>>1)];
   var $66=(($65)&(65535));
   var $67=(($66)>>>(0)) > 8;
   var $68=$67 ? $66 : 8;
   var $69=((($68)*(20))&-1);
   var $70=_malloc($69);
   var $71=$70;
   var $72=(($cset)|0);
   HEAP32[(($72)>>2)]=$71;
   var $73=(($70)|(0))==0;
   if ($73) { var $_2 = 0;label = 225; break; } else { label = 7; break; }
  case 7: 
   var $75=(($cset+4)|0);
   HEAP32[(($75)>>2)]=0;
   var $76=(($chf+8)|0);
   var $77=HEAP32[(($76)>>2)];
   var $78=_malloc($77);
   var $79=(($78)|(0))==0;
   if ($79) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $81=HEAP32[(($76)>>2)];
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4416)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$81,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_2 = 0;label = 225; break; } else { label = 9; break; }
  case 9: 
   var $83$0 = ___cxa_find_matching_catch(-1, -1); $83$1 = tempRet0;
   var $84=$83$0;
   var $85=$83$1;
   var $_0992 = $85;var $_0993 = $84;label = 223; break;
  case 10: 
   var $87=HEAP8[($7)];
   var $88=$87 & 1;
   var $89=(($88 << 24) >> 24)==0;
   if ($89) { label = 12; break; } else { label = 11; break; }
  case 11: 
   var $91=$ctx;
   var $92=HEAP32[(($91)>>2)];
   var $93=(($92+20)|0);
   var $94=HEAP32[(($93)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$94]($ctx, 5) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 12; break; } else { label = 9; break; }
  case 12: 
   var $96=(($chf+60)|0);
   var $97=(($chf+64)|0);
   var $storemerge = 0;label = 13; break;
  case 13: 
   var $storemerge;
   var $99=(($storemerge)|(0)) < (($4)|(0));
   if ($99) { label = 14; break; } else { label = 31; break; }
  case 14: 
   var $100=(Math.imul($storemerge,$2)|0);
   var $storemerge8 = 0;label = 15; break;
  case 15: 
   var $storemerge8;
   var $102=(($storemerge8)|(0)) < (($2)|(0));
   if ($102) { label = 16; break; } else { label = 30; break; }
  case 16: 
   var $104=((($storemerge8)+($100))|0);
   var $105=HEAP32[(($96)>>2)];
   var $106=(($105+($104<<2))|0);
   var $107=$106;
   var $108=HEAP32[(($107)>>2)];
   var $109=$108 & 16777215;
   var $110=$108 >>> 24;
   var $111=((($109)+($110))|0);
   var $i_0 = $109;label = 17; break;
  case 17: 
   var $i_0;
   var $113=(($i_0)|(0)) < (($111)|(0));
   if ($113) { label = 18; break; } else { label = 29; break; }
  case 18: 
   var $115=HEAP32[(($97)>>2)];
   var $116=(($115+($i_0<<3)+2)|0);
   var $117=HEAP16[(($116)>>1)];
   var $118=(($117 << 16) >> 16)==0;
   var $119=(($117 << 16) >> 16) < 0;
   var $or_cond1070=$118 | $119;
   if ($or_cond1070) { label = 20; break; } else { label = 19; break; }
  case 19: 
   var $120=(($115+($i_0<<3)+4)|0);
   var $121=$120;
   var $storemerge9 = 0;var $res_0 = 0;label = 21; break;
  case 20: 
   var $123=(($78+$i_0)|0);
   HEAP8[($123)]=0;
   label = 28; break;
  case 21: 
   var $res_0;
   var $storemerge9;
   var $125=(($storemerge9)|(0)) < 4;
   if ($125) { label = 22; break; } else { label = 27; break; }
  case 22: 
   var $127=HEAP32[(($121)>>2)];
   var $128=$127 & 16777215;
   var $129=((($storemerge9)*(6))&-1);
   var $130=$128 >>> (($129)>>>(0));
   var $131=$130 & 63;
   var $132=(($131)|(0))==63;
   if ($132) { var $r_0 = 0;label = 24; break; } else { label = 23; break; }
  case 23: 
   var $134=$storemerge9 & 3;
   var $135=((6640+($134<<2))|0);
   var $136=HEAP32[(($135)>>2)];
   var $137=((($storemerge8)+($136))|0);
   var $138=((6624+($134<<2))|0);
   var $139=HEAP32[(($138)>>2)];
   var $140=((($storemerge)+($139))|0);
   var $141=(Math.imul($140,$2)|0);
   var $142=HEAP32[(($96)>>2)];
   var $143=((($137)+($141))|0);
   var $144=(($142+($143<<2))|0);
   var $145=$144;
   var $146=HEAP32[(($145)>>2)];
   var $147=$146 & 16777215;
   var $148=((($147)+($131))|0);
   var $149=(($115+($148<<3)+2)|0);
   var $150=HEAP16[(($149)>>1)];
   var $r_0 = $150;label = 24; break;
  case 24: 
   var $r_0;
   var $152=(($r_0 << 16) >> 16)==(($117 << 16) >> 16);
   if ($152) { label = 25; break; } else { var $res_1 = $res_0;label = 26; break; }
  case 25: 
   var $154=1 << $storemerge9;
   var $155=(($res_0)&(255));
   var $156=$155 | $154;
   var $157=(($156) & 255);
   var $res_1 = $157;label = 26; break;
  case 26: 
   var $res_1;
   var $159=((($storemerge9)+(1))|0);
   var $storemerge9 = $159;var $res_0 = $res_1;label = 21; break;
  case 27: 
   var $161=$res_0 ^ 15;
   var $162=(($78+$i_0)|0);
   HEAP8[($162)]=$161;
   label = 28; break;
  case 28: 
   var $164=((($i_0)+(1))|0);
   var $i_0 = $164;label = 17; break;
  case 29: 
   var $166=((($storemerge8)+(1))|0);
   var $storemerge8 = $166;label = 15; break;
  case 30: 
   var $168=((($storemerge)+(1))|0);
   var $storemerge = $168;label = 13; break;
  case 31: 
   var $170=HEAP8[($7)];
   var $171=$170 & 1;
   var $172=(($171 << 24) >> 24)==0;
   var $_pre1038=$ctx;
   if ($172) { var $_pre_phi1039 = $_pre1038;label = 33; break; } else { label = 32; break; }
  case 32: 
   var $174=HEAP32[(($_pre1038)>>2)];
   var $175=(($174+24)|0);
   var $176=HEAP32[(($175)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$176]($ctx, 5) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $_pre_phi1039 = $_pre1038;label = 33; break; } else { label = 9; break; }
  case 33: 
   var $_pre_phi1039;
   var $177=(($verts)|0);
   HEAP32[(($177)>>2)]=0;
   var $178=(($verts+4)|0);
   HEAP32[(($178)>>2)]=0;
   var $179=(($verts+8)|0);
   HEAP32[(($179)>>2)]=0;
   __ZN10rcIntArray6resizeEi($verts, 256);
   var $180=(($simplified)|0);
   HEAP32[(($180)>>2)]=0;
   var $181=(($simplified+4)|0);
   HEAP32[(($181)>>2)]=0;
   var $182=(($simplified+8)|0);
   HEAP32[(($182)>>2)]=0;
   __ZN10rcIntArray6resizeEi($simplified, 64);
   var $183=(($chf+72)|0);
   var $184=$regs_i_i;
   var $185=(($regs_i_i)|0);
   var $186=(($regs_i_i+12)|0);
   var $187=(($regs_i_i+8)|0);
   var $188=(($regs_i_i+4)|0);
   var $189=($maxError)*($maxError);
   var $190=(($maxEdgeLen)|(0)) > 0;
   var $191=(Math.imul($maxEdgeLen,$maxEdgeLen)|0);
   var $storemerge1 = 0;var $maxContours_0 = $68;label = 34; break;
  case 34: 
   var $maxContours_0;
   var $storemerge1;
   var $193=(($storemerge1)|(0)) < (($4)|(0));
   if ($193) { label = 35; break; } else { var $storemerge2 = 0;label = 174; break; }
  case 35: 
   var $194=(Math.imul($storemerge1,$2)|0);
   var $storemerge4 = 0;var $maxContours_1 = $maxContours_0;label = 36; break;
  case 36: 
   var $maxContours_1;
   var $storemerge4;
   var $196=(($storemerge4)|(0)) < (($2)|(0));
   if ($196) { label = 37; break; } else { label = 173; break; }
  case 37: 
   var $198=((($storemerge4)+($194))|0);
   var $199=HEAP32[(($96)>>2)];
   var $200=(($199+($198<<2))|0);
   var $201=$200;
   var $202=HEAP32[(($201)>>2)];
   var $203=$202 & 16777215;
   var $204=$202 >>> 24;
   var $205=((($203)+($204))|0);
   var $i4_0 = $203;var $maxContours_2 = $maxContours_1;label = 38; break;
  case 38: 
   var $maxContours_2;
   var $i4_0;
   var $207=(($i4_0)|(0)) < (($205)|(0));
   if ($207) { label = 39; break; } else { label = 172; break; }
  case 39: 
   var $209=(($78+$i4_0)|0);
   var $210=HEAP8[($209)];
   if ((($210 << 24) >> 24)==0 | (($210 << 24) >> 24)==15) {
    label = 40; break;
   }
   else {
   label = 46; break;
   }
  case 40: 
   HEAP8[($209)]=0;
   var $maxContours_4 = $maxContours_2;label = 171; break;
  case 41: 
   var $lpad_loopexit$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit$1 = tempRet0;
   var $lpad_phi$1 = $lpad_loopexit$1;var $lpad_phi$0 = $lpad_loopexit$0;label = 44; break;
  case 42: 
   var $lpad_loopexit1013$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit1013$1 = tempRet0;
   var $lpad_phi$1 = $lpad_loopexit1013$1;var $lpad_phi$0 = $lpad_loopexit1013$0;label = 44; break;
  case 43: 
   var $lpad_nonloopexit1014$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit1014$1 = tempRet0;
   var $lpad_phi$1 = $lpad_nonloopexit1014$1;var $lpad_phi$0 = $lpad_nonloopexit1014$0;label = 44; break;
  case 44: 
   var $lpad_phi$0;
   var $lpad_phi$1;
   var $212=$lpad_phi$0;
   var $213=$lpad_phi$1;
   var $214=HEAP32[(($180)>>2)];
   var $215=(($214)|(0))==0;
   if ($215) { label = 219; break; } else { label = 45; break; }
  case 45: 
   var $217=$214;
   _free($217);
   label = 219; break;
  case 46: 
   var $219=HEAP32[(($97)>>2)];
   var $220=(($219+($i4_0<<3)+2)|0);
   var $221=HEAP16[(($220)>>1)];
   var $222=(($221 << 16) >> 16)==0;
   var $223=(($221 << 16) >> 16) < 0;
   var $or_cond1071=$222 | $223;
   if ($or_cond1071) { var $maxContours_4 = $maxContours_2;label = 171; break; } else { label = 47; break; }
  case 47: 
   var $225=HEAP32[(($183)>>2)];
   var $226=(($225+$i4_0)|0);
   var $227=HEAP8[($226)];
   __ZN10rcIntArray6resizeEi($verts, 0);
   __ZN10rcIntArray6resizeEi($simplified, 0);
   var $228=HEAP8[($7)];
   var $229=$228 & 1;
   var $230=(($229 << 24) >> 24)==0;
   if ($230) { label = 49; break; } else { label = 48; break; }
  case 48: 
   var $232=HEAP32[(($_pre_phi1039)>>2)];
   var $233=(($232+20)|0);
   var $234=HEAP32[(($233)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$234]($ctx, 5) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 49; break; } else { label = 42; break; }
  case 49: 
   var $236=HEAP8[($209)];
   var $237=(($236)&(255));
   var $storemerge_i34 = 0;label = 50; break;
  case 50: 
   var $storemerge_i34;
   var $239=(($storemerge_i34)&(255));
   var $240=1 << $239;
   var $241=$237 & $240;
   var $242=(($241)|(0))==0;
   if ($242) { label = 51; break; } else { label = 52; break; }
  case 51: 
   var $244=((($storemerge_i34)+(1))&255);
   var $storemerge_i34 = $244;label = 50; break;
  case 52: 
   var $246=HEAP32[(($183)>>2)];
   var $247=(($246+$i4_0)|0);
   var $248=HEAP8[($247)];
   var $_0 = $storemerge4;var $_0990 = $storemerge1;var $_0994 = $i4_0;var $dir_i_0 = $storemerge_i34;var $iter_i_0 = 1;label = 53; break;
  case 53: 
   var $iter_i_0;
   var $dir_i_0;
   var $_0994;
   var $_0990;
   var $_0;
   var $250=(($iter_i_0)|(0)) < 40000;
   if ($250) { label = 54; break; } else { label = 82; break; }
  case 54: 
   var $252=(($78+$_0994)|0);
   var $253=HEAP8[($252)];
   var $254=(($253)&(255));
   var $255=(($dir_i_0)&(255));
   var $256=1 << $255;
   var $257=$254 & $256;
   var $258=(($257)|(0))==0;
   if ($258) { label = 77; break; } else { label = 55; break; }
  case 55: 
   var $260=HEAP32[(($97)>>2)];
   var $261=(($260+($_0994<<3))|0);
   var $262=HEAP16[(($261)>>1)];
   var $263=(($262)&(65535));
   var $264=((($255)+(1))|0);
   var $265=$264 & 3;
   HEAP32[(($184)>>2)]=0; HEAP32[((($184)+(4))>>2)]=0; HEAP32[((($184)+(8))>>2)]=0; HEAP32[((($184)+(12))>>2)]=0;
   var $266=(($260+($_0994<<3)+2)|0);
   var $267=HEAP16[(($266)>>1)];
   var $268=(($267)&(65535));
   var $269=HEAP32[(($183)>>2)];
   var $270=(($269+$_0994)|0);
   var $271=HEAP8[($270)];
   var $272=(($271)&(255));
   var $273=$272 << 16;
   var $274=$268 | $273;
   HEAP32[(($185)>>2)]=$274;
   var $275=((($255)*(6))&-1);
   var $276=(($260+($_0994<<3)+4)|0);
   var $277=$276;
   var $278=HEAP32[(($277)>>2)];
   var $279=$278 & 16777215;
   var $280=$279 >>> (($275)>>>(0));
   var $281=$280 & 63;
   var $282=(($281)|(0))==63;
   if ($282) { label = 56; break; } else { label = 57; break; }
  case 56: 
   var $_pre1040=((($265)*(6))&-1);
   var $ch_i_i_0 = $263;var $_pre_phi1041 = $_pre1040;label = 59; break;
  case 57: 
   var $284=$255 & 3;
   var $285=((6640+($284<<2))|0);
   var $286=HEAP32[(($285)>>2)];
   var $287=((($_0)+($286))|0);
   var $288=((6624+($284<<2))|0);
   var $289=HEAP32[(($288)>>2)];
   var $290=((($_0990)+($289))|0);
   var $291=HEAP32[(($1)>>2)];
   var $292=(Math.imul($290,$291)|0);
   var $293=((($287)+($292))|0);
   var $294=HEAP32[(($96)>>2)];
   var $295=(($294+($293<<2))|0);
   var $296=$295;
   var $297=HEAP32[(($296)>>2)];
   var $298=$297 & 16777215;
   var $299=((($298)+($281))|0);
   var $300=(($260+($299<<3))|0);
   var $301=HEAP16[(($300)>>1)];
   var $302=(($301)&(65535));
   var $303=(($263)>>>(0)) > (($302)>>>(0));
   var $304=$303 ? $263 : $302;
   var $305=(($260+($299<<3)+2)|0);
   var $306=HEAP16[(($305)>>1)];
   var $307=(($306)&(65535));
   var $308=(($269+$299)|0);
   var $309=HEAP8[($308)];
   var $310=(($309)&(255));
   var $311=$310 << 16;
   var $312=$307 | $311;
   HEAP32[(($188)>>2)]=$312;
   var $313=((($265)*(6))&-1);
   var $314=(($260+($299<<3)+4)|0);
   var $315=$314;
   var $316=HEAP32[(($315)>>2)];
   var $317=$316 & 16777215;
   var $318=$317 >>> (($313)>>>(0));
   var $319=$318 & 63;
   var $320=(($319)|(0))==63;
   if ($320) { var $ch_i_i_0 = $304;var $_pre_phi1041 = $313;label = 59; break; } else { label = 58; break; }
  case 58: 
   var $322=((6640+($265<<2))|0);
   var $323=HEAP32[(($322)>>2)];
   var $324=((($287)+($323))|0);
   var $325=((6624+($265<<2))|0);
   var $326=HEAP32[(($325)>>2)];
   var $327=((($290)+($326))|0);
   var $328=(Math.imul($327,$291)|0);
   var $329=((($324)+($328))|0);
   var $330=(($294+($329<<2))|0);
   var $331=$330;
   var $332=HEAP32[(($331)>>2)];
   var $333=$332 & 16777215;
   var $334=((($333)+($319))|0);
   var $335=(($260+($334<<3))|0);
   var $336=HEAP16[(($335)>>1)];
   var $337=(($336)&(65535));
   var $338=(($304)>>>(0)) > (($337)>>>(0));
   var $339=$338 ? $304 : $337;
   var $340=(($260+($334<<3)+2)|0);
   var $341=HEAP16[(($340)>>1)];
   var $342=(($341)&(65535));
   var $343=(($269+$334)|0);
   var $344=HEAP8[($343)];
   var $345=(($344)&(255));
   var $346=$345 << 16;
   var $347=$342 | $346;
   HEAP32[(($187)>>2)]=$347;
   var $ch_i_i_0 = $339;var $_pre_phi1041 = $313;label = 59; break;
  case 59: 
   var $_pre_phi1041;
   var $ch_i_i_0;
   var $349=$279 >>> (($_pre_phi1041)>>>(0));
   var $350=$349 & 63;
   var $351=(($350)|(0))==63;
   if ($351) { var $ch_i_i_1_ph = $ch_i_i_0;label = 62; break; } else { label = 60; break; }
  case 60: 
   var $353=((6640+($265<<2))|0);
   var $354=HEAP32[(($353)>>2)];
   var $355=((($_0)+($354))|0);
   var $356=((6624+($265<<2))|0);
   var $357=HEAP32[(($356)>>2)];
   var $358=((($_0990)+($357))|0);
   var $359=HEAP32[(($1)>>2)];
   var $360=(Math.imul($358,$359)|0);
   var $361=((($355)+($360))|0);
   var $362=HEAP32[(($96)>>2)];
   var $363=(($362+($361<<2))|0);
   var $364=$363;
   var $365=HEAP32[(($364)>>2)];
   var $366=$365 & 16777215;
   var $367=((($366)+($350))|0);
   var $368=(($260+($367<<3))|0);
   var $369=HEAP16[(($368)>>1)];
   var $370=(($369)&(65535));
   var $371=(($ch_i_i_0)|(0)) > (($370)|(0));
   var $372=$371 ? $ch_i_i_0 : $370;
   var $373=(($260+($367<<3)+2)|0);
   var $374=HEAP16[(($373)>>1)];
   var $375=(($374)&(65535));
   var $376=(($269+$367)|0);
   var $377=HEAP8[($376)];
   var $378=(($377)&(255));
   var $379=$378 << 16;
   var $380=$375 | $379;
   HEAP32[(($186)>>2)]=$380;
   var $381=(($260+($367<<3)+4)|0);
   var $382=$381;
   var $383=HEAP32[(($382)>>2)];
   var $384=$383 & 16777215;
   var $385=$384 >>> (($275)>>>(0));
   var $386=$385 & 63;
   var $387=(($386)|(0))==63;
   if ($387) { var $ch_i_i_1_ph = $372;label = 62; break; } else { label = 61; break; }
  case 61: 
   var $389=$255 & 3;
   var $390=((6640+($389<<2))|0);
   var $391=HEAP32[(($390)>>2)];
   var $392=((($355)+($391))|0);
   var $393=((6624+($389<<2))|0);
   var $394=HEAP32[(($393)>>2)];
   var $395=((($358)+($394))|0);
   var $396=(Math.imul($395,$359)|0);
   var $397=((($392)+($396))|0);
   var $398=(($362+($397<<2))|0);
   var $399=$398;
   var $400=HEAP32[(($399)>>2)];
   var $401=$400 & 16777215;
   var $402=((($401)+($386))|0);
   var $403=(($260+($402<<3))|0);
   var $404=HEAP16[(($403)>>1)];
   var $405=(($404)&(65535));
   var $406=(($372)|(0)) > (($405)|(0));
   var $407=$406 ? $372 : $405;
   var $408=(($260+($402<<3)+2)|0);
   var $409=HEAP16[(($408)>>1)];
   var $410=(($409)&(65535));
   var $411=(($269+$402)|0);
   var $412=HEAP8[($411)];
   var $413=(($412)&(255));
   var $414=$413 << 16;
   var $415=$410 | $414;
   HEAP32[(($187)>>2)]=$415;
   var $ch_i_i_1_ph = $407;label = 62; break;
  case 62: 
   var $ch_i_i_1_ph;
   var $storemerge_i_i = 0;label = 63; break;
  case 63: 
   var $storemerge_i_i;
   var $417=(($storemerge_i_i)|(0)) < 4;
   if ($417) { label = 64; break; } else { var $isBorderVertex_i_0 = 0;label = 70; break; }
  case 64: 
   var $419=((($storemerge_i_i)+(1))|0);
   var $420=$419 & 3;
   var $421=((($storemerge_i_i)+(2))|0);
   var $422=$421 & 3;
   var $423=((($storemerge_i_i)+(3))|0);
   var $424=$423 & 3;
   var $425=(($regs_i_i+($storemerge_i_i<<2))|0);
   var $426=HEAP32[(($425)>>2)];
   var $427=(($regs_i_i+($420<<2))|0);
   var $428=HEAP32[(($427)>>2)];
   var $429=$426 & $428;
   var $430=$429 & 32768;
   var $431=(($430)|(0))==0;
   if ($431) { var $435 = 0;label = 66; break; } else { label = 65; break; }
  case 65: 
   var $433=(($426)|(0))==(($428)|(0));
   var $phitmp_i_i=(($433)&(1));
   var $435 = $phitmp_i_i;label = 66; break;
  case 66: 
   var $435;
   var $436=(($regs_i_i+($422<<2))|0);
   var $437=HEAP32[(($436)>>2)];
   var $438=(($regs_i_i+($424<<2))|0);
   var $439=HEAP32[(($438)>>2)];
   var $440=$437 | $439;
   var $441=$437 >>> 16;
   var $442=$439 >>> 16;
   var $443=(($441)|(0))==(($442)|(0));
   var $444=(($426)|(0))==0;
   var $445=(($428)|(0))==0;
   var $or_cond1072=$444 | $445;
   var $446=(($437)|(0))==0;
   var $or_cond1073=$or_cond1072 | $446;
   if ($or_cond1073) { var $450 = 0;label = 68; break; } else { label = 67; break; }
  case 67: 
   var $448=(($439)|(0))!=0;
   var $phitmp1_i_i=(($448)&(1));
   var $450 = $phitmp1_i_i;label = 68; break;
  case 68: 
   var $450;
   var $451=(($435 << 24) >> 24)==0;
   if ($451) { var $storemerge_i_i = $419;label = 63; break; } else { label = 69; break; }
  case 69: 
   var $453=$440 & 32768;
   var $454=(($453)|(0))==0;
   var $_not=$454 ^ 1;
   var $_not1074=$443 ^ 1;
   var $brmerge=$_not | $_not1074;
   var $455=(($450 << 24) >> 24)==0;
   var $or_cond1075=$brmerge | $455;
   if ($or_cond1075) { var $storemerge_i_i = $419;label = 63; break; } else { var $isBorderVertex_i_0 = 1;label = 70; break; }
  case 70: 
   var $isBorderVertex_i_0;
   if ((($255)|(0))==0) {
    label = 71; break;
   }
   else if ((($255)|(0))==1) {
    label = 72; break;
   }
   else if ((($255)|(0))==2) {
    label = 73; break;
   }
   else {
   var $px_i_0 = $_0;var $pz_i_0 = $_0990;label = 74; break;
   }
  case 71: 
   var $457=((($_0990)+(1))|0);
   var $px_i_0 = $_0;var $pz_i_0 = $457;label = 74; break;
  case 72: 
   var $459=((($_0)+(1))|0);
   var $460=((($_0990)+(1))|0);
   var $px_i_0 = $459;var $pz_i_0 = $460;label = 74; break;
  case 73: 
   var $462=((($_0)+(1))|0);
   var $px_i_0 = $462;var $pz_i_0 = $_0990;label = 74; break;
  case 74: 
   var $pz_i_0;
   var $px_i_0;
   if ($282) { var $isAreaBorder_i_0 = 0;var $r_i_0 = 0;label = 76; break; } else { label = 75; break; }
  case 75: 
   var $465=$255 & 3;
   var $466=((6640+($465<<2))|0);
   var $467=HEAP32[(($466)>>2)];
   var $468=((($_0)+($467))|0);
   var $469=((6624+($465<<2))|0);
   var $470=HEAP32[(($469)>>2)];
   var $471=((($_0990)+($470))|0);
   var $472=HEAP32[(($1)>>2)];
   var $473=(Math.imul($471,$472)|0);
   var $474=((($468)+($473))|0);
   var $475=HEAP32[(($96)>>2)];
   var $476=(($475+($474<<2))|0);
   var $477=$476;
   var $478=HEAP32[(($477)>>2)];
   var $479=$478 & 16777215;
   var $480=((($479)+($281))|0);
   var $481=(($260+($480<<3)+2)|0);
   var $482=HEAP16[(($481)>>1)];
   var $483=(($482)&(65535));
   var $484=(($269+$480)|0);
   var $485=HEAP8[($484)];
   var $486=(($248 << 24) >> 24)==(($485 << 24) >> 24);
   var $_=$486 ? 0 : 1;
   var $isAreaBorder_i_0 = $_;var $r_i_0 = $483;label = 76; break;
  case 76: 
   var $r_i_0;
   var $isAreaBorder_i_0;
   var $487=(($isBorderVertex_i_0 << 24) >> 24)==0;
   var $488=$r_i_0 | 65536;
   var $r_i_1=$487 ? $r_i_0 : $488;
   var $489=(($isAreaBorder_i_0 << 24) >> 24)==0;
   var $490=$r_i_1 | 131072;
   var $r_i_1_=$489 ? $r_i_1 : $490;
   var $491=HEAP32[(($178)>>2)];
   var $492=((($491)+(1))|0);
   __ZN10rcIntArray6resizeEi($verts, $492);
   var $493=HEAP32[(($178)>>2)];
   var $494=((($493)-(1))|0);
   var $495=HEAP32[(($177)>>2)];
   var $496=(($495+($494<<2))|0);
   HEAP32[(($496)>>2)]=$px_i_0;
   var $497=((($493)+(1))|0);
   __ZN10rcIntArray6resizeEi($verts, $497);
   var $498=HEAP32[(($178)>>2)];
   var $499=((($498)-(1))|0);
   var $500=HEAP32[(($177)>>2)];
   var $501=(($500+($499<<2))|0);
   HEAP32[(($501)>>2)]=$ch_i_i_1_ph;
   var $502=((($498)+(1))|0);
   __ZN10rcIntArray6resizeEi($verts, $502);
   var $503=HEAP32[(($178)>>2)];
   var $504=((($503)-(1))|0);
   var $505=HEAP32[(($177)>>2)];
   var $506=(($505+($504<<2))|0);
   HEAP32[(($506)>>2)]=$pz_i_0;
   var $507=((($503)+(1))|0);
   __ZN10rcIntArray6resizeEi($verts, $507);
   var $508=HEAP32[(($178)>>2)];
   var $509=((($508)-(1))|0);
   var $510=HEAP32[(($177)>>2)];
   var $511=(($510+($509<<2))|0);
   HEAP32[(($511)>>2)]=$r_i_1_;
   var $512=$256 ^ 255;
   var $513=HEAP8[($252)];
   var $514=(($513)&(255));
   var $515=$514 & $512;
   var $516=(($515) & 255);
   HEAP8[($252)]=$516;
   var $517=((($dir_i_0)+(1))&255);
   var $storemerge1_in_i = $517;var $_1 = $_0;var $_1991 = $_0990;var $_1995 = $_0994;label = 80; break;
  case 77: 
   var $519=$255 & 3;
   var $520=((6640+($519<<2))|0);
   var $521=HEAP32[(($520)>>2)];
   var $522=((($_0)+($521))|0);
   var $523=((6624+($519<<2))|0);
   var $524=HEAP32[(($523)>>2)];
   var $525=((($_0990)+($524))|0);
   var $526=HEAP32[(($97)>>2)];
   var $527=((($255)*(6))&-1);
   var $528=(($526+($_0994<<3)+4)|0);
   var $529=$528;
   var $530=HEAP32[(($529)>>2)];
   var $531=$530 & 16777215;
   var $532=$531 >>> (($527)>>>(0));
   var $533=$532 & 63;
   var $534=(($533)|(0))==63;
   if ($534) { label = 82; break; } else { label = 78; break; }
  case 78: 
   var $535=HEAP32[(($1)>>2)];
   var $536=(Math.imul($525,$535)|0);
   var $537=((($522)+($536))|0);
   var $538=HEAP32[(($96)>>2)];
   var $539=(($538+($537<<2))|0);
   var $540=$539;
   var $541=HEAP32[(($540)>>2)];
   var $542=$541 & 16777215;
   var $543=((($542)+($533))|0);
   var $phitmp1064=(($543)|(0))==-1;
   if ($phitmp1064) { label = 82; break; } else { label = 79; break; }
  case 79: 
   var $545=((($dir_i_0)+(3))&255);
   var $storemerge1_in_i = $545;var $_1 = $522;var $_1991 = $525;var $_1995 = $543;label = 80; break;
  case 80: 
   var $_1995;
   var $_1991;
   var $_1;
   var $storemerge1_in_i;
   var $storemerge1_i35=$storemerge1_in_i & 3;
   var $547=(($i4_0)|(0))==(($_1995)|(0));
   var $548=(($storemerge_i34 << 24) >> 24)==(($storemerge1_i35 << 24) >> 24);
   var $or_cond=$547 & $548;
   if ($or_cond) { label = 82; break; } else { label = 81; break; }
  case 81: 
   var $phitmp=((($iter_i_0)+(1))|0);
   var $_0 = $_1;var $_0990 = $_1991;var $_0994 = $_1995;var $dir_i_0 = $storemerge1_i35;var $iter_i_0 = $phitmp;label = 53; break;
  case 82: 
   var $549=HEAP8[($7)];
   var $550=$549 & 1;
   var $551=(($550 << 24) >> 24)==0;
   if ($551) { var $557 = $549;label = 85; break; } else { label = 83; break; }
  case 83: 
   var $553=HEAP32[(($_pre_phi1039)>>2)];
   var $554=(($553+24)|0);
   var $555=HEAP32[(($554)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$555]($ctx, 5) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 84; break; } else { label = 42; break; }
  case 84: 
   var $_pre1033=HEAP8[($7)];
   var $557 = $_pre1033;label = 85; break;
  case 85: 
   var $557;
   var $558=$557 & 1;
   var $559=(($558 << 24) >> 24)==0;
   if ($559) { label = 87; break; } else { label = 86; break; }
  case 86: 
   var $561=HEAP32[(($_pre_phi1039)>>2)];
   var $562=(($561+20)|0);
   var $563=HEAP32[(($562)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$563]($ctx, 6) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 87; break; } else { label = 42; break; }
  case 87: 
   var $564=HEAP32[(($178)>>2)];
   var $565=HEAP32[(($177)>>2)];
   var $storemerge_i48 = 0;label = 88; break;
  case 88: 
   var $storemerge_i48;
   var $567=(($storemerge_i48)|(0)) < (($564)|(0));
   if ($567) { label = 89; break; } else { label = 95; break; }
  case 89: 
   var $569=$storemerge_i48 | 3;
   var $570=(($565+($569<<2))|0);
   var $571=HEAP32[(($570)>>2)];
   var $572=$571 & 65535;
   var $573=(($572)|(0))==0;
   if ($573) { label = 90; break; } else { label = 91; break; }
  case 90: 
   var $575=((($storemerge_i48)+(4))|0);
   var $storemerge_i48 = $575;label = 88; break;
  case 91: 
   var $576=((((($564)|(0)))/(4))&-1);
   var $i1_i42_0 = 0;label = 92; break;
  case 92: 
   var $i1_i42_0;
   var $578=(($i1_i42_0)|(0)) < (($576)|(0));
   if ($578) { label = 93; break; } else { label = 95; break; }
  case 93: 
   var $580=((($i1_i42_0)+(1))|0);
   var $581=((((($580)|(0)))%((($576)|(0))))&-1);
   var $582=$i1_i42_0 << 2;
   var $583=$582 | 3;
   var $584=(($565+($583<<2))|0);
   var $585=HEAP32[(($584)>>2)];
   var $586=$581 << 2;
   var $587=$586 | 3;
   var $588=(($565+($587<<2))|0);
   var $589=HEAP32[(($588)>>2)];
   var $590=$585 ^ $589;
   var $591=$590 & 65535;
   var $592=(($591)|(0))==0;
   var $593=$590 & 131072;
   var $594=(($593)|(0))==0;
   var $or_cond1077=$592 & $594;
   if ($or_cond1077) { var $i1_i42_0 = $580;label = 92; break; } else { label = 94; break; }
  case 94: 
   var $595=(($565+($582<<2))|0);
   var $596=HEAP32[(($595)>>2)];
   var $597=HEAP32[(($181)>>2)];
   var $598=((($597)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $598);
   var $599=HEAP32[(($181)>>2)];
   var $600=((($599)-(1))|0);
   var $601=HEAP32[(($180)>>2)];
   var $602=(($601+($600<<2))|0);
   HEAP32[(($602)>>2)]=$596;
   var $603=$582 | 1;
   var $604=(($565+($603<<2))|0);
   var $605=HEAP32[(($604)>>2)];
   var $606=((($599)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $606);
   var $607=HEAP32[(($181)>>2)];
   var $608=((($607)-(1))|0);
   var $609=HEAP32[(($180)>>2)];
   var $610=(($609+($608<<2))|0);
   HEAP32[(($610)>>2)]=$605;
   var $611=$582 | 2;
   var $612=(($565+($611<<2))|0);
   var $613=HEAP32[(($612)>>2)];
   var $614=((($607)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $614);
   var $615=HEAP32[(($181)>>2)];
   var $616=((($615)-(1))|0);
   var $617=HEAP32[(($180)>>2)];
   var $618=(($617+($616<<2))|0);
   HEAP32[(($618)>>2)]=$613;
   var $619=((($615)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $619);
   var $620=HEAP32[(($181)>>2)];
   var $621=((($620)-(1))|0);
   var $622=HEAP32[(($180)>>2)];
   var $623=(($622+($621<<2))|0);
   HEAP32[(($623)>>2)]=$i1_i42_0;
   var $i1_i42_0 = $580;label = 92; break;
  case 95: 
   var $624=HEAP32[(($181)>>2)];
   var $625=(($624)|(0))==0;
   if ($625) { label = 96; break; } else { var $699 = $624;label = 106; break; }
  case 96: 
   var $627=HEAP32[(($565)>>2)];
   var $628=(($565+4)|0);
   var $629=HEAP32[(($628)>>2)];
   var $630=(($565+8)|0);
   var $631=HEAP32[(($630)>>2)];
   var $storemerge6_i = 0;var $llx_i_0 = $627;var $lly_i_0 = $629;var $llz_i_0 = $631;var $lli_i_0 = 0;var $urx_i_0 = $627;var $ury_i_0 = $629;var $urz_i_0 = $631;var $uri_i_0 = 0;label = 97; break;
  case 97: 
   var $uri_i_0;
   var $urz_i_0;
   var $ury_i_0;
   var $urx_i_0;
   var $lli_i_0;
   var $llz_i_0;
   var $lly_i_0;
   var $llx_i_0;
   var $storemerge6_i;
   var $633=(($storemerge6_i)|(0)) < (($564)|(0));
   if ($633) { label = 98; break; } else { label = 105; break; }
  case 98: 
   var $635=(($565+($storemerge6_i<<2))|0);
   var $636=HEAP32[(($635)>>2)];
   var $637=$storemerge6_i | 1;
   var $638=(($565+($637<<2))|0);
   var $639=HEAP32[(($638)>>2)];
   var $640=$storemerge6_i | 2;
   var $641=(($565+($640<<2))|0);
   var $642=HEAP32[(($641)>>2)];
   var $643=(($636)|(0)) < (($llx_i_0)|(0));
   if ($643) { label = 100; break; } else { label = 99; break; }
  case 99: 
   var $645=(($636)|(0))==(($llx_i_0)|(0));
   var $646=(($642)|(0)) < (($llz_i_0)|(0));
   var $or_cond1078=$645 & $646;
   if ($or_cond1078) { label = 100; break; } else { var $llx_i_1 = $llx_i_0;var $lly_i_1 = $lly_i_0;var $llz_i_1 = $llz_i_0;var $lli_i_1 = $lli_i_0;label = 101; break; }
  case 100: 
   var $648=((((($storemerge6_i)|(0)))/(4))&-1);
   var $llx_i_1 = $636;var $lly_i_1 = $639;var $llz_i_1 = $642;var $lli_i_1 = $648;label = 101; break;
  case 101: 
   var $lli_i_1;
   var $llz_i_1;
   var $lly_i_1;
   var $llx_i_1;
   var $650=(($636)|(0)) > (($urx_i_0)|(0));
   if ($650) { label = 103; break; } else { label = 102; break; }
  case 102: 
   var $652=(($636)|(0))==(($urx_i_0)|(0));
   var $653=(($642)|(0)) > (($urz_i_0)|(0));
   var $or_cond1079=$652 & $653;
   if ($or_cond1079) { label = 103; break; } else { var $urx_i_1 = $urx_i_0;var $ury_i_1 = $ury_i_0;var $urz_i_1 = $urz_i_0;var $uri_i_1 = $uri_i_0;label = 104; break; }
  case 103: 
   var $655=((((($storemerge6_i)|(0)))/(4))&-1);
   var $urx_i_1 = $636;var $ury_i_1 = $639;var $urz_i_1 = $642;var $uri_i_1 = $655;label = 104; break;
  case 104: 
   var $uri_i_1;
   var $urz_i_1;
   var $ury_i_1;
   var $urx_i_1;
   var $657=((($storemerge6_i)+(4))|0);
   var $storemerge6_i = $657;var $llx_i_0 = $llx_i_1;var $lly_i_0 = $lly_i_1;var $llz_i_0 = $llz_i_1;var $lli_i_0 = $lli_i_1;var $urx_i_0 = $urx_i_1;var $ury_i_0 = $ury_i_1;var $urz_i_0 = $urz_i_1;var $uri_i_0 = $uri_i_1;label = 97; break;
  case 105: 
   __ZN10rcIntArray6resizeEi($simplified, 1);
   var $659=HEAP32[(($181)>>2)];
   var $660=((($659)-(1))|0);
   var $661=HEAP32[(($180)>>2)];
   var $662=(($661+($660<<2))|0);
   HEAP32[(($662)>>2)]=$llx_i_0;
   var $663=((($659)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $663);
   var $664=HEAP32[(($181)>>2)];
   var $665=((($664)-(1))|0);
   var $666=HEAP32[(($180)>>2)];
   var $667=(($666+($665<<2))|0);
   HEAP32[(($667)>>2)]=$lly_i_0;
   var $668=((($664)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $668);
   var $669=HEAP32[(($181)>>2)];
   var $670=((($669)-(1))|0);
   var $671=HEAP32[(($180)>>2)];
   var $672=(($671+($670<<2))|0);
   HEAP32[(($672)>>2)]=$llz_i_0;
   var $673=((($669)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $673);
   var $674=HEAP32[(($181)>>2)];
   var $675=((($674)-(1))|0);
   var $676=HEAP32[(($180)>>2)];
   var $677=(($676+($675<<2))|0);
   HEAP32[(($677)>>2)]=$lli_i_0;
   var $678=((($674)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $678);
   var $679=HEAP32[(($181)>>2)];
   var $680=((($679)-(1))|0);
   var $681=HEAP32[(($180)>>2)];
   var $682=(($681+($680<<2))|0);
   HEAP32[(($682)>>2)]=$urx_i_0;
   var $683=((($679)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $683);
   var $684=HEAP32[(($181)>>2)];
   var $685=((($684)-(1))|0);
   var $686=HEAP32[(($180)>>2)];
   var $687=(($686+($685<<2))|0);
   HEAP32[(($687)>>2)]=$ury_i_0;
   var $688=((($684)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $688);
   var $689=HEAP32[(($181)>>2)];
   var $690=((($689)-(1))|0);
   var $691=HEAP32[(($180)>>2)];
   var $692=(($691+($690<<2))|0);
   HEAP32[(($692)>>2)]=$urz_i_0;
   var $693=((($689)+(1))|0);
   __ZN10rcIntArray6resizeEi($simplified, $693);
   var $694=HEAP32[(($181)>>2)];
   var $695=((($694)-(1))|0);
   var $696=HEAP32[(($180)>>2)];
   var $697=(($696+($695<<2))|0);
   HEAP32[(($697)>>2)]=$uri_i_0;
   var $699 = $694;label = 106; break;
  case 106: 
   var $699;
   var $700=((((($564)|(0)))/(4))&-1);
   var $701=((($700)-(1))|0);
   var $i3_i_0_ph = 0;var $702 = $699;label = 107; break;
  case 107: 
   var $702;
   var $i3_i_0_ph;
   var $703=((($i3_i_0_ph)+(1))|0);
   var $704=$i3_i_0_ph << 2;
   var $705=$704 | 2;
   var $706=$704 | 3;
   var $707=((($704)+(4))|0);
   var $708=((($704)+(5))|0);
   var $709=((($704)+(6))|0);
   var $710=((($704)+(7))|0);
   var $712 = $702;label = 108; break;
  case 108: 
   var $712;
   var $713=((((($712)|(0)))/(4))&-1);
   var $714=(($i3_i_0_ph)|(0)) < (($713)|(0));
   if ($714) { label = 109; break; } else { label = 127; break; }
  case 109: 
   var $716=((((($703)|(0)))%((($713)|(0))))&-1);
   var $717=HEAP32[(($180)>>2)];
   var $718=(($717+($704<<2))|0);
   var $719=HEAP32[(($718)>>2)];
   var $720=(($717+($705<<2))|0);
   var $721=HEAP32[(($720)>>2)];
   var $722=(($717+($706<<2))|0);
   var $723=HEAP32[(($722)>>2)];
   var $724=$716 << 2;
   var $725=(($717+($724<<2))|0);
   var $726=HEAP32[(($725)>>2)];
   var $727=$724 | 2;
   var $728=(($717+($727<<2))|0);
   var $729=HEAP32[(($728)>>2)];
   var $730=$724 | 3;
   var $731=(($717+($730<<2))|0);
   var $732=HEAP32[(($731)>>2)];
   var $733=(($726)|(0)) > (($719)|(0));
   if ($733) { label = 111; break; } else { label = 110; break; }
  case 110: 
   var $735=(($726)|(0))==(($719)|(0));
   var $736=(($729)|(0)) > (($721)|(0));
   var $or_cond1080=$735 & $736;
   if ($or_cond1080) { label = 111; break; } else { label = 112; break; }
  case 111: 
   var $738=((($723)+(1))|0);
   var $_pn1063 = $738;var $cinc_i_0 = 1;var $storemerge4_i = $732;label = 113; break;
  case 112: 
   var $740=((($732)+($701))|0);
   var $_pn1063 = $740;var $cinc_i_0 = $701;var $storemerge4_i = $723;label = 113; break;
  case 113: 
   var $storemerge4_i;
   var $cinc_i_0;
   var $_pn1063;
   var $storemerge59=((((($_pn1063)|(0)))%((($700)|(0))))&-1);
   var $742=$storemerge59 << 2;
   var $743=$742 | 3;
   var $744=(($565+($743<<2))|0);
   var $745=HEAP32[(($744)>>2)];
   var $746=$745 & 65535;
   var $747=(($746)|(0))!=0;
   var $748=$745 & 131072;
   var $749=(($748)|(0))==0;
   var $or_cond1082=$747 & $749;
   if ($or_cond1082) { var $i3_i_0_ph = $703;var $702 = $712;label = 107; break; } else { label = 114; break; }
  case 114: 
   var $750=((($726)-($719))|0);
   var $751=(($750)|(0));
   var $752=((($729)-($721))|0);
   var $753=(($752)|(0));
   var $754=($751)*($751);
   var $755=($753)*($753);
   var $756=($754)+($755);
   var $757=$756 > 0;
   var $758=(($719)|(0));
   var $759=(($721)|(0));
   var $maxd_i_0 = 0;var $maxi_i_0 = -1;var $ci_i_0 = $storemerge59;label = 115; break;
  case 115: 
   var $ci_i_0;
   var $maxi_i_0;
   var $maxd_i_0;
   var $761=(($ci_i_0)|(0))==(($storemerge4_i)|(0));
   if ($761) { var $maxd_i_2 = $maxd_i_0;var $maxi_i_2 = $maxi_i_0;label = 122; break; } else { label = 116; break; }
  case 116: 
   var $763=$ci_i_0 << 2;
   var $764=(($565+($763<<2))|0);
   var $765=HEAP32[(($764)>>2)];
   var $766=$763 | 2;
   var $767=(($565+($766<<2))|0);
   var $768=HEAP32[(($767)>>2)];
   var $769=((($765)-($719))|0);
   var $770=(($769)|(0));
   var $771=((($768)-($721))|0);
   var $772=(($771)|(0));
   var $773=($751)*($770);
   var $774=($753)*($772);
   var $775=($773)+($774);
   if ($757) { label = 117; break; } else { var $t_i_i_0 = $775;label = 118; break; }
  case 117: 
   var $777=($775)/($756);
   var $t_i_i_0 = $777;label = 118; break;
  case 118: 
   var $t_i_i_0;
   var $779=$t_i_i_0 < 0;
   if ($779) { var $t_i_i_1 = 0;label = 121; break; } else { label = 119; break; }
  case 119: 
   var $781=$t_i_i_0 > 1;
   if ($781) { label = 120; break; } else { var $t_i_i_1 = $t_i_i_0;label = 121; break; }
  case 120: 
   var $t_i_i_1 = 1;label = 121; break;
  case 121: 
   var $t_i_i_1;
   var $783=($t_i_i_1)*($751);
   var $784=($758)+($783);
   var $785=(($765)|(0));
   var $786=($784)-($785);
   var $787=($t_i_i_1)*($753);
   var $788=($759)+($787);
   var $789=(($768)|(0));
   var $790=($788)-($789);
   var $791=($786)*($786);
   var $792=($790)*($790);
   var $793=($791)+($792);
   var $794=$793 > $maxd_i_0;
   var $maxi_i_1=$794 ? $ci_i_0 : $maxi_i_0;
   var $maxd_i_1=$794 ? $793 : $maxd_i_0;
   var $795=((($ci_i_0)+($cinc_i_0))|0);
   var $796=((((($795)|(0)))%((($700)|(0))))&-1);
   var $maxd_i_0 = $maxd_i_1;var $maxi_i_0 = $maxi_i_1;var $ci_i_0 = $796;label = 115; break;
  case 122: 
   var $maxi_i_2;
   var $maxd_i_2;
   var $797=(($maxi_i_2)|(0))!=-1;
   var $798=$maxd_i_2 > $189;
   var $or_cond1083=$797 & $798;
   if ($or_cond1083) { label = 123; break; } else { var $i3_i_0_ph = $703;var $702 = $712;label = 107; break; }
  case 123: 
   var $800=((($712)+(4))|0);
   __ZN10rcIntArray6resizeEi($simplified, $800);
   var $801=HEAP32[(($181)>>2)];
   var $802=((((($801)|(0)))/(4))&-1);
   var $storemerge5_in_i = $802;label = 124; break;
  case 124: 
   var $storemerge5_in_i;
   var $storemerge5_i=((($storemerge5_in_i)-(1))|0);
   var $804=(($storemerge5_i)|(0)) > (($i3_i_0_ph)|(0));
   if ($804) { label = 125; break; } else { label = 126; break; }
  case 125: 
   var $806=$storemerge5_i << 2;
   var $807=((($806)-(4))|0);
   var $808=HEAP32[(($180)>>2)];
   var $809=(($808+($807<<2))|0);
   var $810=HEAP32[(($809)>>2)];
   var $811=(($808+($806<<2))|0);
   HEAP32[(($811)>>2)]=$810;
   var $812=((($806)-(3))|0);
   var $813=(($808+($812<<2))|0);
   var $814=HEAP32[(($813)>>2)];
   var $815=$806 | 1;
   var $816=(($808+($815<<2))|0);
   HEAP32[(($816)>>2)]=$814;
   var $817=((($806)-(2))|0);
   var $818=(($808+($817<<2))|0);
   var $819=HEAP32[(($818)>>2)];
   var $820=$806 | 2;
   var $821=(($808+($820<<2))|0);
   HEAP32[(($821)>>2)]=$819;
   var $822=((($806)-(1))|0);
   var $823=(($808+($822<<2))|0);
   var $824=HEAP32[(($823)>>2)];
   var $825=$806 | 3;
   var $826=(($808+($825<<2))|0);
   HEAP32[(($826)>>2)]=$824;
   var $storemerge5_in_i = $storemerge5_i;label = 124; break;
  case 126: 
   var $828=$maxi_i_2 << 2;
   var $829=(($565+($828<<2))|0);
   var $830=HEAP32[(($829)>>2)];
   var $831=HEAP32[(($180)>>2)];
   var $832=(($831+($707<<2))|0);
   HEAP32[(($832)>>2)]=$830;
   var $833=$828 | 1;
   var $834=(($565+($833<<2))|0);
   var $835=HEAP32[(($834)>>2)];
   var $836=(($831+($708<<2))|0);
   HEAP32[(($836)>>2)]=$835;
   var $837=$828 | 2;
   var $838=(($565+($837<<2))|0);
   var $839=HEAP32[(($838)>>2)];
   var $840=(($831+($709<<2))|0);
   HEAP32[(($840)>>2)]=$839;
   var $841=(($831+($710<<2))|0);
   HEAP32[(($841)>>2)]=$maxi_i_2;
   var $712 = $801;label = 108; break;
  case 127: 
   if ($190) { var $i5_i_0_ph = 0;var $843 = $712;label = 128; break; } else { var $943 = $712;label = 140; break; }
  case 128: 
   var $843;
   var $i5_i_0_ph;
   var $844=((($i5_i_0_ph)+(1))|0);
   var $845=$i5_i_0_ph << 2;
   var $846=$845 | 2;
   var $847=$845 | 3;
   var $848=((($845)+(4))|0);
   var $849=((($845)+(5))|0);
   var $850=((($845)+(6))|0);
   var $851=((($845)+(7))|0);
   var $853 = $843;label = 129; break;
  case 129: 
   var $853;
   var $854=((((($853)|(0)))/(4))&-1);
   var $855=(($i5_i_0_ph)|(0)) < (($854)|(0));
   if ($855) { label = 130; break; } else { var $943 = $853;label = 140; break; }
  case 130: 
   var $857=((((($844)|(0)))%((($854)|(0))))&-1);
   var $858=HEAP32[(($180)>>2)];
   var $859=(($858+($845<<2))|0);
   var $860=HEAP32[(($859)>>2)];
   var $861=(($858+($846<<2))|0);
   var $862=HEAP32[(($861)>>2)];
   var $863=(($858+($847<<2))|0);
   var $864=HEAP32[(($863)>>2)];
   var $865=$857 << 2;
   var $866=(($858+($865<<2))|0);
   var $867=HEAP32[(($866)>>2)];
   var $868=$865 | 2;
   var $869=(($858+($868<<2))|0);
   var $870=HEAP32[(($869)>>2)];
   var $871=$865 | 3;
   var $872=(($858+($871<<2))|0);
   var $873=HEAP32[(($872)>>2)];
   var $874=((($864)+(1))|0);
   var $875=((((($874)|(0)))%((($700)|(0))))&-1);
   var $876=$875 << 2;
   var $877=$876 | 3;
   var $878=(($565+($877<<2))|0);
   var $879=HEAP32[(($878)>>2)];
   var $880=$879 & 65535;
   var $881=(($880)|(0))==0;
   if ($881) { label = 131; break; } else { var $i5_i_0_ph = $844;var $843 = $853;label = 128; break; }
  case 131: 
   var $883=((($867)-($860))|0);
   var $884=((($870)-($862))|0);
   var $885=(Math.imul($883,$883)|0);
   var $886=(Math.imul($884,$884)|0);
   var $887=((($885)+($886))|0);
   var $888=(($887)|(0)) > (($191)|(0));
   if ($888) { label = 132; break; } else { var $i5_i_0_ph = $844;var $843 = $853;label = 128; break; }
  case 132: 
   var $890=(($873)|(0)) < (($864)|(0));
   var $891=((($873)+($700))|0);
   var $_1084=$890 ? $891 : $873;
   var $892=((($_1084)-($864))|0);
   var $893=(($892)|(0)) > 1;
   if ($893) { label = 133; break; } else { var $i5_i_0_ph = $844;var $843 = $853;label = 128; break; }
  case 133: 
   var $895=(($867)|(0)) > (($860)|(0));
   if ($895) { var $_pn1066_in = $892;label = 135; break; } else { label = 134; break; }
  case 134: 
   var $897=(($867)|(0))==(($860)|(0));
   var $898=(($870)|(0)) > (($862)|(0));
   var $or_cond1085=$897 & $898;
   var $899=((($892)+(1))|0);
   var $_1087=$or_cond1085 ? $892 : $899;
   var $_pn1066_in = $_1087;label = 135; break;
  case 135: 
   var $_pn1066_in;
   var $_pn1066=((((($_pn1066_in)|(0)))/(2))&-1);
   var $_pn1062=((($864)+($_pn1066))|0);
   var $storemerge3_i=((((($_pn1062)|(0)))%((($700)|(0))))&-1);
   var $phitmp1065=(($storemerge3_i)|(0))==-1;
   if ($phitmp1065) { var $i5_i_0_ph = $844;var $843 = $853;label = 128; break; } else { label = 136; break; }
  case 136: 
   var $901=((($853)+(4))|0);
   __ZN10rcIntArray6resizeEi($simplified, $901);
   var $902=HEAP32[(($181)>>2)];
   var $903=((((($902)|(0)))/(4))&-1);
   var $storemerge2_in_i = $903;label = 137; break;
  case 137: 
   var $storemerge2_in_i;
   var $storemerge2_i49=((($storemerge2_in_i)-(1))|0);
   var $905=(($storemerge2_i49)|(0)) > (($i5_i_0_ph)|(0));
   if ($905) { label = 138; break; } else { label = 139; break; }
  case 138: 
   var $907=$storemerge2_i49 << 2;
   var $908=((($907)-(4))|0);
   var $909=HEAP32[(($180)>>2)];
   var $910=(($909+($908<<2))|0);
   var $911=HEAP32[(($910)>>2)];
   var $912=(($909+($907<<2))|0);
   HEAP32[(($912)>>2)]=$911;
   var $913=((($907)-(3))|0);
   var $914=(($909+($913<<2))|0);
   var $915=HEAP32[(($914)>>2)];
   var $916=$907 | 1;
   var $917=(($909+($916<<2))|0);
   HEAP32[(($917)>>2)]=$915;
   var $918=((($907)-(2))|0);
   var $919=(($909+($918<<2))|0);
   var $920=HEAP32[(($919)>>2)];
   var $921=$907 | 2;
   var $922=(($909+($921<<2))|0);
   HEAP32[(($922)>>2)]=$920;
   var $923=((($907)-(1))|0);
   var $924=(($909+($923<<2))|0);
   var $925=HEAP32[(($924)>>2)];
   var $926=$907 | 3;
   var $927=(($909+($926<<2))|0);
   HEAP32[(($927)>>2)]=$925;
   var $storemerge2_in_i = $storemerge2_i49;label = 137; break;
  case 139: 
   var $929=$storemerge3_i << 2;
   var $930=(($565+($929<<2))|0);
   var $931=HEAP32[(($930)>>2)];
   var $932=HEAP32[(($180)>>2)];
   var $933=(($932+($848<<2))|0);
   HEAP32[(($933)>>2)]=$931;
   var $934=$929 | 1;
   var $935=(($565+($934<<2))|0);
   var $936=HEAP32[(($935)>>2)];
   var $937=(($932+($849<<2))|0);
   HEAP32[(($937)>>2)]=$936;
   var $938=$929 | 2;
   var $939=(($565+($938<<2))|0);
   var $940=HEAP32[(($939)>>2)];
   var $941=(($932+($850<<2))|0);
   HEAP32[(($941)>>2)]=$940;
   var $942=(($932+($851<<2))|0);
   HEAP32[(($942)>>2)]=$storemerge3_i;
   var $853 = $902;label = 129; break;
  case 140: 
   var $943;
   var $storemerge1_i50 = 0;label = 141; break;
  case 141: 
   var $storemerge1_i50;
   var $945=((((($943)|(0)))/(4))&-1);
   var $946=(($storemerge1_i50)|(0)) < (($945)|(0));
   if ($946) { label = 142; break; } else { var $storemerge_i54 = 0;var $968 = $943;label = 143; break; }
  case 142: 
   var $948=$storemerge1_i50 << 2;
   var $949=$948 | 3;
   var $950=HEAP32[(($180)>>2)];
   var $951=(($950+($949<<2))|0);
   var $952=HEAP32[(($951)>>2)];
   var $953=((($952)+(1))|0);
   var $954=((((($953)|(0)))%((($700)|(0))))&-1);
   var $955=$954 << 2;
   var $956=$955 | 3;
   var $957=(($565+($956<<2))|0);
   var $958=HEAP32[(($957)>>2)];
   var $959=$958 & 196607;
   var $960=$952 << 2;
   var $961=$960 | 3;
   var $962=(($565+($961<<2))|0);
   var $963=HEAP32[(($962)>>2)];
   var $964=$963 & 65536;
   var $965=$959 | $964;
   HEAP32[(($951)>>2)]=$965;
   var $966=((($storemerge1_i50)+(1))|0);
   var $storemerge1_i50 = $966;label = 141; break;
  case 143: 
   var $968;
   var $storemerge_i54;
   var $969=((((($968)|(0)))/(4))&-1);
   var $970=(($storemerge_i54)|(0)) < (($969)|(0));
   if ($970) { label = 144; break; } else { label = 149; break; }
  case 144: 
   var $971=((($storemerge_i54)+(1))|0);
   var $972=(($971)|(0)) < (($969)|(0));
   var $phitmp1061=$971 << 2;
   var $phitmp1061_=$972 ? $phitmp1061 : 0;
   var $973=$storemerge_i54 << 2;
   var $974=HEAP32[(($180)>>2)];
   var $975=(($974+($973<<2))|0);
   var $976=HEAP32[(($975)>>2)];
   var $977=(($974+($phitmp1061_<<2))|0);
   var $978=HEAP32[(($977)>>2)];
   var $979=(($976)|(0))==(($978)|(0));
   if ($979) { label = 145; break; } else { var $storemerge_i54 = $971;var $968 = $968;label = 143; break; }
  case 145: 
   var $981=$973 | 2;
   var $982=(($974+($981<<2))|0);
   var $983=HEAP32[(($982)>>2)];
   var $984=$phitmp1061_ | 2;
   var $985=(($974+($984<<2))|0);
   var $986=HEAP32[(($985)>>2)];
   var $987=(($983)|(0))==(($986)|(0));
   if ($987) { var $storemerge1_i55 = $storemerge_i54;label = 146; break; } else { var $storemerge_i54 = $971;var $968 = $968;label = 143; break; }
  case 146: 
   var $storemerge1_i55;
   var $989=((($969)-(1))|0);
   var $990=(($storemerge1_i55)|(0)) < (($989)|(0));
   if ($990) { label = 147; break; } else { label = 148; break; }
  case 147: 
   var $992=$storemerge1_i55 << 2;
   var $993=((($992)+(4))|0);
   var $994=(($974+($993<<2))|0);
   var $995=HEAP32[(($994)>>2)];
   var $996=(($974+($992<<2))|0);
   HEAP32[(($996)>>2)]=$995;
   var $997=((($992)+(5))|0);
   var $998=(($974+($997<<2))|0);
   var $999=HEAP32[(($998)>>2)];
   var $1000=$992 | 1;
   var $1001=(($974+($1000<<2))|0);
   HEAP32[(($1001)>>2)]=$999;
   var $1002=((($992)+(6))|0);
   var $1003=(($974+($1002<<2))|0);
   var $1004=HEAP32[(($1003)>>2)];
   var $1005=$992 | 2;
   var $1006=(($974+($1005<<2))|0);
   HEAP32[(($1006)>>2)]=$1004;
   var $1007=((($992)+(7))|0);
   var $1008=(($974+($1007<<2))|0);
   var $1009=HEAP32[(($1008)>>2)];
   var $1010=$992 | 3;
   var $1011=(($974+($1010<<2))|0);
   HEAP32[(($1011)>>2)]=$1009;
   var $1012=((($storemerge1_i55)+(1))|0);
   var $storemerge1_i55 = $1012;label = 146; break;
  case 148: 
   var $1014=((($968)-(4))|0);
   __ZN10rcIntArray6resizeEi($simplified, $1014);
   var $_pre_pre=HEAP32[(($181)>>2)];
   var $storemerge_i54 = $971;var $968 = $_pre_pre;label = 143; break;
  case 149: 
   var $1016=HEAP8[($7)];
   var $1017=$1016 & 1;
   var $1018=(($1017 << 24) >> 24)==0;
   if ($1018) { label = 151; break; } else { label = 150; break; }
  case 150: 
   var $1020=HEAP32[(($_pre_phi1039)>>2)];
   var $1021=(($1020+24)|0);
   var $1022=HEAP32[(($1021)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$1022]($ctx, 6) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 151; break; } else { label = 42; break; }
  case 151: 
   var $1024=(($968)|(0)) > 11;
   if ($1024) { label = 152; break; } else { var $maxContours_4 = $maxContours_2;label = 171; break; }
  case 152: 
   var $1026=HEAP32[(($75)>>2)];
   var $1027=(($1026)|(0)) < (($maxContours_2)|(0));
   if ($1027) { var $maxContours_3 = $maxContours_2;var $1054 = $1026;label = 160; break; } else { label = 153; break; }
  case 153: 
   var $1029=$maxContours_2 << 1;
   var $1030=((($maxContours_2)*(40))&-1);
   var $1031=_malloc($1030);
   var $1032=$1031;
   var $storemerge7 = 0;label = 154; break;
  case 154: 
   var $storemerge7;
   var $1034=HEAP32[(($75)>>2)];
   var $1035=(($storemerge7)|(0)) < (($1034)|(0));
   if ($1035) { label = 155; break; } else { label = 156; break; }
  case 155: 
   var $1037=(($1032+((($storemerge7)*(20))&-1))|0);
   var $1038=HEAP32[(($72)>>2)];
   var $1039=(($1038+((($storemerge7)*(20))&-1))|0);
   var $1040=$1037;
   var $1041=$1039;
   assert(20 % 1 === 0);HEAP32[(($1040)>>2)]=HEAP32[(($1041)>>2)];HEAP32[((($1040)+(4))>>2)]=HEAP32[((($1041)+(4))>>2)];HEAP32[((($1040)+(8))>>2)]=HEAP32[((($1041)+(8))>>2)];HEAP32[((($1040)+(12))>>2)]=HEAP32[((($1041)+(12))>>2)];HEAP32[((($1040)+(16))>>2)]=HEAP32[((($1041)+(16))>>2)];
   var $1042=HEAP32[(($72)>>2)];
   var $1043=(($1042+((($storemerge7)*(20))&-1))|0);
   HEAP32[(($1043)>>2)]=0;
   var $1044=HEAP32[(($72)>>2)];
   var $1045=(($1044+((($storemerge7)*(20))&-1)+8)|0);
   HEAP32[(($1045)>>2)]=0;
   var $1046=((($storemerge7)+(1))|0);
   var $storemerge7 = $1046;label = 154; break;
  case 156: 
   var $1048=HEAP32[(($72)>>2)];
   var $1049=(($1048)|(0))==0;
   if ($1049) { label = 158; break; } else { label = 157; break; }
  case 157: 
   var $1051=$1048;
   _free($1051);
   label = 158; break;
  case 158: 
   HEAP32[(($72)>>2)]=$1032;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((5952)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxContours_2,HEAP32[(((tempVarArgs)+(8))>>2)]=$1029,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 159; break; } else { label = 42; break; }
  case 159: 
   var $_pre1034=HEAP32[(($75)>>2)];
   var $maxContours_3 = $1029;var $1054 = $_pre1034;label = 160; break;
  case 160: 
   var $1054;
   var $maxContours_3;
   var $1055=((($1054)+(1))|0);
   HEAP32[(($75)>>2)]=$1055;
   var $1056=HEAP32[(($72)>>2)];
   var $1057=(($1056+((($1054)*(20))&-1)+4)|0);
   HEAP32[(($1057)>>2)]=$969;
   var $1058=$969 << 4;
   var $1059=_malloc($1058);
   var $1060=$1059;
   var $1061=(($1056+((($1054)*(20))&-1))|0);
   HEAP32[(($1061)>>2)]=$1060;
   var $1062=(($1059)|(0))==0;
   if ($1062) { label = 161; break; } else { label = 162; break; }
  case 161: 
   var $1064=HEAP32[(($1057)>>2)];
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4776)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1064,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_0996 = 0;label = 215; break; } else { label = 43; break; }
  case 162: 
   var $1066=HEAP32[(($180)>>2)];
   var $1067=$1066;
   var $1068=HEAP32[(($1057)>>2)];
   var $1069=$1068 << 4;
   assert($1069 % 1 === 0);(_memcpy($1059, $1067, $1069)|0);
   if ($34) { var $storemerge6 = 0;label = 163; break; } else { label = 165; break; }
  case 163: 
   var $storemerge6;
   var $1070=HEAP32[(($1057)>>2)];
   var $1071=(($storemerge6)|(0)) < (($1070)|(0));
   if ($1071) { label = 164; break; } else { label = 165; break; }
  case 164: 
   var $1073=$storemerge6 << 2;
   var $1074=HEAP32[(($1061)>>2)];
   var $1075=(($1074+($1073<<2))|0);
   var $1076=HEAP32[(($1075)>>2)];
   var $1077=((($1076)-($6))|0);
   HEAP32[(($1075)>>2)]=$1077;
   var $_sum1060=$1073 | 2;
   var $1078=(($1074+($_sum1060<<2))|0);
   var $1079=HEAP32[(($1078)>>2)];
   var $1080=((($1079)-($6))|0);
   HEAP32[(($1078)>>2)]=$1080;
   var $1081=((($storemerge6)+(1))|0);
   var $storemerge6 = $1081;label = 163; break;
  case 165: 
   var $1082=(($1056+((($1054)*(20))&-1)+12)|0);
   HEAP32[(($1082)>>2)]=$700;
   var $1083=$700 << 4;
   var $1084=_malloc($1083);
   var $1085=$1084;
   var $1086=(($1056+((($1054)*(20))&-1)+8)|0);
   HEAP32[(($1086)>>2)]=$1085;
   var $1087=(($1084)|(0))==0;
   if ($1087) { label = 166; break; } else { label = 167; break; }
  case 166: 
   var $1089=HEAP32[(($1082)>>2)];
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3800)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1089,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_0996 = 0;label = 215; break; } else { label = 43; break; }
  case 167: 
   var $1091=$565;
   var $1092=HEAP32[(($1082)>>2)];
   var $1093=$1092 << 4;
   assert($1093 % 1 === 0);(_memcpy($1084, $1091, $1093)|0);
   if ($34) { var $storemerge5 = 0;label = 168; break; } else { label = 170; break; }
  case 168: 
   var $storemerge5;
   var $1094=HEAP32[(($1082)>>2)];
   var $1095=(($storemerge5)|(0)) < (($1094)|(0));
   if ($1095) { label = 169; break; } else { label = 170; break; }
  case 169: 
   var $1097=$storemerge5 << 2;
   var $1098=HEAP32[(($1086)>>2)];
   var $1099=(($1098+($1097<<2))|0);
   var $1100=HEAP32[(($1099)>>2)];
   var $1101=((($1100)-($6))|0);
   HEAP32[(($1099)>>2)]=$1101;
   var $_sum1059=$1097 | 2;
   var $1102=(($1098+($_sum1059<<2))|0);
   var $1103=HEAP32[(($1102)>>2)];
   var $1104=((($1103)-($6))|0);
   HEAP32[(($1102)>>2)]=$1104;
   var $1105=((($storemerge5)+(1))|0);
   var $storemerge5 = $1105;label = 168; break;
  case 170: 
   var $1106=(($1056+((($1054)*(20))&-1)+16)|0);
   HEAP16[(($1106)>>1)]=$221;
   var $1107=(($1056+((($1054)*(20))&-1)+18)|0);
   HEAP8[($1107)]=$227;
   var $maxContours_4 = $maxContours_3;label = 171; break;
  case 171: 
   var $maxContours_4;
   var $1109=((($i4_0)+(1))|0);
   var $i4_0 = $1109;var $maxContours_2 = $maxContours_4;label = 38; break;
  case 172: 
   var $1111=((($storemerge4)+(1))|0);
   var $storemerge4 = $1111;var $maxContours_1 = $maxContours_2;label = 36; break;
  case 173: 
   var $1113=((($storemerge1)+(1))|0);
   var $storemerge1 = $1113;var $maxContours_0 = $maxContours_1;label = 34; break;
  case 174: 
   var $storemerge2;
   var $1114=HEAP32[(($75)>>2)];
   var $1115=(($storemerge2)|(0)) < (($1114)|(0));
   if ($1115) { label = 175; break; } else { label = 213; break; }
  case 175: 
   var $1117=HEAP32[(($72)>>2)];
   var $1118=(($1117+((($storemerge2)*(20))&-1))|0);
   var $1119=HEAP32[(($1118)>>2)];
   var $1120=(($1117+((($storemerge2)*(20))&-1)+4)|0);
   var $1121=HEAP32[(($1120)>>2)];
   var $1122=((($1121)-(1))|0);
   var $storemerge_i27 = $1122;var $area_i23_0 = 0;var $i_i24_0 = 0;label = 176; break;
  case 176: 
   var $i_i24_0;
   var $area_i23_0;
   var $storemerge_i27;
   var $1124=(($i_i24_0)|(0)) < (($1121)|(0));
   if ($1124) { label = 177; break; } else { label = 178; break; }
  case 177: 
   var $1126=$i_i24_0 << 2;
   var $1127=(($1119+($1126<<2))|0);
   var $1128=$storemerge_i27 << 2;
   var $1129=(($1119+($1128<<2))|0);
   var $1130=HEAP32[(($1127)>>2)];
   var $_sum1_i28=$1128 | 2;
   var $1131=(($1119+($_sum1_i28<<2))|0);
   var $1132=HEAP32[(($1131)>>2)];
   var $1133=(Math.imul($1130,$1132)|0);
   var $1134=HEAP32[(($1129)>>2)];
   var $_sum1058=$1126 | 2;
   var $1135=(($1119+($_sum1058<<2))|0);
   var $1136=HEAP32[(($1135)>>2)];
   var $1137=(Math.imul($1134,$1136)|0);
   var $1138=((($1133)-($1137))|0);
   var $1139=((($area_i23_0)+($1138))|0);
   var $1140=((($i_i24_0)+(1))|0);
   var $storemerge_i27 = $i_i24_0;var $area_i23_0 = $1139;var $i_i24_0 = $1140;label = 176; break;
  case 178: 
   var $1142=((($area_i23_0)+(1))|0);
   var $1143=(($1142)|(0)) < -1;
   if ($1143) { label = 179; break; } else { label = 212; break; }
  case 179: 
   var $1145=(($1117+((($storemerge2)*(20))&-1)+16)|0);
   var $storemerge3 = 0;label = 180; break;
  case 180: 
   var $storemerge3;
   var $1147=(($storemerge3)|(0)) < (($1114)|(0));
   if ($1147) { label = 181; break; } else { label = 190; break; }
  case 181: 
   var $1149=(($storemerge2)|(0))==(($storemerge3)|(0));
   if ($1149) { label = 188; break; } else { label = 182; break; }
  case 182: 
   var $1151=(($1117+((($storemerge3)*(20))&-1)+4)|0);
   var $1152=HEAP32[(($1151)>>2)];
   var $1153=(($1152)|(0))==0;
   if ($1153) { label = 188; break; } else { label = 183; break; }
  case 183: 
   var $1155=(($1117+((($storemerge3)*(20))&-1)+16)|0);
   var $1156=HEAP16[(($1155)>>1)];
   var $1157=HEAP16[(($1145)>>1)];
   var $1158=(($1156 << 16) >> 16)==(($1157 << 16) >> 16);
   if ($1158) { label = 184; break; } else { label = 188; break; }
  case 184: 
   var $1160=(($1117+((($storemerge3)*(20))&-1))|0);
   var $1161=HEAP32[(($1160)>>2)];
   var $1162=((($1152)-(1))|0);
   var $storemerge_i22 = $1162;var $area_i_0 = 0;var $i_i20_0 = 0;label = 185; break;
  case 185: 
   var $i_i20_0;
   var $area_i_0;
   var $storemerge_i22;
   var $1164=(($i_i20_0)|(0)) < (($1152)|(0));
   if ($1164) { label = 186; break; } else { label = 187; break; }
  case 186: 
   var $1166=$i_i20_0 << 2;
   var $1167=(($1161+($1166<<2))|0);
   var $1168=$storemerge_i22 << 2;
   var $1169=(($1161+($1168<<2))|0);
   var $1170=HEAP32[(($1167)>>2)];
   var $_sum1_i=$1168 | 2;
   var $1171=(($1161+($_sum1_i<<2))|0);
   var $1172=HEAP32[(($1171)>>2)];
   var $1173=(Math.imul($1170,$1172)|0);
   var $1174=HEAP32[(($1169)>>2)];
   var $_sum1057=$1166 | 2;
   var $1175=(($1161+($_sum1057<<2))|0);
   var $1176=HEAP32[(($1175)>>2)];
   var $1177=(Math.imul($1174,$1176)|0);
   var $1178=((($1173)-($1177))|0);
   var $1179=((($area_i_0)+($1178))|0);
   var $1180=((($i_i20_0)+(1))|0);
   var $storemerge_i22 = $i_i20_0;var $area_i_0 = $1179;var $i_i20_0 = $1180;label = 185; break;
  case 187: 
   var $_off=((($area_i_0)+(2))|0);
   var $1182=(($_off)>>>(0)) < 3;
   if ($1182) { label = 188; break; } else { var $mergeIdx_0 = $storemerge3;label = 189; break; }
  case 188: 
   var $1184=((($storemerge3)+(1))|0);
   var $storemerge3 = $1184;label = 180; break;
  case 189: 
   var $mergeIdx_0;
   var $1185=(($mergeIdx_0)|(0))==-1;
   if ($1185) { label = 190; break; } else { label = 191; break; }
  case 190: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((2720)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge2,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 212; break; } else { label = 41; break; }
  case 191: 
   var $1187=(($1117+((($mergeIdx_0)*(20))&-1))|0);
   var $1188=HEAP32[(($1187)>>2)];
   var $1189=(($1117+((($mergeIdx_0)*(20))&-1)+4)|0);
   var $1190=HEAP32[(($1189)>>2)];
   var $1191=(($1117+((($storemerge2)*(20))&-1)+4)|0);
   var $storemerge_i18 = 0;var $closestDist_i_0 = 268435455;var $ia_0 = -1;var $ib_0 = -1;label = 192; break;
  case 192: 
   var $ib_0;
   var $ia_0;
   var $closestDist_i_0;
   var $storemerge_i18;
   var $1193=(($storemerge_i18)|(0)) < (($1190)|(0));
   if ($1193) { label = 193; break; } else { label = 199; break; }
  case 193: 
   var $1195=((($storemerge_i18)+(1))|0);
   var $1196=((((($1195)|(0)))%((($1190)|(0))))&-1);
   var $1197=((($storemerge_i18)+($1190))|0);
   var $1198=((($1197)-(1))|0);
   var $1199=((((($1198)|(0)))%((($1190)|(0))))&-1);
   var $1200=$storemerge_i18 << 2;
   var $1201=(($1188+($1200<<2))|0);
   var $1202=$1196 << 2;
   var $1203=(($1188+($1202<<2))|0);
   var $1204=$1199 << 2;
   var $1205=(($1188+($1204<<2))|0);
   var $_sum1054=$1204 | 2;
   var $1206=(($1188+($_sum1054<<2))|0);
   var $_sum1055=$1200 | 2;
   var $1207=(($1188+($_sum1055<<2))|0);
   var $_sum1056=$1202 | 2;
   var $1208=(($1188+($_sum1056<<2))|0);
   var $storemerge1_i19 = 0;var $closestDist_i_1 = $closestDist_i_0;var $ia_1 = $ia_0;var $ib_1 = $ib_0;label = 194; break;
  case 194: 
   var $ib_1;
   var $ia_1;
   var $closestDist_i_1;
   var $storemerge1_i19;
   var $1210=(($storemerge1_i19)|(0)) < (($1121)|(0));
   if ($1210) { label = 195; break; } else { var $storemerge_i18 = $1195;var $closestDist_i_0 = $closestDist_i_1;var $ia_0 = $ia_1;var $ib_0 = $ib_1;label = 192; break; }
  case 195: 
   var $1212=$storemerge1_i19 << 2;
   var $1213=(($1119+($1212<<2))|0);
   var $1214=HEAP32[(($1201)>>2)];
   var $1215=HEAP32[(($1205)>>2)];
   var $1216=((($1214)-($1215))|0);
   var $_sum58=$1212 | 2;
   var $1217=(($1119+($_sum58<<2))|0);
   var $1218=HEAP32[(($1217)>>2)];
   var $1219=HEAP32[(($1206)>>2)];
   var $1220=((($1218)-($1219))|0);
   var $1221=(Math.imul($1216,$1220)|0);
   var $1222=HEAP32[(($1213)>>2)];
   var $1223=((($1222)-($1215))|0);
   var $1224=HEAP32[(($1207)>>2)];
   var $1225=((($1224)-($1219))|0);
   var $1226=(Math.imul($1223,$1225)|0);
   var $1227=((($1221)-($1226))|0);
   var $1228=(($1227)|(0)) < 1;
   if ($1228) { label = 196; break; } else { var $closestDist_i_2 = $closestDist_i_1;var $ia_2 = $ia_1;var $ib_2 = $ib_1;label = 198; break; }
  case 196: 
   var $1230=HEAP32[(($1203)>>2)];
   var $1231=((($1230)-($1214))|0);
   var $1232=((($1218)-($1224))|0);
   var $1233=(Math.imul($1231,$1232)|0);
   var $1234=((($1222)-($1214))|0);
   var $1235=HEAP32[(($1208)>>2)];
   var $1236=((($1235)-($1224))|0);
   var $1237=(Math.imul($1234,$1236)|0);
   var $1238=((($1233)-($1237))|0);
   var $1239=(($1238)|(0)) < 1;
   if ($1239) { label = 197; break; } else { var $closestDist_i_2 = $closestDist_i_1;var $ia_2 = $ia_1;var $ib_2 = $ib_1;label = 198; break; }
  case 197: 
   var $1241=(Math.imul($1234,$1234)|0);
   var $1242=(Math.imul($1232,$1232)|0);
   var $1243=((($1241)+($1242))|0);
   var $1244=(($1243)|(0)) < (($closestDist_i_1)|(0));
   var $storemerge1_i19_ib_1=$1244 ? $storemerge1_i19 : $ib_1;
   var $storemerge_i18_ia_1=$1244 ? $storemerge_i18 : $ia_1;
   var $_closestDist_i_1=$1244 ? $1243 : $closestDist_i_1;
   var $closestDist_i_2 = $_closestDist_i_1;var $ia_2 = $storemerge_i18_ia_1;var $ib_2 = $storemerge1_i19_ib_1;label = 198; break;
  case 198: 
   var $ib_2;
   var $ia_2;
   var $closestDist_i_2;
   var $1246=((($storemerge1_i19)+(1))|0);
   var $storemerge1_i19 = $1246;var $closestDist_i_1 = $closestDist_i_2;var $ia_1 = $ia_2;var $ib_1 = $ib_2;label = 194; break;
  case 199: 
   var $1248=(($ia_0)|(0))==-1;
   var $1249=(($ib_0)|(0))==-1;
   var $or_cond1086=$1248 | $1249;
   if ($or_cond1086) { label = 200; break; } else { label = 201; break; }
  case 200: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((1976)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge2,HEAP32[(((tempVarArgs)+(8))>>2)]=$mergeIdx_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 212; break; } else { label = 41; break; }
  case 201: 
   var $1252=(($1117+((($mergeIdx_0)*(20))&-1)+4)|0);
   var $1253=((($1190)+($1121))|0);
   var $1254=$1253 << 4;
   var $1255=((($1254)+(32))|0);
   var $1256=_malloc($1255);
   var $1257=$1256;
   var $1258=(($1256)|(0))==0;
   if ($1258) { label = 211; break; } else { var $storemerge_i = 0;var $nv_i_0 = 0;label = 202; break; }
  case 202: 
   var $nv_i_0;
   var $storemerge_i;
   var $1260=HEAP32[(($1252)>>2)];
   var $1261=(($storemerge_i)|(0)) > (($1260)|(0));
   if ($1261) { var $storemerge1_i = 0;var $nv_i_1 = $nv_i_0;label = 204; break; } else { label = 203; break; }
  case 203: 
   var $1263=$nv_i_0 << 2;
   var $1264=(($1257+($1263<<2))|0);
   var $1265=((($ia_0)+($storemerge_i))|0);
   var $1266=((((($1265)|(0)))%((($1260)|(0))))&-1);
   var $1267=$1266 << 2;
   var $1268=HEAP32[(($1187)>>2)];
   var $1269=(($1268+($1267<<2))|0);
   var $1270=HEAP32[(($1269)>>2)];
   HEAP32[(($1264)>>2)]=$1270;
   var $_sum1042=$1267 | 1;
   var $1271=(($1268+($_sum1042<<2))|0);
   var $1272=HEAP32[(($1271)>>2)];
   var $_sum1043=$1263 | 1;
   var $1273=(($1257+($_sum1043<<2))|0);
   HEAP32[(($1273)>>2)]=$1272;
   var $_sum1044=$1267 | 2;
   var $1274=(($1268+($_sum1044<<2))|0);
   var $1275=HEAP32[(($1274)>>2)];
   var $_sum1045=$1263 | 2;
   var $1276=(($1257+($_sum1045<<2))|0);
   HEAP32[(($1276)>>2)]=$1275;
   var $_sum1046=$1267 | 3;
   var $1277=(($1268+($_sum1046<<2))|0);
   var $1278=HEAP32[(($1277)>>2)];
   var $_sum1047=$1263 | 3;
   var $1279=(($1257+($_sum1047<<2))|0);
   HEAP32[(($1279)>>2)]=$1278;
   var $1280=((($nv_i_0)+(1))|0);
   var $1281=((($storemerge_i)+(1))|0);
   var $storemerge_i = $1281;var $nv_i_0 = $1280;label = 202; break;
  case 204: 
   var $nv_i_1;
   var $storemerge1_i;
   var $1282=HEAP32[(($1191)>>2)];
   var $1283=(($storemerge1_i)|(0)) > (($1282)|(0));
   if ($1283) { label = 206; break; } else { label = 205; break; }
  case 205: 
   var $1285=$nv_i_1 << 2;
   var $1286=(($1257+($1285<<2))|0);
   var $1287=((($ib_0)+($storemerge1_i))|0);
   var $1288=((((($1287)|(0)))%((($1282)|(0))))&-1);
   var $1289=$1288 << 2;
   var $1290=HEAP32[(($1118)>>2)];
   var $1291=(($1290+($1289<<2))|0);
   var $1292=HEAP32[(($1291)>>2)];
   HEAP32[(($1286)>>2)]=$1292;
   var $_sum1048=$1289 | 1;
   var $1293=(($1290+($_sum1048<<2))|0);
   var $1294=HEAP32[(($1293)>>2)];
   var $_sum1049=$1285 | 1;
   var $1295=(($1257+($_sum1049<<2))|0);
   HEAP32[(($1295)>>2)]=$1294;
   var $_sum1050=$1289 | 2;
   var $1296=(($1290+($_sum1050<<2))|0);
   var $1297=HEAP32[(($1296)>>2)];
   var $_sum1051=$1285 | 2;
   var $1298=(($1257+($_sum1051<<2))|0);
   HEAP32[(($1298)>>2)]=$1297;
   var $_sum1052=$1289 | 3;
   var $1299=(($1290+($_sum1052<<2))|0);
   var $1300=HEAP32[(($1299)>>2)];
   var $_sum1053=$1285 | 3;
   var $1301=(($1257+($_sum1053<<2))|0);
   HEAP32[(($1301)>>2)]=$1300;
   var $1302=((($nv_i_1)+(1))|0);
   var $1303=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $1303;var $nv_i_1 = $1302;label = 204; break;
  case 206: 
   var $1305=HEAP32[(($1187)>>2)];
   var $1306=(($1305)|(0))==0;
   if ($1306) { label = 208; break; } else { label = 207; break; }
  case 207: 
   var $1308=$1305;
   _free($1308);
   label = 208; break;
  case 208: 
   HEAP32[(($1187)>>2)]=$1257;
   HEAP32[(($1252)>>2)]=$nv_i_1;
   var $1309=HEAP32[(($1118)>>2)];
   var $1310=(($1309)|(0))==0;
   if ($1310) { label = 210; break; } else { label = 209; break; }
  case 209: 
   var $1312=$1309;
   _free($1312);
   label = 210; break;
  case 210: 
   HEAP32[(($1118)>>2)]=0;
   HEAP32[(($1191)>>2)]=0;
   label = 212; break;
  case 211: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((1288)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge2,HEAP32[(((tempVarArgs)+(8))>>2)]=$mergeIdx_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 212; break; } else { label = 41; break; }
  case 212: 
   var $1315=((($storemerge2)+(1))|0);
   var $storemerge2 = $1315;label = 174; break;
  case 213: 
   var $1317=HEAP8[($7)];
   var $1318=$1317 & 1;
   var $1319=(($1318 << 24) >> 24)==0;
   if ($1319) { var $_0996 = 1;label = 215; break; } else { label = 214; break; }
  case 214: 
   var $1321=HEAP32[(($_pre_phi1039)>>2)];
   var $1322=(($1321+24)|0);
   var $1323=HEAP32[(($1322)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$1323]($ctx, 4) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $_0996 = 1;label = 215; break; } else { label = 43; break; }
  case 215: 
   var $_0996;
   var $1325=HEAP32[(($180)>>2)];
   var $1326=(($1325)|(0))==0;
   if ($1326) { label = 217; break; } else { label = 216; break; }
  case 216: 
   var $1328=$1325;
   _free($1328);
   label = 217; break;
  case 217: 
   var $1329=HEAP32[(($177)>>2)];
   var $1330=(($1329)|(0))==0;
   if ($1330) { label = 221; break; } else { label = 218; break; }
  case 218: 
   var $1332=$1329;
   _free($1332);
   label = 221; break;
  case 219: 
   var $1333=HEAP32[(($177)>>2)];
   var $1334=(($1333)|(0))==0;
   if ($1334) { var $_0992 = $213;var $_0993 = $212;label = 223; break; } else { label = 220; break; }
  case 220: 
   var $1336=$1333;
   _free($1336);
   var $_0992 = $213;var $_0993 = $212;label = 223; break;
  case 221: 
   if ($79) { var $_2 = $_0996;label = 225; break; } else { label = 222; break; }
  case 222: 
   _free($78);
   var $_2 = $_0996;label = 225; break;
  case 223: 
   var $_0993;
   var $_0992;
   if ($79) { label = 226; break; } else { label = 224; break; }
  case 224: 
   _free($78);
   label = 226; break;
  case 225: 
   var $_2;
   STACKTOP = sp;
   return $_2;
  case 226: 
   var $1340$0=$_0993;
   var $1340$1=0;
   var $1341$0=$1340$0;
   var $1341$1=$_0992;
   ___resumeException($1341$0)
  default: assert(0, "bad label: " + label);
 }
}
function __Z35rcFilterLowHangingWalkableObstaclesP9rcContextiR13rcHeightfield($ctx, $walkableClimb, $solid) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 10);
   label = 3; break;
  case 3: 
   var $10=(($solid)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($solid+4)|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($solid+40)|0);
   var $storemerge = 0;label = 4; break;
  case 4: 
   var $storemerge;
   var $16=(($storemerge)|(0)) < (($13)|(0));
   if ($16) { label = 5; break; } else { label = 15; break; }
  case 5: 
   var $17=(Math.imul($storemerge,$11)|0);
   var $storemerge1 = 0;label = 6; break;
  case 6: 
   var $storemerge1;
   var $19=(($storemerge1)|(0)) < (($11)|(0));
   if ($19) { label = 7; break; } else { label = 14; break; }
  case 7: 
   var $21=((($storemerge1)+($17))|0);
   var $22=HEAP32[(($14)>>2)];
   var $23=(($22+($21<<2))|0);
   var $storemerge2_in = $23;var $ps_0 = 0;var $previousWalkable_0 = 0;var $previousArea_0 = 0;label = 8; break;
  case 8: 
   var $previousArea_0;
   var $previousWalkable_0;
   var $ps_0;
   var $storemerge2_in;
   var $storemerge2=HEAP32[(($storemerge2_in)>>2)];
   var $25=(($storemerge2)|(0))==0;
   if ($25) { label = 13; break; } else { label = 9; break; }
  case 9: 
   var $27=$storemerge2;
   var $28=HEAP32[(($27)>>2)];
   var $29=(($28)>>>(0)) > 67108863;
   var $30=(($29)&(1));
   var $31=(($previousWalkable_0 << 24) >> 24)==0;
   var $or_cond=$29 | $31;
   if ($or_cond) { var $46 = $28;label = 12; break; } else { label = 10; break; }
  case 10: 
   var $32=$28 >>> 13;
   var $33=$32 & 8191;
   var $34=HEAP32[(($ps_0)>>2)];
   var $35=$34 >>> 13;
   var $36=$35 & 8191;
   var $37=((($33)-($36))|0);
   var $38=(($37)|(0)) < 0;
   var $39=(((-$37))|0);
   var $40=$38 ? $39 : $37;
   var $41=(($40)|(0)) > (($walkableClimb)|(0));
   if ($41) { var $46 = $28;label = 12; break; } else { label = 11; break; }
  case 11: 
   var $43=$28 & 67108863;
   var $44=$43 | $previousArea_0;
   HEAP32[(($27)>>2)]=$44;
   var $46 = $44;label = 12; break;
  case 12: 
   var $46;
   var $47=$46 & -67108864;
   var $48=(($storemerge2+4)|0);
   var $phitmp=$storemerge2;
   var $storemerge2_in = $48;var $ps_0 = $phitmp;var $previousWalkable_0 = $30;var $previousArea_0 = $47;label = 8; break;
  case 13: 
   var $50=((($storemerge1)+(1))|0);
   var $storemerge1 = $50;label = 6; break;
  case 14: 
   var $52=((($storemerge)+(1))|0);
   var $storemerge = $52;label = 4; break;
  case 15: 
   var $54=HEAP8[($1)];
   var $55=$54 & 1;
   var $56=(($55 << 24) >> 24)==0;
   if ($56) { label = 17; break; } else { label = 16; break; }
  case 16: 
   var $58=$ctx;
   var $59=HEAP32[(($58)>>2)];
   var $60=(($59+24)|0);
   var $61=HEAP32[(($60)>>2)];
   FUNCTION_TABLE[$61]($ctx, 10);
   label = 17; break;
  case 17: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z18rcFilterLedgeSpansP9rcContextiiR13rcHeightfield($ctx, $walkableHeight, $walkableClimb, $solid) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 7);
   label = 3; break;
  case 3: 
   var $10=(($solid)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($solid+4)|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($solid+40)|0);
   var $15=(((-$walkableClimb))|0);
   var $storemerge = 0;label = 4; break;
  case 4: 
   var $storemerge;
   var $17=(($storemerge)|(0)) < (($13)|(0));
   if ($17) { label = 5; break; } else { label = 34; break; }
  case 5: 
   var $18=(Math.imul($storemerge,$11)|0);
   var $storemerge1 = 0;label = 6; break;
  case 6: 
   var $storemerge1;
   var $20=(($storemerge1)|(0)) < (($11)|(0));
   if ($20) { label = 7; break; } else { label = 33; break; }
  case 7: 
   var $22=((($storemerge1)+($18))|0);
   var $23=HEAP32[(($14)>>2)];
   var $24=(($23+($22<<2))|0);
   var $storemerge2_in = $24;label = 8; break;
  case 8: 
   var $storemerge2_in;
   var $storemerge2=HEAP32[(($storemerge2_in)>>2)];
   var $26=(($storemerge2)|(0))==0;
   if ($26) { label = 32; break; } else { label = 9; break; }
  case 9: 
   var $28=$storemerge2;
   var $29=HEAP32[(($28)>>2)];
   var $30=(($29)>>>(0)) < 67108864;
   if ($30) { label = 10; break; } else { label = 11; break; }
  case 10: 
   var $_pre=(($storemerge2+4)|0);
   var $storemerge2_in = $_pre;label = 8; break;
  case 11: 
   var $32=$29 >>> 13;
   var $33=$32 & 8191;
   var $34=(($storemerge2+4)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==0;
   if ($36) { var $42 = 65535;label = 13; break; } else { label = 12; break; }
  case 12: 
   var $38=$35;
   var $39=HEAP32[(($38)>>2)];
   var $40=$39 & 8191;
   var $42 = $40;label = 13; break;
  case 13: 
   var $42;
   var $43=((($15)-($33))|0);
   var $44=(($33)|(0)) > (($15)|(0));
   var $45=$44 ? $33 : $15;
   var $storemerge3 = 0;var $minh_0 = 65535;var $asmin_0 = $33;var $asmax_0 = $33;label = 14; break;
  case 14: 
   var $asmax_0;
   var $asmin_0;
   var $minh_0;
   var $storemerge3;
   var $47=(($storemerge3)|(0)) < 4;
   if ($47) { label = 15; break; } else { label = 28; break; }
  case 15: 
   var $49=$storemerge3 & 3;
   var $50=((6640+($49<<2))|0);
   var $51=HEAP32[(($50)>>2)];
   var $52=((($storemerge1)+($51))|0);
   var $53=((6624+($49<<2))|0);
   var $54=HEAP32[(($53)>>2)];
   var $55=((($storemerge)+($54))|0);
   var $56=(($52)|(0)) < 0;
   var $57=(($55)|(0)) < 0;
   var $or_cond=$56 | $57;
   var $or_cond_not=$or_cond ^ 1;
   var $58=(($52)|(0)) < (($11)|(0));
   var $or_cond70=$or_cond_not & $58;
   var $59=(($55)|(0)) < (($13)|(0));
   var $or_cond71=$or_cond70 & $59;
   if ($or_cond71) { label = 17; break; } else { label = 16; break; }
  case 16: 
   var $61=(($minh_0)|(0)) < (($43)|(0));
   var $62=$61 ? $minh_0 : $43;
   var $minh_4 = $62;var $asmin_4 = $asmin_0;var $asmax_3 = $asmax_0;label = 27; break;
  case 17: 
   var $64=(Math.imul($55,$11)|0);
   var $65=((($52)+($64))|0);
   var $66=HEAP32[(($14)>>2)];
   var $67=(($66+($65<<2))|0);
   var $68=HEAP32[(($67)>>2)];
   var $69=(($68)|(0))==0;
   if ($69) { var $75 = 65535;label = 19; break; } else { label = 18; break; }
  case 18: 
   var $71=$68;
   var $72=HEAP32[(($71)>>2)];
   var $73=$72 & 8191;
   var $75 = $73;label = 19; break;
  case 19: 
   var $75;
   var $76=(($42)>>>(0)) < (($75)>>>(0));
   var $77=$76 ? $42 : $75;
   var $78=((($77)-($45))|0);
   var $79=(($78)|(0)) > (($walkableHeight)|(0));
   if ($79) { label = 20; break; } else { var $minh_2 = $minh_0;var $asmin_1 = $asmin_0;var $asmax_1 = $asmax_0;var $storemerge4 = $68;label = 21; break; }
  case 20: 
   var $81=(($minh_0)|(0)) < (($43)|(0));
   var $82=$81 ? $minh_0 : $43;
   var $minh_2 = $82;var $asmin_1 = $asmin_0;var $asmax_1 = $asmax_0;var $storemerge4 = $68;label = 21; break;
  case 21: 
   var $storemerge4;
   var $asmax_1;
   var $asmin_1;
   var $minh_2;
   var $84=(($storemerge4)|(0))==0;
   if ($84) { var $minh_4 = $minh_2;var $asmin_4 = $asmin_1;var $asmax_3 = $asmax_1;label = 27; break; } else { label = 22; break; }
  case 22: 
   var $86=$storemerge4;
   var $87=HEAP32[(($86)>>2)];
   var $88=$87 >>> 13;
   var $89=$88 & 8191;
   var $90=(($storemerge4+4)|0);
   var $91=HEAP32[(($90)>>2)];
   var $92=(($91)|(0))==0;
   if ($92) { var $98 = 65535;var $storemerge469 = 0;label = 24; break; } else { label = 23; break; }
  case 23: 
   var $94=$91;
   var $95=HEAP32[(($94)>>2)];
   var $96=$95 & 8191;
   var $98 = $96;var $storemerge469 = $91;label = 24; break;
  case 24: 
   var $storemerge469;
   var $98;
   var $99=(($42)>>>(0)) < (($98)>>>(0));
   var $100=$99 ? $42 : $98;
   var $101=(($33)>>>(0)) > (($89)>>>(0));
   var $102=$101 ? $33 : $89;
   var $103=((($100)-($102))|0);
   var $104=(($103)|(0)) > (($walkableHeight)|(0));
   if ($104) { label = 25; break; } else { var $minh_2 = $minh_2;var $asmin_1 = $asmin_1;var $asmax_1 = $asmax_1;var $storemerge4 = $storemerge469;label = 21; break; }
  case 25: 
   var $105=((($89)-($33))|0);
   var $106=(($minh_2)|(0)) < (($105)|(0));
   var $107=$106 ? $minh_2 : $105;
   var $108=(($105)|(0)) < 0;
   var $109=(((-$105))|0);
   var $_=$108 ? $109 : $105;
   var $110=(($_)|(0)) > (($walkableClimb)|(0));
   if ($110) { var $minh_2 = $107;var $asmin_1 = $asmin_1;var $asmax_1 = $asmax_1;var $storemerge4 = $storemerge469;label = 21; break; } else { label = 26; break; }
  case 26: 
   var $112=(($89)|(0)) < (($asmin_1)|(0));
   var $_asmin_1=$112 ? $89 : $asmin_1;
   var $113=(($89)|(0)) > (($asmax_1)|(0));
   var $_asmax_1=$113 ? $89 : $asmax_1;
   var $minh_2 = $107;var $asmin_1 = $_asmin_1;var $asmax_1 = $_asmax_1;var $storemerge4 = $storemerge469;label = 21; break;
  case 27: 
   var $asmax_3;
   var $asmin_4;
   var $minh_4;
   var $114=((($storemerge3)+(1))|0);
   var $storemerge3 = $114;var $minh_0 = $minh_4;var $asmin_0 = $asmin_4;var $asmax_0 = $asmax_3;label = 14; break;
  case 28: 
   var $116=(($minh_0)|(0)) < (($15)|(0));
   if ($116) { label = 29; break; } else { var $120 = $29;label = 30; break; }
  case 29: 
   var $118=$29 & 67108863;
   HEAP32[(($28)>>2)]=$118;
   var $120 = $118;label = 30; break;
  case 30: 
   var $120;
   var $121=((($asmax_0)-($asmin_0))|0);
   var $122=(($121)|(0)) > (($walkableClimb)|(0));
   if ($122) { label = 31; break; } else { var $storemerge2_in = $34;label = 8; break; }
  case 31: 
   var $124=$120 & 67108863;
   HEAP32[(($28)>>2)]=$124;
   var $storemerge2_in = $34;label = 8; break;
  case 32: 
   var $126=((($storemerge1)+(1))|0);
   var $storemerge1 = $126;label = 6; break;
  case 33: 
   var $128=((($storemerge)+(1))|0);
   var $storemerge = $128;label = 4; break;
  case 34: 
   var $130=HEAP8[($1)];
   var $131=$130 & 1;
   var $132=(($131 << 24) >> 24)==0;
   if ($132) { label = 36; break; } else { label = 35; break; }
  case 35: 
   var $134=$ctx;
   var $135=HEAP32[(($134)>>2)];
   var $136=(($135+24)|0);
   var $137=HEAP32[(($136)>>2)];
   FUNCTION_TABLE[$137]($ctx, 7);
   label = 36; break;
  case 36: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z30rcFilterWalkableLowHeightSpansP9rcContextiR13rcHeightfield($ctx, $walkableHeight, $solid) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 8);
   label = 3; break;
  case 3: 
   var $10=(($solid)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($solid+4)|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($solid+40)|0);
   var $storemerge = 0;label = 4; break;
  case 4: 
   var $storemerge;
   var $16=(($storemerge)|(0)) < (($13)|(0));
   if ($16) { label = 5; break; } else { label = 15; break; }
  case 5: 
   var $17=(Math.imul($storemerge,$11)|0);
   var $storemerge1 = 0;label = 6; break;
  case 6: 
   var $storemerge1;
   var $19=(($storemerge1)|(0)) < (($11)|(0));
   if ($19) { label = 7; break; } else { label = 14; break; }
  case 7: 
   var $21=((($storemerge1)+($17))|0);
   var $22=HEAP32[(($14)>>2)];
   var $23=(($22+($21<<2))|0);
   var $storemerge2_pre=HEAP32[(($23)>>2)];
   var $storemerge2 = $storemerge2_pre;label = 8; break;
  case 8: 
   var $storemerge2;
   var $25=(($storemerge2)|(0))==0;
   if ($25) { label = 13; break; } else { label = 9; break; }
  case 9: 
   var $27=$storemerge2;
   var $28=HEAP32[(($27)>>2)];
   var $29=$28 >>> 13;
   var $30=$29 & 8191;
   var $31=(($storemerge2+4)|0);
   var $32=HEAP32[(($31)>>2)];
   var $33=(($32)|(0))==0;
   if ($33) { var $39 = 65535;var $storemerge218 = 0;label = 11; break; } else { label = 10; break; }
  case 10: 
   var $35=$32;
   var $36=HEAP32[(($35)>>2)];
   var $37=$36 & 8191;
   var $39 = $37;var $storemerge218 = $32;label = 11; break;
  case 11: 
   var $storemerge218;
   var $39;
   var $40=((($39)-($30))|0);
   var $41=(($40)|(0)) > (($walkableHeight)|(0));
   if ($41) { var $storemerge2 = $storemerge218;label = 8; break; } else { label = 12; break; }
  case 12: 
   var $43=$28 & 67108863;
   HEAP32[(($27)>>2)]=$43;
   var $storemerge2 = $storemerge218;label = 8; break;
  case 13: 
   var $45=((($storemerge1)+(1))|0);
   var $storemerge1 = $45;label = 6; break;
  case 14: 
   var $47=((($storemerge)+(1))|0);
   var $storemerge = $47;label = 4; break;
  case 15: 
   var $49=HEAP8[($1)];
   var $50=$49 & 1;
   var $51=(($50 << 24) >> 24)==0;
   if ($51) { label = 17; break; } else { label = 16; break; }
  case 16: 
   var $53=$ctx;
   var $54=HEAP32[(($53)>>2)];
   var $55=(($54+24)|0);
   var $56=HEAP32[(($55)>>2)];
   FUNCTION_TABLE[$56]($ctx, 8);
   label = 17; break;
  case 17: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z15rcBuildPolyMeshP9rcContextR12rcContourSetiR10rcPolyMesh($ctx, $cset, $nvp, $mesh) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $ea18_i=sp;
   var $eb19_i=(sp)+(8);
   var $ea=(sp)+(16);
   var $eb=(sp)+(24);
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 11);
   label = 3; break;
  case 3: 
   var $10=(($mesh+36)|0);
   var $11=(($cset+8)|0);
   var $12=HEAPF32[(($11)>>2)];
   HEAPF32[(($10)>>2)]=$12;
   var $13=(($cset+12)|0);
   var $14=HEAPF32[(($13)>>2)];
   var $15=(($mesh+40)|0);
   HEAPF32[(($15)>>2)]=$14;
   var $16=(($cset+16)|0);
   var $17=HEAPF32[(($16)>>2)];
   var $18=(($mesh+44)|0);
   HEAPF32[(($18)>>2)]=$17;
   var $19=(($mesh+48)|0);
   var $20=(($cset+20)|0);
   var $21=HEAPF32[(($20)>>2)];
   HEAPF32[(($19)>>2)]=$21;
   var $22=(($cset+24)|0);
   var $23=HEAPF32[(($22)>>2)];
   var $24=(($mesh+52)|0);
   HEAPF32[(($24)>>2)]=$23;
   var $25=(($cset+28)|0);
   var $26=HEAPF32[(($25)>>2)];
   var $27=(($mesh+56)|0);
   HEAPF32[(($27)>>2)]=$26;
   var $28=(($cset+32)|0);
   var $29=HEAPF32[(($28)>>2)];
   var $30=(($mesh+60)|0);
   HEAPF32[(($30)>>2)]=$29;
   var $31=(($cset+36)|0);
   var $32=HEAPF32[(($31)>>2)];
   var $33=(($mesh+64)|0);
   HEAPF32[(($33)>>2)]=$32;
   var $34=(($cset+48)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($mesh+68)|0);
   HEAP32[(($36)>>2)]=$35;
   var $37=(($cset+4)|0);
   var $38=HEAP32[(($37)>>2)];
   var $39=(($cset)|0);
   var $storemerge = 0;var $maxVertsPerCont_0 = 0;var $maxTris_0 = 0;var $maxVertices_0 = 0;label = 4; break;
  case 4: 
   var $maxVertices_0;
   var $maxTris_0;
   var $maxVertsPerCont_0;
   var $storemerge;
   var $41=(($storemerge)|(0)) < (($38)|(0));
   if ($41) { label = 5; break; } else { label = 8; break; }
  case 5: 
   var $43=HEAP32[(($39)>>2)];
   var $44=(($43+((($storemerge)*(20))&-1)+4)|0);
   var $45=HEAP32[(($44)>>2)];
   var $46=(($45)|(0)) < 3;
   if ($46) { var $maxVertsPerCont_1 = $maxVertsPerCont_0;var $maxTris_1 = $maxTris_0;var $maxVertices_1 = $maxVertices_0;label = 7; break; } else { label = 6; break; }
  case 6: 
   var $48=((($maxVertices_0)+($45))|0);
   var $49=((($45)-(2))|0);
   var $50=((($maxTris_0)+($49))|0);
   var $51=(($maxVertsPerCont_0)|(0)) > (($45)|(0));
   var $52=$51 ? $maxVertsPerCont_0 : $45;
   var $maxVertsPerCont_1 = $52;var $maxTris_1 = $50;var $maxVertices_1 = $48;label = 7; break;
  case 7: 
   var $maxVertices_1;
   var $maxTris_1;
   var $maxVertsPerCont_1;
   var $54=((($storemerge)+(1))|0);
   var $storemerge = $54;var $maxVertsPerCont_0 = $maxVertsPerCont_1;var $maxTris_0 = $maxTris_1;var $maxVertices_0 = $maxVertices_1;label = 4; break;
  case 8: 
   var $56=(($maxVertices_0)|(0)) > 65533;
   if ($56) { label = 9; break; } else { label = 10; break; }
  case 9: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4128)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxVertices_0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_61194 = 0;label = 402; break;
  case 10: 
   var $59=_malloc($maxVertices_0);
   var $60=(($59)|(0))==0;
   if ($60) { label = 11; break; } else { label = 13; break; }
  case 11: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5896)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxVertices_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_61194 = 0;label = 402; break; } else { label = 12; break; }
  case 12: 
   var $63$0 = ___cxa_find_matching_catch(-1, -1); $63$1 = tempRet0;
   var $64=$63$0;
   var $65=$63$1;
   var $_41182 = $65;var $_41187 = $64;label = 400; break;
  case 13: 
   _memset($59, 0, $maxVertices_0);
   var $67=((($maxVertices_0)*(6))&-1);
   var $68=_malloc($67);
   var $69=$68;
   var $70=(($mesh)|0);
   HEAP32[(($70)>>2)]=$69;
   var $71=(($68)|(0))==0;
   if ($71) { label = 14; break; } else { label = 15; break; }
  case 14: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4664)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxVertices_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_511931366 = 0;label = 399; break; } else { label = 12; break; }
  case 15: 
   var $74=$maxTris_0 << 1;
   var $75=(Math.imul($74,$nvp)|0);
   var $76=$75 << 1;
   var $77=_malloc($76);
   var $78=$77;
   var $79=(($mesh+4)|0);
   HEAP32[(($79)>>2)]=$78;
   var $80=(($77)|(0))==0;
   if ($80) { label = 16; break; } else { label = 17; break; }
  case 16: 
   var $82=(Math.imul($maxTris_0,$nvp)|0);
   var $83=$82 << 1;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3728)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$83,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_51193 = 0;label = 398; break; } else { label = 12; break; }
  case 17: 
   var $85=_malloc($74);
   var $86=$85;
   var $87=(($mesh+8)|0);
   HEAP32[(($87)>>2)]=$86;
   var $88=(($85)|(0))==0;
   if ($88) { label = 18; break; } else { label = 19; break; }
  case 18: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2664)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxTris_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_51193 = 0;label = 398; break; } else { label = 12; break; }
  case 19: 
   var $91=_malloc($maxTris_0);
   var $92=(($mesh+16)|0);
   HEAP32[(($92)>>2)]=$91;
   var $93=(($91)|(0))==0;
   if ($93) { label = 20; break; } else { label = 21; break; }
  case 20: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((1872)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxTris_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_51193 = 0;label = 398; break; } else { label = 12; break; }
  case 21: 
   var $96=(($mesh+20)|0);
   HEAP32[(($96)>>2)]=0;
   var $97=(($mesh+24)|0);
   HEAP32[(($97)>>2)]=0;
   var $98=(($mesh+32)|0);
   HEAP32[(($98)>>2)]=$nvp;
   var $99=(($mesh+28)|0);
   HEAP32[(($99)>>2)]=$maxTris_0;
   var $100=HEAP32[(($70)>>2)];
   var $101=$100;
   _memset($101, 0, $67);
   var $102=HEAP32[(($79)>>2)];
   var $103=$102;
   _memset($103, -1, $76);
   var $104=HEAP32[(($87)>>2)];
   var $105=$104;
   _memset($105, 0, $74);
   var $106=HEAP32[(($92)>>2)];
   _memset($106, 0, $maxTris_0);
   var $107=$maxVertices_0 << 2;
   var $108=_malloc($107);
   var $109=$108;
   var $110=(($108)|(0))==0;
   if ($110) { label = 22; break; } else { label = 24; break; }
  case 22: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((1208)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxVertices_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_51193 = 0;label = 398; break; } else { label = 23; break; }
  case 23: 
   var $112$0 = ___cxa_find_matching_catch(-1, -1); $112$1 = tempRet0;
   var $113=$112$0;
   var $114=$112$1;
   var $_41182 = $114;var $_41187 = $113;label = 400; break;
  case 24: 
   _memset($108, 0, $107);
   var $116=_malloc(16384);
   var $117=$116;
   var $118=(($116)|(0))==0;
   if ($118) { label = 25; break; } else { var $storemerge1 = 0;label = 27; break; }
  case 25: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((832)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=4096,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_pre_phi1374 = $108;var $_411921375 = 0;label = 395; break; } else { label = 26; break; }
  case 26: 
   var $120$0 = ___cxa_find_matching_catch(-1, -1); $120$1 = tempRet0;
   var $121=$120$0;
   var $122=$120$1;
   var $_31181 = $122;var $_31186 = $121;var $_pre_phi1255 = $108;label = 396; break;
  case 27: 
   var $storemerge1;
   var $123=(($storemerge1)|(0)) < 4096;
   if ($123) { label = 28; break; } else { label = 29; break; }
  case 28: 
   var $125=(($117+($storemerge1<<2))|0);
   HEAP32[(($125)>>2)]=-1;
   var $126=((($storemerge1)+(1))|0);
   var $storemerge1 = $126;label = 27; break;
  case 29: 
   var $128=$maxVertsPerCont_0 << 2;
   var $129=_malloc($128);
   var $130=$129;
   var $131=(($129)|(0))==0;
   if ($131) { label = 30; break; } else { label = 32; break; }
  case 30: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((472)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$maxVertsPerCont_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_31191 = 0;label = 390; break; } else { label = 31; break; }
  case 31: 
   var $133$0 = ___cxa_find_matching_catch(-1, -1); $133$1 = tempRet0;
   var $134=$133$0;
   var $135=$133$1;
   var $_21180 = $135;var $_21185 = $134;label = 392; break;
  case 32: 
   var $137=((($maxVertsPerCont_0)*(12))&-1);
   var $138=_malloc($137);
   var $139=$138;
   var $140=(($138)|(0))==0;
   if ($140) { label = 33; break; } else { label = 35; break; }
  case 33: 
   var $142=((($maxVertsPerCont_0)*(3))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((200)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$142,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_211901373 = 0;label = 387; break; } else { label = 34; break; }
  case 34: 
   var $143$0 = ___cxa_find_matching_catch(-1, -1); $143$1 = tempRet0;
   var $144=$143$0;
   var $145=$143$1;
   var $_11179 = $145;var $_11184 = $144;label = 388; break;
  case 35: 
   var $147=$maxVertsPerCont_0 << 1;
   var $148=((($147)+(2))|0);
   var $149=(Math.imul($148,$nvp)|0);
   var $150=_malloc($149);
   var $151=$150;
   var $152=(($150)|(0))==0;
   var $153=(Math.imul($maxVertsPerCont_0,$nvp)|0);
   if ($152) { label = 36; break; } else { label = 41; break; }
  case 36: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((6360)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$153,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_111891372 = 0;label = 383; break; } else { label = 38; break; }
  case 37: 
   var $lpad_loopexit$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit$1 = tempRet0;
   var $eh_lpad_body$1 = $lpad_loopexit$1;var $eh_lpad_body$0 = $lpad_loopexit$0;label = 39; break;
  case 38: 
   var $lpad_nonloopexit$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit$1 = tempRet0;
   var $eh_lpad_body$1 = $lpad_nonloopexit$1;var $eh_lpad_body$0 = $lpad_nonloopexit$0;label = 39; break;
  case 39: 
   var $eh_lpad_body$0;
   var $eh_lpad_body$1;
   var $155=$eh_lpad_body$0;
   var $156=$eh_lpad_body$1;
   if ($152) { label = 384; break; } else { label = 40; break; }
  case 40: 
   _free($150);
   label = 384; break;
  case 41: 
   var $159=(($151+($153<<1))|0);
   var $160=$153 << 1;
   var $161=(($nvp)|(0)) > 3;
   var $162=$nvp << 1;
   var $storemerge2 = 0;label = 42; break;
  case 42: 
   var $storemerge2;
   var $164=HEAP32[(($37)>>2)];
   var $165=(($storemerge2)|(0)) < (($164)|(0));
   if ($165) { label = 44; break; } else { label = 43; break; }
  case 43: 
   var $166=$ea18_i;
   var $167=$eb19_i;
   var $storemerge3 = 0;label = 89; break;
  case 44: 
   var $169=HEAP32[(($39)>>2)];
   var $170=(($169+((($storemerge2)*(20))&-1)+4)|0);
   var $171=HEAP32[(($170)>>2)];
   var $172=(($171)|(0)) < 3;
   if ($172) { label = 88; break; } else { label = 45; break; }
  case 45: 
   var $173=(($169+((($storemerge2)*(20))&-1)+4)|0);
   var $storemerge7 = 0;var $175 = $171;label = 46; break;
  case 46: 
   var $175;
   var $storemerge7;
   var $176=(($storemerge7)|(0)) < (($175)|(0));
   if ($176) { label = 47; break; } else { label = 48; break; }
  case 47: 
   var $178=(($130+($storemerge7<<2))|0);
   HEAP32[(($178)>>2)]=$storemerge7;
   var $179=((($storemerge7)+(1))|0);
   var $_pre=HEAP32[(($173)>>2)];
   var $storemerge7 = $179;var $175 = $_pre;label = 46; break;
  case 48: 
   var $181=(($169+((($storemerge2)*(20))&-1))|0);
   var $182=HEAP32[(($181)>>2)];
   var $183=__ZL11triangulateiPKiPiS1_($175, $182, $130, $139);
   var $184=(($183)|(0)) < 1;
   if ($184) { label = 49; break; } else { var $ntris_0_ph = $183;label = 51; break; }
  case 49: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((6224)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge2,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 50; break; } else { label = 37; break; }
  case 50: 
   var $187=(((-$183))|0);
   var $ntris_0_ph = $187;label = 51; break;
  case 51: 
   var $ntris_0_ph;
   var $storemerge8 = 0;label = 52; break;
  case 52: 
   var $storemerge8;
   var $189=HEAP32[(($173)>>2)];
   var $190=(($storemerge8)|(0)) < (($189)|(0));
   if ($190) { label = 53; break; } else { label = 63; break; }
  case 53: 
   var $192=$storemerge8 << 2;
   var $193=HEAP32[(($181)>>2)];
   var $194=(($193+($192<<2))|0);
   var $195=HEAP32[(($194)>>2)];
   var $196=(($195) & 65535);
   var $_sum1415=$192 | 1;
   var $197=(($193+($_sum1415<<2))|0);
   var $198=HEAP32[(($197)>>2)];
   var $199=(($198) & 65535);
   var $_sum13081309=$192 | 2;
   var $200=(($193+($_sum13081309<<2))|0);
   var $201=HEAP32[(($200)>>2)];
   var $202=(($201) & 65535);
   var $203=HEAP32[(($70)>>2)];
   var $204=$195 & 65535;
   var $205=$201 & 65535;
   var $206=(Math.imul($204,-1918454973)|0);
   var $207=(Math.imul($205,-887442657)|0);
   var $208=((($206)+($207))|0);
   var $209=$208 & 4095;
   var $210=(($117+($209<<2))|0);
   var $211=$198 & 65535;
   var $storemerge_in_i = $210;label = 54; break;
  case 54: 
   var $storemerge_in_i;
   var $storemerge_i43=HEAP32[(($storemerge_in_i)>>2)];
   var $213=(($storemerge_i43)|(0))==-1;
   if ($213) { label = 59; break; } else { label = 55; break; }
  case 55: 
   var $215=((($storemerge_i43)*(3))&-1);
   var $216=(($203+($215<<1))|0);
   var $217=HEAP16[(($216)>>1)];
   var $218=(($217 << 16) >> 16)==(($196 << 16) >> 16);
   if ($218) { label = 56; break; } else { label = 58; break; }
  case 56: 
   var $_sum1310=((($215)+(1))|0);
   var $219=(($203+($_sum1310<<1))|0);
   var $220=HEAP16[(($219)>>1)];
   var $221=(($220)&(65535));
   var $222=((($221)-($211))|0);
   var $223=(($222)|(0)) < 0;
   var $224=(((-$222))|0);
   var $225=$223 ? $224 : $222;
   var $226=(($225)|(0)) < 3;
   if ($226) { label = 57; break; } else { label = 58; break; }
  case 57: 
   var $_sum1311=((($215)+(2))|0);
   var $228=(($203+($_sum1311<<1))|0);
   var $229=HEAP16[(($228)>>1)];
   var $230=(($229 << 16) >> 16)==(($202 << 16) >> 16);
   if ($230) { var $storemerge_i43_sink = $storemerge_i43;label = 60; break; } else { label = 58; break; }
  case 58: 
   var $232=(($109+($storemerge_i43<<2))|0);
   var $storemerge_in_i = $232;label = 54; break;
  case 59: 
   var $234=HEAP32[(($96)>>2)];
   var $235=((($234)+(1))|0);
   HEAP32[(($96)>>2)]=$235;
   var $236=((($234)*(3))&-1);
   var $237=(($203+($236<<1))|0);
   HEAP16[(($237)>>1)]=$196;
   var $_sum1314=((($236)+(1))|0);
   var $238=(($203+($_sum1314<<1))|0);
   HEAP16[(($238)>>1)]=$199;
   var $_sum1315=((($236)+(2))|0);
   var $239=(($203+($_sum1315<<1))|0);
   HEAP16[(($239)>>1)]=$202;
   var $240=HEAP32[(($210)>>2)];
   var $241=(($109+($234<<2))|0);
   HEAP32[(($241)>>2)]=$240;
   HEAP32[(($210)>>2)]=$234;
   var $storemerge_i43_sink = $234;label = 60; break;
  case 60: 
   var $storemerge_i43_sink;
   var $243=(($storemerge_i43_sink) & 65535);
   var $244=(($243)&(65535));
   var $245=(($130+($storemerge8<<2))|0);
   HEAP32[(($245)>>2)]=$244;
   var $_sum13121313=$192 | 3;
   var $246=(($193+($_sum13121313<<2))|0);
   var $247=HEAP32[(($246)>>2)];
   var $248=$247 & 65536;
   var $249=(($248)|(0))==0;
   if ($249) { label = 62; break; } else { label = 61; break; }
  case 61: 
   var $251=(($59+$244)|0);
   HEAP8[($251)]=1;
   label = 62; break;
  case 62: 
   var $253=((($storemerge8)+(1))|0);
   var $storemerge8 = $253;label = 52; break;
  case 63: 
   _memset($150, -1, $160);
   var $storemerge9 = 0;var $npolys_0 = 0;label = 64; break;
  case 64: 
   var $npolys_0;
   var $storemerge9;
   var $256=(($storemerge9)|(0)) < (($ntris_0_ph)|(0));
   if ($256) { label = 65; break; } else { label = 69; break; }
  case 65: 
   var $258=((($storemerge9)*(3))&-1);
   var $259=(($139+($258<<2))|0);
   var $260=HEAP32[(($259)>>2)];
   var $_sum=((($258)+(1))|0);
   var $261=(($139+($_sum<<2))|0);
   var $262=HEAP32[(($261)>>2)];
   var $263=(($260)|(0))==(($262)|(0));
   if ($263) { var $npolys_1 = $npolys_0;label = 68; break; } else { label = 66; break; }
  case 66: 
   var $_sum1306=((($258)+(2))|0);
   var $265=(($139+($_sum1306<<2))|0);
   var $266=HEAP32[(($265)>>2)];
   var $267=(($260)|(0))==(($266)|(0));
   var $268=(($262)|(0))==(($266)|(0));
   var $or_cond=$267 | $268;
   if ($or_cond) { var $npolys_1 = $npolys_0;label = 68; break; } else { label = 67; break; }
  case 67: 
   var $_sum1307=((($258)+(1))|0);
   var $270=(($139+($_sum1307<<2))|0);
   var $271=(($130+($260<<2))|0);
   var $272=HEAP32[(($271)>>2)];
   var $273=(Math.imul($npolys_0,$nvp)|0);
   var $274=(($272) & 65535);
   var $275=(($151+($273<<1))|0);
   HEAP16[(($275)>>1)]=$274;
   var $276=HEAP32[(($270)>>2)];
   var $277=(($130+($276<<2))|0);
   var $278=HEAP32[(($277)>>2)];
   var $279=((($273)+(1))|0);
   var $280=(($278) & 65535);
   var $281=(($151+($279<<1))|0);
   HEAP16[(($281)>>1)]=$280;
   var $282=HEAP32[(($265)>>2)];
   var $283=(($130+($282<<2))|0);
   var $284=HEAP32[(($283)>>2)];
   var $285=((($273)+(2))|0);
   var $286=(($284) & 65535);
   var $287=(($151+($285<<1))|0);
   HEAP16[(($287)>>1)]=$286;
   var $288=((($npolys_0)+(1))|0);
   var $npolys_1 = $288;label = 68; break;
  case 68: 
   var $npolys_1;
   var $290=((($storemerge9)+(1))|0);
   var $storemerge9 = $290;var $npolys_0 = $npolys_1;label = 64; break;
  case 69: 
   var $292=(($npolys_0)|(0))==0;
   if ($292) { label = 88; break; } else { label = 70; break; }
  case 70: 
   if ($161) { var $npolys_2 = $npolys_0;label = 71; break; } else { var $npolys_3_ph = $npolys_0;label = 80; break; }
  case 71: 
   var $npolys_2;
   var $294=((($npolys_2)-(1))|0);
   var $storemerge12 = 0;var $bestEb_0 = 0;var $bestEa_0 = 0;var $bestPb_0 = 0;var $bestPa_0 = 0;var $bestMergeVal_0 = 0;label = 72; break;
  case 72: 
   var $bestMergeVal_0;
   var $bestPa_0;
   var $bestPb_0;
   var $bestEa_0;
   var $bestEb_0;
   var $storemerge12;
   var $296=(($storemerge12)|(0)) < (($294)|(0));
   if ($296) { label = 73; break; } else { label = 78; break; }
  case 73: 
   var $298=(Math.imul($storemerge12,$nvp)|0);
   var $299=(($151+($298<<1))|0);
   var $storemerge13_in = $storemerge12;var $bestEb_1 = $bestEb_0;var $bestEa_1 = $bestEa_0;var $bestPb_1 = $bestPb_0;var $bestPa_1 = $bestPa_0;var $bestMergeVal_1 = $bestMergeVal_0;label = 74; break;
  case 74: 
   var $bestMergeVal_1;
   var $bestPa_1;
   var $bestPb_1;
   var $bestEa_1;
   var $bestEb_1;
   var $storemerge13_in;
   var $storemerge13=((($storemerge13_in)+(1))|0);
   var $301=(($storemerge13)|(0)) < (($npolys_2)|(0));
   if ($301) { label = 75; break; } else { label = 77; break; }
  case 75: 
   var $303=(Math.imul($storemerge13,$nvp)|0);
   var $304=(($151+($303<<1))|0);
   var $305=HEAP32[(($70)>>2)];
   var $306=__ZL17getPolyMergeValuePtS_PKtRiS2_i($299, $304, $305, $ea, $eb, $nvp);
   var $307=(($306)|(0)) > (($bestMergeVal_1)|(0));
   if ($307) { label = 76; break; } else { var $storemerge13_in = $storemerge13;var $bestEb_1 = $bestEb_1;var $bestEa_1 = $bestEa_1;var $bestPb_1 = $bestPb_1;var $bestPa_1 = $bestPa_1;var $bestMergeVal_1 = $bestMergeVal_1;label = 74; break; }
  case 76: 
   var $309=HEAP32[(($ea)>>2)];
   var $310=HEAP32[(($eb)>>2)];
   var $storemerge13_in = $storemerge13;var $bestEb_1 = $310;var $bestEa_1 = $309;var $bestPb_1 = $storemerge13;var $bestPa_1 = $storemerge12;var $bestMergeVal_1 = $306;label = 74; break;
  case 77: 
   var $312=((($storemerge12)+(1))|0);
   var $storemerge12 = $312;var $bestEb_0 = $bestEb_1;var $bestEa_0 = $bestEa_1;var $bestPb_0 = $bestPb_1;var $bestPa_0 = $bestPa_1;var $bestMergeVal_0 = $bestMergeVal_1;label = 72; break;
  case 78: 
   var $314=(($bestMergeVal_0)|(0)) > 0;
   if ($314) { label = 79; break; } else { var $npolys_3_ph = $npolys_2;label = 80; break; }
  case 79: 
   var $316=(Math.imul($bestPa_0,$nvp)|0);
   var $317=(($151+($316<<1))|0);
   var $318=(Math.imul($bestPb_0,$nvp)|0);
   var $319=(($151+($318<<1))|0);
   __ZL10mergePolysPtS_iiS_i($317, $319, $bestEa_0, $bestEb_0, $159, $nvp);
   var $320=(Math.imul($294,$nvp)|0);
   var $321=$319;
   var $322=(($151+($320<<1))|0);
   var $323=$322;
   assert($162 % 1 === 0);(_memcpy($321, $323, $162)|0);
   var $npolys_2 = $294;label = 71; break;
  case 80: 
   var $npolys_3_ph;
   var $324=(($169+((($storemerge2)*(20))&-1)+16)|0);
   var $325=(($169+((($storemerge2)*(20))&-1)+18)|0);
   var $storemerge10 = 0;label = 81; break;
  case 81: 
   var $storemerge10;
   var $327=(($storemerge10)|(0)) < (($npolys_3_ph)|(0));
   if ($327) { label = 82; break; } else { label = 88; break; }
  case 82: 
   var $329=HEAP32[(($97)>>2)];
   var $330=(Math.imul($329,$nvp)|0);
   var $331=$330 << 1;
   var $332=HEAP32[(($79)>>2)];
   var $333=(Math.imul($storemerge10,$nvp)|0);
   var $storemerge11 = 0;label = 83; break;
  case 83: 
   var $storemerge11;
   var $335=(($storemerge11)|(0)) < (($nvp)|(0));
   if ($335) { label = 84; break; } else { label = 85; break; }
  case 84: 
   var $_sum1304=((($333)+($storemerge11))|0);
   var $337=(($151+($_sum1304<<1))|0);
   var $338=HEAP16[(($337)>>1)];
   var $_sum1305=((($331)+($storemerge11))|0);
   var $339=(($332+($_sum1305<<1))|0);
   HEAP16[(($339)>>1)]=$338;
   var $340=((($storemerge11)+(1))|0);
   var $storemerge11 = $340;label = 83; break;
  case 85: 
   var $342=HEAP16[(($324)>>1)];
   var $343=HEAP32[(($97)>>2)];
   var $344=HEAP32[(($87)>>2)];
   var $345=(($344+($343<<1))|0);
   HEAP16[(($345)>>1)]=$342;
   var $346=HEAP8[($325)];
   var $347=HEAP32[(($97)>>2)];
   var $348=HEAP32[(($92)>>2)];
   var $349=(($348+$347)|0);
   HEAP8[($349)]=$346;
   var $350=HEAP32[(($97)>>2)];
   var $351=((($350)+(1))|0);
   HEAP32[(($97)>>2)]=$351;
   var $352=(($351)|(0)) > (($maxTris_0)|(0));
   if ($352) { label = 86; break; } else { label = 87; break; }
  case 86: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((6112)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$351,HEAP32[(((tempVarArgs)+(8))>>2)]=$maxTris_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01188 = 0;var $_pre_phi1257 = $150;label = 380; break; } else { label = 38; break; }
  case 87: 
   var $355=((($storemerge10)+(1))|0);
   var $storemerge10 = $355;label = 81; break;
  case 88: 
   var $356=((($storemerge2)+(1))|0);
   var $storemerge2 = $356;label = 42; break;
  case 89: 
   var $storemerge3;
   var $358=HEAP32[(($96)>>2)];
   var $359=(($storemerge3)|(0)) < (($358)|(0));
   if ($359) { label = 90; break; } else { label = 309; break; }
  case 90: 
   var $361=(($59+$storemerge3)|0);
   var $362=HEAP8[($361)];
   var $363=(($362 << 24) >> 24)==0;
   if ($363) { var $i9_0 = $storemerge3;label = 308; break; } else { label = 91; break; }
  case 91: 
   var $365=(($storemerge3) & 65535);
   var $366=HEAP32[(($98)>>2)];
   var $367=HEAP32[(($97)>>2)];
   var $storemerge_i61 = 0;var $numRemovedVerts_i47_0 = 0;var $numTouchedVerts_i_0 = 0;var $numRemainingEdges_i_0 = 0;label = 92; break;
  case 92: 
   var $numRemainingEdges_i_0;
   var $numTouchedVerts_i_0;
   var $numRemovedVerts_i47_0;
   var $storemerge_i61;
   var $369=(($storemerge_i61)|(0)) < (($367)|(0));
   if ($369) { label = 93; break; } else { label = 105; break; }
  case 93: 
   var $371=(Math.imul($storemerge_i61,$366)|0);
   var $372=$371 << 1;
   var $373=HEAP32[(($79)>>2)];
   var $storemerge_i_i62 = 0;label = 94; break;
  case 94: 
   var $storemerge_i_i62;
   var $375=(($storemerge_i_i62)|(0)) < (($366)|(0));
   if ($375) { label = 95; break; } else { var $storemerge1_i_i63_in_sroa_speculated = $366;label = 97; break; }
  case 95: 
   var $_sum1303=((($372)+($storemerge_i_i62))|0);
   var $377=(($373+($_sum1303<<1))|0);
   var $378=HEAP16[(($377)>>1)];
   var $379=(($378 << 16) >> 16)==-1;
   if ($379) { var $storemerge1_i_i63_in_sroa_speculated = $storemerge_i_i62;label = 97; break; } else { label = 96; break; }
  case 96: 
   var $381=((($storemerge_i_i62)+(1))|0);
   var $storemerge_i_i62 = $381;label = 94; break;
  case 97: 
   var $storemerge1_i_i63_in_sroa_speculated;
   var $storemerge5_i65 = 0;var $numTouchedVerts_i_1 = $numTouchedVerts_i_0;var $numRemoved_i_0 = 0;var $numVerts_i_0 = 0;label = 98; break;
  case 98: 
   var $numVerts_i_0;
   var $numRemoved_i_0;
   var $numTouchedVerts_i_1;
   var $storemerge5_i65;
   var $383=(($storemerge5_i65)|(0)) < (($storemerge1_i_i63_in_sroa_speculated)|(0));
   if ($383) { label = 99; break; } else { label = 102; break; }
  case 99: 
   var $_sum1302=((($372)+($storemerge5_i65))|0);
   var $385=(($373+($_sum1302<<1))|0);
   var $386=HEAP16[(($385)>>1)];
   var $387=(($386 << 16) >> 16)==(($365 << 16) >> 16);
   if ($387) { label = 100; break; } else { var $numTouchedVerts_i_2 = $numTouchedVerts_i_1;var $numRemoved_i_1 = $numRemoved_i_0;label = 101; break; }
  case 100: 
   var $389=((($numTouchedVerts_i_1)+(1))|0);
   var $390=((($numRemoved_i_0)+(1))|0);
   var $numTouchedVerts_i_2 = $389;var $numRemoved_i_1 = $390;label = 101; break;
  case 101: 
   var $numRemoved_i_1;
   var $numTouchedVerts_i_2;
   var $392=((($numVerts_i_0)+(1))|0);
   var $393=((($storemerge5_i65)+(1))|0);
   var $storemerge5_i65 = $393;var $numTouchedVerts_i_1 = $numTouchedVerts_i_2;var $numRemoved_i_0 = $numRemoved_i_1;var $numVerts_i_0 = $392;label = 98; break;
  case 102: 
   var $395=(($numRemoved_i_0)|(0))==0;
   if ($395) { var $numRemovedVerts_i47_1 = $numRemovedVerts_i47_0;var $numRemainingEdges_i_1 = $numRemainingEdges_i_0;label = 104; break; } else { label = 103; break; }
  case 103: 
   var $397=((($numRemovedVerts_i47_0)+($numRemoved_i_0))|0);
   var $398=((($numRemoved_i_0)+(1))|0);
   var $399=((($numVerts_i_0)-($398))|0);
   var $400=((($numRemainingEdges_i_0)+($399))|0);
   var $numRemovedVerts_i47_1 = $397;var $numRemainingEdges_i_1 = $400;label = 104; break;
  case 104: 
   var $numRemainingEdges_i_1;
   var $numRemovedVerts_i47_1;
   var $402=((($storemerge_i61)+(1))|0);
   var $storemerge_i61 = $402;var $numRemovedVerts_i47_0 = $numRemovedVerts_i47_1;var $numTouchedVerts_i_0 = $numTouchedVerts_i_1;var $numRemainingEdges_i_0 = $numRemainingEdges_i_1;label = 92; break;
  case 105: 
   var $404=(($numRemainingEdges_i_0)|(0)) < 3;
   if ($404) { var $i9_0 = $storemerge3;label = 308; break; } else { label = 106; break; }
  case 106: 
   var $406=((($numTouchedVerts_i_0)*(24))&-1);
   var $407=_malloc($406);
   var $408=$407;
   var $409=(($407)|(0))==0;
   if ($409) { label = 107; break; } else { var $storemerge1_i66 = 0;var $nedges_i52_0 = 0;label = 109; break; }
  case 107: 
   var $411=((($numTouchedVerts_i_0)*(6))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((2312)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$411,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $i9_0 = $storemerge3;label = 308; break; } else { label = 108; break; }
  case 108: 
   var $412$0 = ___cxa_find_matching_catch(-1, -1); $412$1 = tempRet0;
   var $413=(($407)|(0))==0;
   var $eh_lpad_body$1 = $412$1;var $eh_lpad_body$0 = $412$0;label = 39; break;
  case 109: 
   var $nedges_i52_0;
   var $storemerge1_i66;
   var $414=HEAP32[(($97)>>2)];
   var $415=(($storemerge1_i66)|(0)) < (($414)|(0));
   if ($415) { label = 110; break; } else { var $storemerge2_i70 = 0;var $numOpenEdges_i_0 = 0;label = 130; break; }
  case 110: 
   var $417=(Math.imul($storemerge1_i66,$366)|0);
   var $418=$417 << 1;
   var $419=HEAP32[(($79)>>2)];
   var $storemerge_i7_i = 0;label = 111; break;
  case 111: 
   var $storemerge_i7_i;
   var $421=(($storemerge_i7_i)|(0)) < (($366)|(0));
   if ($421) { label = 112; break; } else { var $storemerge1_i8_i_in_sroa_speculated = $366;label = 114; break; }
  case 112: 
   var $_sum1301=((($418)+($storemerge_i7_i))|0);
   var $423=(($419+($_sum1301<<1))|0);
   var $424=HEAP16[(($423)>>1)];
   var $425=(($424 << 16) >> 16)==-1;
   if ($425) { var $storemerge1_i8_i_in_sroa_speculated = $storemerge_i7_i;label = 114; break; } else { label = 113; break; }
  case 113: 
   var $427=((($storemerge_i7_i)+(1))|0);
   var $storemerge_i7_i = $427;label = 111; break;
  case 114: 
   var $storemerge1_i8_i_in_sroa_speculated;
   var $428=((($storemerge1_i8_i_in_sroa_speculated)-(1))|0);
   var $storemerge3_i67 = $428;var $nedges_i52_1 = $nedges_i52_0;var $j4_i57_0 = 0;label = 115; break;
  case 115: 
   var $j4_i57_0;
   var $nedges_i52_1;
   var $storemerge3_i67;
   var $430=(($j4_i57_0)|(0)) < (($storemerge1_i8_i_in_sroa_speculated)|(0));
   if ($430) { label = 116; break; } else { label = 129; break; }
  case 116: 
   var $_sum1295=((($418)+($j4_i57_0))|0);
   var $432=(($419+($_sum1295<<1))|0);
   var $433=HEAP16[(($432)>>1)];
   var $434=(($433 << 16) >> 16)==(($365 << 16) >> 16);
   var $_sum1300=((($418)+($storemerge3_i67))|0);
   var $_phi_trans_insert=(($419+($_sum1300<<1))|0);
   var $_pre1245=HEAP16[(($_phi_trans_insert)>>1)];
   if ($434) { label = 119; break; } else { label = 117; break; }
  case 117: 
   var $436=(($_pre1245 << 16) >> 16)==(($365 << 16) >> 16);
   if ($436) { label = 118; break; } else { var $nedges_i52_2 = $nedges_i52_1;label = 128; break; }
  case 118: 
   var $437=(($433)&(65535));
   var $438=(($365)&(65535));
   var $445 = $437;var $444 = $438;label = 120; break;
  case 119: 
   var $440=(($433)&(65535));
   var $441=(($_pre1245)&(65535));
   var $442=(($_pre1245 << 16) >> 16)==(($365 << 16) >> 16);
   if ($442) { var $445 = $440;var $444 = $441;label = 120; break; } else { var $a_i59_0 = $440;var $b_i_0 = $441;label = 121; break; }
  case 120: 
   var $444;
   var $445;
   var $a_i59_0 = $444;var $b_i_0 = $445;label = 121; break;
  case 121: 
   var $b_i_0;
   var $a_i59_0;
   var $storemerge4_i68 = 0;var $exists_i_0 = 0;label = 122; break;
  case 122: 
   var $exists_i_0;
   var $storemerge4_i68;
   var $448=(($storemerge4_i68)|(0)) < (($nedges_i52_1)|(0));
   if ($448) { label = 123; break; } else { label = 126; break; }
  case 123: 
   var $450=((($storemerge4_i68)*(3))&-1);
   var $_sum_i69=((($450)+(1))|0);
   var $451=(($408+($_sum_i69<<2))|0);
   var $452=HEAP32[(($451)>>2)];
   var $453=(($452)|(0))==(($b_i_0)|(0));
   if ($453) { label = 124; break; } else { var $exists_i_1 = $exists_i_0;label = 125; break; }
  case 124: 
   var $_sum1299=((($450)+(2))|0);
   var $455=(($408+($_sum1299<<2))|0);
   var $456=HEAP32[(($455)>>2)];
   var $457=((($456)+(1))|0);
   HEAP32[(($455)>>2)]=$457;
   var $exists_i_1 = 1;label = 125; break;
  case 125: 
   var $exists_i_1;
   var $459=((($storemerge4_i68)+(1))|0);
   var $storemerge4_i68 = $459;var $exists_i_0 = $exists_i_1;label = 122; break;
  case 126: 
   var $461=$exists_i_0 & 1;
   var $462=(($461 << 24) >> 24)==0;
   if ($462) { label = 127; break; } else { var $nedges_i52_2 = $nedges_i52_1;label = 128; break; }
  case 127: 
   var $464=((($nedges_i52_1)*(3))&-1);
   var $465=(($408+($464<<2))|0);
   HEAP32[(($465)>>2)]=$a_i59_0;
   var $_sum1297=((($464)+(1))|0);
   var $466=(($408+($_sum1297<<2))|0);
   HEAP32[(($466)>>2)]=$b_i_0;
   var $_sum1298=((($464)+(2))|0);
   var $467=(($408+($_sum1298<<2))|0);
   HEAP32[(($467)>>2)]=1;
   var $468=((($nedges_i52_1)+(1))|0);
   var $nedges_i52_2 = $468;label = 128; break;
  case 128: 
   var $nedges_i52_2;
   var $470=((($j4_i57_0)+(1))|0);
   var $storemerge3_i67 = $j4_i57_0;var $nedges_i52_1 = $nedges_i52_2;var $j4_i57_0 = $470;label = 115; break;
  case 129: 
   var $472=((($storemerge1_i66)+(1))|0);
   var $storemerge1_i66 = $472;var $nedges_i52_0 = $nedges_i52_1;label = 109; break;
  case 130: 
   var $numOpenEdges_i_0;
   var $storemerge2_i70;
   var $474=(($storemerge2_i70)|(0)) < (($nedges_i52_0)|(0));
   if ($474) { label = 131; break; } else { label = 132; break; }
  case 131: 
   var $476=((($storemerge2_i70)*(3))&-1);
   var $477=((($476)+(2))|0);
   var $478=(($408+($477<<2))|0);
   var $479=HEAP32[(($478)>>2)];
   var $480=(($479)|(0)) < 2;
   var $481=((($numOpenEdges_i_0)+(1))|0);
   var $_numOpenEdges_i_0=$480 ? $481 : $numOpenEdges_i_0;
   var $482=((($storemerge2_i70)+(1))|0);
   var $storemerge2_i70 = $482;var $numOpenEdges_i_0 = $_numOpenEdges_i_0;label = 130; break;
  case 132: 
   var $484=(($numOpenEdges_i_0)|(0)) > 2;
   var $_=$484 ? 0 : 1;
   var $485=(($407)|(0))==0;
   if ($485) { label = 134; break; } else { label = 133; break; }
  case 133: 
   _free($407);
   if ($_) { label = 135; break; } else { var $i9_0 = $storemerge3;label = 308; break; }
  case 134: 
   if ($_) { label = 135; break; } else { var $i9_0 = $storemerge3;label = 308; break; }
  case 135: 
   var $488=HEAP32[(($98)>>2)];
   var $489=HEAP32[(($97)>>2)];
   var $storemerge_i33 = 0;var $numRemovedVerts_i_0 = 0;label = 136; break;
  case 136: 
   var $numRemovedVerts_i_0;
   var $storemerge_i33;
   var $491=(($storemerge_i33)|(0)) < (($489)|(0));
   if ($491) { label = 137; break; } else { label = 145; break; }
  case 137: 
   var $493=(Math.imul($storemerge_i33,$488)|0);
   var $494=$493 << 1;
   var $495=HEAP32[(($79)>>2)];
   var $storemerge_i_i = 0;label = 138; break;
  case 138: 
   var $storemerge_i_i;
   var $497=(($storemerge_i_i)|(0)) < (($488)|(0));
   if ($497) { label = 139; break; } else { var $storemerge1_i_i_in_sroa_speculated = $488;label = 141; break; }
  case 139: 
   var $_sum1294=((($494)+($storemerge_i_i))|0);
   var $499=(($495+($_sum1294<<1))|0);
   var $500=HEAP16[(($499)>>1)];
   var $501=(($500 << 16) >> 16)==-1;
   if ($501) { var $storemerge1_i_i_in_sroa_speculated = $storemerge_i_i;label = 141; break; } else { label = 140; break; }
  case 140: 
   var $503=((($storemerge_i_i)+(1))|0);
   var $storemerge_i_i = $503;label = 138; break;
  case 141: 
   var $storemerge1_i_i_in_sroa_speculated;
   var $storemerge15_i = 0;var $numRemovedVerts_i_1 = $numRemovedVerts_i_0;label = 142; break;
  case 142: 
   var $numRemovedVerts_i_1;
   var $storemerge15_i;
   var $505=(($storemerge15_i)|(0)) < (($storemerge1_i_i_in_sroa_speculated)|(0));
   if ($505) { label = 143; break; } else { label = 144; break; }
  case 143: 
   var $_sum1293=((($494)+($storemerge15_i))|0);
   var $507=(($495+($_sum1293<<1))|0);
   var $508=HEAP16[(($507)>>1)];
   var $509=(($508 << 16) >> 16)==(($365 << 16) >> 16);
   var $510=((($numRemovedVerts_i_1)+(1))|0);
   var $_numRemovedVerts_i_1=$509 ? $510 : $numRemovedVerts_i_1;
   var $511=((($storemerge15_i)+(1))|0);
   var $storemerge15_i = $511;var $numRemovedVerts_i_1 = $_numRemovedVerts_i_1;label = 142; break;
  case 144: 
   var $513=((($storemerge_i33)+(1))|0);
   var $storemerge_i33 = $513;var $numRemovedVerts_i_0 = $numRemovedVerts_i_1;label = 136; break;
  case 145: 
   var $515=$numRemovedVerts_i_0 << 2;
   var $516=(Math.imul($515,$488)|0);
   var $517=$516 << 2;
   var $518=_malloc($517);
   var $519=$518;
   var $520=(($518)|(0))==0;
   if ($520) { label = 146; break; } else { label = 148; break; }
  case 146: 
   var $522=(Math.imul($numRemovedVerts_i_0,$488)|0);
   var $523=$522 << 2;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3488)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$523,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 304; break; } else { label = 147; break; }
  case 147: 
   var $524$0 = ___cxa_find_matching_catch(-1, -1); $524$1 = tempRet0;
   var $525=$524$0;
   var $526=$524$1;
   var $_811771347 = $526;var $_811681348 = $525;label = 301; break;
  case 148: 
   var $528=_malloc($516);
   var $529=$528;
   var $530=(($528)|(0))==0;
   if ($530) { label = 149; break; } else { label = 151; break; }
  case 149: 
   var $532=(Math.imul($numRemovedVerts_i_0,$488)|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3416)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$532,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 303; break; } else { label = 150; break; }
  case 150: 
   var $533$0 = ___cxa_find_matching_catch(-1, -1); $533$1 = tempRet0;
   var $534=$533$0;
   var $535=$533$1;
   var $_81168 = $534;var $_81177 = $535;label = 299; break;
  case 151: 
   var $537=_malloc($516);
   var $538=$537;
   var $539=(($537)|(0))==0;
   if ($539) { label = 152; break; } else { label = 154; break; }
  case 152: 
   var $541=(Math.imul($numRemovedVerts_i_0,$488)|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3320)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$541,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_81370 = 0;label = 294; break; } else { label = 153; break; }
  case 153: 
   var $542$0 = ___cxa_find_matching_catch(-1, -1); $542$1 = tempRet0;
   var $543=$542$0;
   var $544=$542$1;
   var $_71167 = $543;var $_71176 = $544;label = 295; break;
  case 154: 
   var $546=_malloc($516);
   var $547=$546;
   var $548=(($546)|(0))==0;
   if ($548) { label = 156; break; } else { label = 155; break; }
  case 155: 
   var $549=$488 << 1;
   var $_pre1239=HEAP32[(($97)>>2)];
   var $storemerge1_i34 = 0;var $nedges_i_0 = 0;var $556 = $_pre1239;label = 158; break;
  case 156: 
   var $551=(Math.imul($numRemovedVerts_i_0,$488)|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3232)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$551,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_71369 = 0;label = 290; break; } else { label = 157; break; }
  case 157: 
   var $552$0 = ___cxa_find_matching_catch(-1, -1); $552$1 = tempRet0;
   var $553=$552$0;
   var $554=$552$1;
   var $_61166 = $553;var $_61175 = $554;label = 291; break;
  case 158: 
   var $556;
   var $nedges_i_0;
   var $storemerge1_i34;
   var $557=(($storemerge1_i34)|(0)) < (($556)|(0));
   if ($557) { label = 159; break; } else { label = 175; break; }
  case 159: 
   var $559=(Math.imul($storemerge1_i34,$488)|0);
   var $560=$559 << 1;
   var $561=HEAP32[(($79)>>2)];
   var $562=(($561+($560<<1))|0);
   var $storemerge_i25_i = 0;label = 160; break;
  case 160: 
   var $storemerge_i25_i;
   var $564=(($storemerge_i25_i)|(0)) < (($488)|(0));
   if ($564) { label = 161; break; } else { var $storemerge1_i26_i_in_sroa_speculated = $488;label = 163; break; }
  case 161: 
   var $_sum1292=((($560)+($storemerge_i25_i))|0);
   var $566=(($561+($_sum1292<<1))|0);
   var $567=HEAP16[(($566)>>1)];
   var $568=(($567 << 16) >> 16)==-1;
   if ($568) { var $storemerge1_i26_i_in_sroa_speculated = $storemerge_i25_i;label = 163; break; } else { label = 162; break; }
  case 162: 
   var $570=((($storemerge_i25_i)+(1))|0);
   var $storemerge_i25_i = $570;label = 160; break;
  case 163: 
   var $storemerge1_i26_i_in_sroa_speculated;
   var $storemerge13_i = 0;var $hasRem_i_0 = 0;label = 164; break;
  case 164: 
   var $hasRem_i_0;
   var $storemerge13_i;
   var $572=(($storemerge13_i)|(0)) < (($storemerge1_i26_i_in_sroa_speculated)|(0));
   if ($572) { label = 165; break; } else { label = 166; break; }
  case 165: 
   var $_sum1291=((($560)+($storemerge13_i))|0);
   var $574=(($561+($_sum1291<<1))|0);
   var $575=HEAP16[(($574)>>1)];
   var $576=(($575 << 16) >> 16)==(($365 << 16) >> 16);
   var $_hasRem_i_0=$576 ? 1 : $hasRem_i_0;
   var $577=((($storemerge13_i)+(1))|0);
   var $storemerge13_i = $577;var $hasRem_i_0 = $_hasRem_i_0;label = 164; break;
  case 166: 
   var $579=$hasRem_i_0 & 1;
   var $580=(($579 << 24) >> 24)==0;
   if ($580) { var $nedges_i_3 = $nedges_i_0;var $i1_i28_0 = $storemerge1_i34;var $640 = $556;label = 174; break; } else { label = 167; break; }
  case 167: 
   var $582=((($storemerge1_i26_i_in_sroa_speculated)-(1))|0);
   var $storemerge14_i = $582;var $nedges_i_1 = $nedges_i_0;var $j5_i_0 = 0;label = 168; break;
  case 168: 
   var $j5_i_0;
   var $nedges_i_1;
   var $storemerge14_i;
   var $584=(($j5_i_0)|(0)) < (($storemerge1_i26_i_in_sroa_speculated)|(0));
   if ($584) { label = 169; break; } else { label = 173; break; }
  case 169: 
   var $_sum1283=((($560)+($j5_i_0))|0);
   var $586=(($561+($_sum1283<<1))|0);
   var $587=HEAP16[(($586)>>1)];
   var $588=(($587 << 16) >> 16)==(($365 << 16) >> 16);
   if ($588) { var $nedges_i_2 = $nedges_i_1;label = 172; break; } else { label = 170; break; }
  case 170: 
   var $_sum1284=((($560)+($storemerge14_i))|0);
   var $590=(($561+($_sum1284<<1))|0);
   var $591=HEAP16[(($590)>>1)];
   var $592=(($591 << 16) >> 16)==(($365 << 16) >> 16);
   if ($592) { var $nedges_i_2 = $nedges_i_1;label = 172; break; } else { label = 171; break; }
  case 171: 
   var $594=$nedges_i_1 << 2;
   var $595=(($519+($594<<2))|0);
   var $596=(($591)&(65535));
   HEAP32[(($595)>>2)]=$596;
   var $597=HEAP16[(($586)>>1)];
   var $598=(($597)&(65535));
   var $_sum12851286=$594 | 1;
   var $599=(($519+($_sum12851286<<2))|0);
   HEAP32[(($599)>>2)]=$598;
   var $600=HEAP32[(($87)>>2)];
   var $601=(($600+($storemerge1_i34<<1))|0);
   var $602=HEAP16[(($601)>>1)];
   var $603=(($602)&(65535));
   var $_sum12871288=$594 | 2;
   var $604=(($519+($_sum12871288<<2))|0);
   HEAP32[(($604)>>2)]=$603;
   var $605=HEAP32[(($92)>>2)];
   var $606=(($605+$storemerge1_i34)|0);
   var $607=HEAP8[($606)];
   var $608=(($607)&(255));
   var $_sum12891290=$594 | 3;
   var $609=(($519+($_sum12891290<<2))|0);
   HEAP32[(($609)>>2)]=$608;
   var $610=((($nedges_i_1)+(1))|0);
   var $nedges_i_2 = $610;label = 172; break;
  case 172: 
   var $nedges_i_2;
   var $612=((($j5_i_0)+(1))|0);
   var $storemerge14_i = $j5_i_0;var $nedges_i_1 = $nedges_i_2;var $j5_i_0 = $612;label = 168; break;
  case 173: 
   var $614=HEAP32[(($97)>>2)];
   var $615=((($614)-(1))|0);
   var $616=(Math.imul($615,$488)|0);
   var $617=$616 << 1;
   var $618=HEAP32[(($79)>>2)];
   var $619=(($618+($617<<1))|0);
   var $620=$562;
   var $621=$619;
   assert($549 % 1 === 0);(_memcpy($620, $621, $549)|0);
   var $_sum1282=((($560)+($488))|0);
   var $622=(($561+($_sum1282<<1))|0);
   var $623=$622;
   _memset($623, -1, $549);
   var $624=HEAP32[(($97)>>2)];
   var $625=((($624)-(1))|0);
   var $626=HEAP32[(($87)>>2)];
   var $627=(($626+($625<<1))|0);
   var $628=HEAP16[(($627)>>1)];
   var $629=(($626+($storemerge1_i34<<1))|0);
   HEAP16[(($629)>>1)]=$628;
   var $630=HEAP32[(($97)>>2)];
   var $631=((($630)-(1))|0);
   var $632=HEAP32[(($92)>>2)];
   var $633=(($632+$631)|0);
   var $634=HEAP8[($633)];
   var $635=(($632+$storemerge1_i34)|0);
   HEAP8[($635)]=$634;
   var $636=HEAP32[(($97)>>2)];
   var $637=((($636)-(1))|0);
   HEAP32[(($97)>>2)]=$637;
   var $638=((($storemerge1_i34)-(1))|0);
   var $nedges_i_3 = $nedges_i_1;var $i1_i28_0 = $638;var $640 = $637;label = 174; break;
  case 174: 
   var $640;
   var $i1_i28_0;
   var $nedges_i_3;
   var $641=((($i1_i28_0)+(1))|0);
   var $storemerge1_i34 = $641;var $nedges_i_0 = $nedges_i_3;var $556 = $640;label = 158; break;
  case 175: 
   var $643=$storemerge3 & 65535;
   var $storemerge2_i35 = $643;label = 176; break;
  case 176: 
   var $storemerge2_i35;
   var $645=HEAP32[(($96)>>2)];
   var $646=(($storemerge2_i35)|(0)) < (($645)|(0));
   if ($646) { label = 177; break; } else { label = 178; break; }
  case 177: 
   var $648=((($storemerge2_i35)*(3))&-1);
   var $649=((($648)+(3))|0);
   var $650=HEAP32[(($70)>>2)];
   var $651=(($650+($649<<1))|0);
   var $652=HEAP16[(($651)>>1)];
   var $653=(($650+($648<<1))|0);
   HEAP16[(($653)>>1)]=$652;
   var $654=((($648)+(4))|0);
   var $655=HEAP32[(($70)>>2)];
   var $656=(($655+($654<<1))|0);
   var $657=HEAP16[(($656)>>1)];
   var $658=((($648)+(1))|0);
   var $659=(($655+($658<<1))|0);
   HEAP16[(($659)>>1)]=$657;
   var $660=((($648)+(5))|0);
   var $661=HEAP32[(($70)>>2)];
   var $662=(($661+($660<<1))|0);
   var $663=HEAP16[(($662)>>1)];
   var $664=((($648)+(2))|0);
   var $665=(($661+($664<<1))|0);
   HEAP16[(($665)>>1)]=$663;
   var $666=((($storemerge2_i35)+(1))|0);
   var $storemerge2_i35 = $666;label = 176; break;
  case 178: 
   var $668=((($645)-(1))|0);
   HEAP32[(($96)>>2)]=$668;
   var $storemerge3_i36 = 0;label = 179; break;
  case 179: 
   var $storemerge3_i36;
   var $670=HEAP32[(($97)>>2)];
   var $671=(($storemerge3_i36)|(0)) < (($670)|(0));
   if ($671) { label = 180; break; } else { var $storemerge4_i37 = 0;label = 190; break; }
  case 180: 
   var $673=(Math.imul($storemerge3_i36,$488)|0);
   var $674=$673 << 1;
   var $675=HEAP32[(($79)>>2)];
   var $storemerge_i31_i = 0;label = 181; break;
  case 181: 
   var $storemerge_i31_i;
   var $677=(($storemerge_i31_i)|(0)) < (($488)|(0));
   if ($677) { label = 182; break; } else { var $storemerge1_i32_i_in_sroa_speculated = $488;label = 184; break; }
  case 182: 
   var $_sum1281=((($674)+($storemerge_i31_i))|0);
   var $679=(($675+($_sum1281<<1))|0);
   var $680=HEAP16[(($679)>>1)];
   var $681=(($680 << 16) >> 16)==-1;
   if ($681) { var $storemerge1_i32_i_in_sroa_speculated = $storemerge_i31_i;label = 184; break; } else { label = 183; break; }
  case 183: 
   var $683=((($storemerge_i31_i)+(1))|0);
   var $storemerge_i31_i = $683;label = 181; break;
  case 184: 
   var $storemerge1_i32_i_in_sroa_speculated;
   var $storemerge12_i = 0;label = 185; break;
  case 185: 
   var $storemerge12_i;
   var $685=(($storemerge12_i)|(0)) < (($storemerge1_i32_i_in_sroa_speculated)|(0));
   if ($685) { label = 186; break; } else { label = 189; break; }
  case 186: 
   var $_sum1280=((($674)+($storemerge12_i))|0);
   var $687=(($675+($_sum1280<<1))|0);
   var $688=HEAP16[(($687)>>1)];
   var $689=(($688)&(65535)) > (($365)&(65535));
   if ($689) { label = 187; break; } else { label = 188; break; }
  case 187: 
   var $691=((($688)-(1))&65535);
   HEAP16[(($687)>>1)]=$691;
   label = 188; break;
  case 188: 
   var $693=((($storemerge12_i)+(1))|0);
   var $storemerge12_i = $693;label = 185; break;
  case 189: 
   var $695=((($storemerge3_i36)+(1))|0);
   var $storemerge3_i36 = $695;label = 179; break;
  case 190: 
   var $storemerge4_i37;
   var $696=(($storemerge4_i37)|(0)) < (($nedges_i_0)|(0));
   if ($696) { label = 191; break; } else { label = 196; break; }
  case 191: 
   var $698=$storemerge4_i37 << 2;
   var $699=(($519+($698<<2))|0);
   var $700=HEAP32[(($699)>>2)];
   var $701=(($700)|(0)) > (($643)|(0));
   if ($701) { label = 192; break; } else { label = 193; break; }
  case 192: 
   var $703=((($700)-(1))|0);
   HEAP32[(($699)>>2)]=$703;
   label = 193; break;
  case 193: 
   var $705=$698 | 1;
   var $706=(($519+($705<<2))|0);
   var $707=HEAP32[(($706)>>2)];
   var $708=(($707)|(0)) > (($643)|(0));
   if ($708) { label = 194; break; } else { label = 195; break; }
  case 194: 
   var $710=((($707)-(1))|0);
   HEAP32[(($706)>>2)]=$710;
   label = 195; break;
  case 195: 
   var $712=((($storemerge4_i37)+(1))|0);
   var $storemerge4_i37 = $712;label = 190; break;
  case 196: 
   var $714=(($nedges_i_0)|(0))==0;
   if ($714) { var $_6 = 1;label = 285; break; } else { label = 197; break; }
  case 197: 
   var $716=HEAP32[(($519)>>2)];
   HEAP32[(($529)>>2)]=$716;
   var $717=(($518+8)|0);
   var $718=$717;
   var $719=HEAP32[(($718)>>2)];
   HEAP32[(($538)>>2)]=$719;
   var $720=(($518+12)|0);
   var $721=$720;
   var $722=HEAP32[(($721)>>2)];
   HEAP32[(($547)>>2)]=$722;
   var $nedges_i_4 = $nedges_i_0;var $nharea_i_0 = 1;var $nhreg_i_0 = 1;var $nhole_i_0 = 1;label = 198; break;
  case 198: 
   var $nhole_i_0;
   var $nhreg_i_0;
   var $nharea_i_0;
   var $nedges_i_4;
   var $724=(($nedges_i_4)|(0))==0;
   if ($724) { var $nhole_i_3 = $nhole_i_0;label = 216; break; } else { var $storemerge11_i = 0;var $nedges_i_5 = $nedges_i_4;var $match_i_0 = 0;var $nharea_i_1 = $nharea_i_0;var $nhreg_i_1 = $nhreg_i_0;var $nhole_i_1 = $nhole_i_0;label = 199; break; }
  case 199: 
   var $nhole_i_1;
   var $nhreg_i_1;
   var $nharea_i_1;
   var $match_i_0;
   var $nedges_i_5;
   var $storemerge11_i;
   var $726=(($storemerge11_i)|(0)) < (($nedges_i_5)|(0));
   if ($726) { label = 200; break; } else { label = 215; break; }
  case 200: 
   var $728=$storemerge11_i << 2;
   var $729=(($519+($728<<2))|0);
   var $730=HEAP32[(($729)>>2)];
   var $731=$728 | 1;
   var $732=(($519+($731<<2))|0);
   var $733=HEAP32[(($732)>>2)];
   var $734=$728 | 2;
   var $735=(($519+($734<<2))|0);
   var $736=HEAP32[(($735)>>2)];
   var $737=$728 | 3;
   var $738=(($519+($737<<2))|0);
   var $739=HEAP32[(($738)>>2)];
   var $740=HEAP32[(($529)>>2)];
   var $741=(($740)|(0))==(($733)|(0));
   if ($741) { label = 201; break; } else { label = 211; break; }
  case 201: 
   var $743=((($nhole_i_1)+(1))|0);
   var $storemerge_in_i_i = $743;label = 202; break;
  case 202: 
   var $storemerge_in_i_i;
   var $storemerge_i42_i=((($storemerge_in_i_i)-(1))|0);
   var $745=(($storemerge_i42_i)|(0)) > 0;
   if ($745) { label = 203; break; } else { label = 204; break; }
  case 203: 
   var $747=((($storemerge_in_i_i)-(2))|0);
   var $748=(($529+($747<<2))|0);
   var $749=HEAP32[(($748)>>2)];
   var $750=(($529+($storemerge_i42_i<<2))|0);
   HEAP32[(($750)>>2)]=$749;
   var $storemerge_in_i_i = $storemerge_i42_i;label = 202; break;
  case 204: 
   HEAP32[(($529)>>2)]=$730;
   var $751=((($nhreg_i_1)+(1))|0);
   var $storemerge_in_i44_i = $751;label = 205; break;
  case 205: 
   var $storemerge_in_i44_i;
   var $storemerge_i45_i=((($storemerge_in_i44_i)-(1))|0);
   var $753=(($storemerge_i45_i)|(0)) > 0;
   if ($753) { label = 206; break; } else { label = 207; break; }
  case 206: 
   var $755=((($storemerge_in_i44_i)-(2))|0);
   var $756=(($538+($755<<2))|0);
   var $757=HEAP32[(($756)>>2)];
   var $758=(($538+($storemerge_i45_i<<2))|0);
   HEAP32[(($758)>>2)]=$757;
   var $storemerge_in_i44_i = $storemerge_i45_i;label = 205; break;
  case 207: 
   HEAP32[(($538)>>2)]=$736;
   var $759=((($nharea_i_1)+(1))|0);
   var $storemerge_in_i48_i = $759;label = 208; break;
  case 208: 
   var $storemerge_in_i48_i;
   var $storemerge_i49_i=((($storemerge_in_i48_i)-(1))|0);
   var $761=(($storemerge_i49_i)|(0)) > 0;
   if ($761) { label = 209; break; } else { label = 210; break; }
  case 209: 
   var $763=((($storemerge_in_i48_i)-(2))|0);
   var $764=(($547+($763<<2))|0);
   var $765=HEAP32[(($764)>>2)];
   var $766=(($547+($storemerge_i49_i<<2))|0);
   HEAP32[(($766)>>2)]=$765;
   var $storemerge_in_i48_i = $storemerge_i49_i;label = 208; break;
  case 210: 
   HEAP32[(($547)>>2)]=$739;
   var $nharea_i_2_ph = $759;var $nhreg_i_2_ph = $751;var $nhole_i_2_ph = $743;label = 213; break;
  case 211: 
   var $768=((($nhole_i_1)-(1))|0);
   var $769=(($529+($768<<2))|0);
   var $770=HEAP32[(($769)>>2)];
   var $771=(($770)|(0))==(($730)|(0));
   if ($771) { label = 212; break; } else { var $nedges_i_6 = $nedges_i_5;var $match_i_1 = $match_i_0;var $i13_i_0 = $storemerge11_i;var $nhole_i_21320 = $nhole_i_1;var $nhreg_i_21322 = $nhreg_i_1;var $nharea_i_21324 = $nharea_i_1;label = 214; break; }
  case 212: 
   var $773=(($529+($nhole_i_1<<2))|0);
   HEAP32[(($773)>>2)]=$733;
   var $774=((($nhole_i_1)+(1))|0);
   var $775=(($538+($nhreg_i_1<<2))|0);
   HEAP32[(($775)>>2)]=$736;
   var $776=((($nhreg_i_1)+(1))|0);
   var $777=(($547+($nharea_i_1<<2))|0);
   HEAP32[(($777)>>2)]=$739;
   var $778=((($nharea_i_1)+(1))|0);
   var $nharea_i_2_ph = $778;var $nhreg_i_2_ph = $776;var $nhole_i_2_ph = $774;label = 213; break;
  case 213: 
   var $nhole_i_2_ph;
   var $nhreg_i_2_ph;
   var $nharea_i_2_ph;
   var $780=$nedges_i_5 << 2;
   var $781=((($780)-(4))|0);
   var $782=(($519+($781<<2))|0);
   var $783=HEAP32[(($782)>>2)];
   HEAP32[(($729)>>2)]=$783;
   var $784=((($780)-(3))|0);
   var $785=(($519+($784<<2))|0);
   var $786=HEAP32[(($785)>>2)];
   HEAP32[(($732)>>2)]=$786;
   var $787=((($780)-(2))|0);
   var $788=(($519+($787<<2))|0);
   var $789=HEAP32[(($788)>>2)];
   HEAP32[(($735)>>2)]=$789;
   var $790=((($780)-(1))|0);
   var $791=(($519+($790<<2))|0);
   var $792=HEAP32[(($791)>>2)];
   HEAP32[(($738)>>2)]=$792;
   var $793=((($nedges_i_5)-(1))|0);
   var $794=((($storemerge11_i)-(1))|0);
   var $nedges_i_6 = $793;var $match_i_1 = 1;var $i13_i_0 = $794;var $nhole_i_21320 = $nhole_i_2_ph;var $nhreg_i_21322 = $nhreg_i_2_ph;var $nharea_i_21324 = $nharea_i_2_ph;label = 214; break;
  case 214: 
   var $nharea_i_21324;
   var $nhreg_i_21322;
   var $nhole_i_21320;
   var $i13_i_0;
   var $match_i_1;
   var $nedges_i_6;
   var $796=((($i13_i_0)+(1))|0);
   var $storemerge11_i = $796;var $nedges_i_5 = $nedges_i_6;var $match_i_0 = $match_i_1;var $nharea_i_1 = $nharea_i_21324;var $nhreg_i_1 = $nhreg_i_21322;var $nhole_i_1 = $nhole_i_21320;label = 199; break;
  case 215: 
   var $798=$match_i_0 & 1;
   var $799=(($798 << 24) >> 24)==0;
   if ($799) { var $nhole_i_3 = $nhole_i_1;label = 216; break; } else { var $nedges_i_4 = $nedges_i_5;var $nharea_i_0 = $nharea_i_1;var $nhreg_i_0 = $nhreg_i_1;var $nhole_i_0 = $nhole_i_1;label = 198; break; }
  case 216: 
   var $nhole_i_3;
   var $801=((($nhole_i_3)*(12))&-1);
   var $802=_malloc($801);
   var $803=$802;
   var $804=(($802)|(0))==0;
   if ($804) { label = 217; break; } else { label = 219; break; }
  case 217: 
   var $806=((($nhole_i_3)*(3))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3128)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$806,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_6 = 0;label = 285; break; } else { label = 218; break; }
  case 218: 
   var $807$0 = ___cxa_find_matching_catch(-1, -1); $807$1 = tempRet0;
   var $808=$807$0;
   var $809=$807$1;
   var $_51165 = $808;var $_51174 = $809;label = 287; break;
  case 219: 
   var $811=$nhole_i_3 << 4;
   var $812=_malloc($811);
   var $813=$812;
   var $814=(($812)|(0))==0;
   var $815=$nhole_i_3 << 2;
   if ($814) { label = 220; break; } else { label = 222; break; }
  case 220: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((3040)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$815,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_51368 = 0;label = 282; break; } else { label = 221; break; }
  case 221: 
   var $817$0 = ___cxa_find_matching_catch(-1, -1); $817$1 = tempRet0;
   var $818=$817$0;
   var $819=$817$1;
   var $_41164 = $818;var $_41173 = $819;label = 283; break;
  case 222: 
   var $820=_malloc($815);
   var $821=$820;
   var $822=(($812)|(0))==0;
   var $storemerge5_i38 = 0;label = 224; break;
  case 223: 
   var $824$0 = ___cxa_find_matching_catch(-1, -1); $824$1 = tempRet0;
   var $825=$824$0;
   var $826=$824$1;
   var $_21162 = $825;var $_21171 = $826;label = 275; break;
  case 224: 
   var $storemerge5_i38;
   var $828=(($storemerge5_i38)|(0)) < (($nhole_i_3)|(0));
   if ($828) { label = 225; break; } else { label = 226; break; }
  case 225: 
   var $830=(($529+($storemerge5_i38<<2))|0);
   var $831=HEAP32[(($830)>>2)];
   var $832=((($831)*(3))&-1);
   var $833=HEAP32[(($70)>>2)];
   var $834=(($833+($832<<1))|0);
   var $835=HEAP16[(($834)>>1)];
   var $836=$storemerge5_i38 << 2;
   var $837=(($835)&(65535));
   var $838=(($813+($836<<2))|0);
   HEAP32[(($838)>>2)]=$837;
   var $839=((($832)+(1))|0);
   var $840=HEAP32[(($70)>>2)];
   var $841=(($840+($839<<1))|0);
   var $842=HEAP16[(($841)>>1)];
   var $843=$836 | 1;
   var $844=(($842)&(65535));
   var $845=(($813+($843<<2))|0);
   HEAP32[(($845)>>2)]=$844;
   var $846=((($832)+(2))|0);
   var $847=HEAP32[(($70)>>2)];
   var $848=(($847+($846<<1))|0);
   var $849=HEAP16[(($848)>>1)];
   var $850=$836 | 2;
   var $851=(($849)&(65535));
   var $852=(($813+($850<<2))|0);
   HEAP32[(($852)>>2)]=$851;
   var $853=$836 | 3;
   var $854=(($813+($853<<2))|0);
   HEAP32[(($854)>>2)]=0;
   var $855=(($821+($storemerge5_i38<<2))|0);
   HEAP32[(($855)>>2)]=$storemerge5_i38;
   var $856=((($storemerge5_i38)+(1))|0);
   var $storemerge5_i38 = $856;label = 224; break;
  case 226: 
   var $858=__ZL11triangulateiPKiPiS1_($nhole_i_3, $813, $821, $803);
   var $859=(($858)|(0)) < 0;
   if ($859) { label = 227; break; } else { var $ntris_i_0 = $858;label = 228; break; }
  case 227: 
   var $861=(((-$858))|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((2872)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $ntris_i_0 = $861;label = 228; break; } else { label = 223; break; }
  case 228: 
   var $ntris_i_0;
   var $863=$ntris_i_0 << 1;
   var $864=((($863)+(2))|0);
   var $865=(Math.imul($864,$488)|0);
   var $866=_malloc($865);
   var $867=$866;
   var $868=(($866)|(0))==0;
   if ($868) { label = 229; break; } else { label = 231; break; }
  case 229: 
   var $870=((($ntris_i_0)+(1))|0);
   var $871=(Math.imul($870,$488)|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2792)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$871,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_21328 = 0;label = 273; break; } else { label = 230; break; }
  case 230: 
   var $872$0 = ___cxa_find_matching_catch(-1, -1); $872$1 = tempRet0;
   var $873=$872$0;
   var $874=$872$1;
   var $_21162 = $873;var $_21171 = $874;label = 275; break;
  case 231: 
   var $876=_malloc($863);
   var $877=$876;
   var $878=(($876)|(0))==0;
   if ($878) { label = 232; break; } else { label = 236; break; }
  case 232: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2552)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$ntris_i_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_21367 = 0;label = 270; break; } else { label = 233; break; }
  case 233: 
   var $880$0 = ___cxa_find_matching_catch(-1, -1); $880$1 = tempRet0;
   var $881=$880$0;
   var $882=$880$1;
   var $_11161 = $881;var $_11170 = $882;label = 271; break;
  case 234: 
   var $884$0 = ___cxa_find_matching_catch(-1, -1); $884$1 = tempRet0;
   var $885=$884$0;
   var $886=$884$1;
   var $887=(($890)|(0))==0;
   if ($887) { label = 267; break; } else { label = 235; break; }
  case 235: 
   _free($890);
   label = 267; break;
  case 236: 
   var $890=_malloc($ntris_i_0);
   var $891=(($876)|(0))==0;
   var $892=(Math.imul($ntris_i_0,$488)|0);
   var $893=(($867+($892<<1))|0);
   var $894=$892 << 1;
   _memset($866, -1, $894);
   var $storemerge6_i39 = 0;var $npolys_i_0 = 0;label = 237; break;
  case 237: 
   var $npolys_i_0;
   var $storemerge6_i39;
   var $896=(($storemerge6_i39)|(0)) < (($ntris_i_0)|(0));
   if ($896) { label = 238; break; } else { label = 242; break; }
  case 238: 
   var $898=((($storemerge6_i39)*(3))&-1);
   var $899=(($803+($898<<2))|0);
   var $900=HEAP32[(($899)>>2)];
   var $_sum_i=((($898)+(1))|0);
   var $901=(($803+($_sum_i<<2))|0);
   var $902=HEAP32[(($901)>>2)];
   var $903=(($900)|(0))==(($902)|(0));
   if ($903) { var $npolys_i_1 = $npolys_i_0;label = 241; break; } else { label = 239; break; }
  case 239: 
   var $_sum1278=((($898)+(2))|0);
   var $905=(($803+($_sum1278<<2))|0);
   var $906=HEAP32[(($905)>>2)];
   var $907=(($900)|(0))==(($906)|(0));
   var $908=(($902)|(0))==(($906)|(0));
   var $or_cond1376=$907 | $908;
   if ($or_cond1376) { var $npolys_i_1 = $npolys_i_0;label = 241; break; } else { label = 240; break; }
  case 240: 
   var $_sum1279=((($898)+(1))|0);
   var $910=(($803+($_sum1279<<2))|0);
   var $911=(($529+($900<<2))|0);
   var $912=HEAP32[(($911)>>2)];
   var $913=(Math.imul($npolys_i_0,$488)|0);
   var $914=(($912) & 65535);
   var $915=(($867+($913<<1))|0);
   HEAP16[(($915)>>1)]=$914;
   var $916=HEAP32[(($910)>>2)];
   var $917=(($529+($916<<2))|0);
   var $918=HEAP32[(($917)>>2)];
   var $919=((($913)+(1))|0);
   var $920=(($918) & 65535);
   var $921=(($867+($919<<1))|0);
   HEAP16[(($921)>>1)]=$920;
   var $922=HEAP32[(($905)>>2)];
   var $923=(($529+($922<<2))|0);
   var $924=HEAP32[(($923)>>2)];
   var $925=((($913)+(2))|0);
   var $926=(($924) & 65535);
   var $927=(($867+($925<<1))|0);
   HEAP16[(($927)>>1)]=$926;
   var $928=HEAP32[(($899)>>2)];
   var $929=(($538+($928<<2))|0);
   var $930=HEAP32[(($929)>>2)];
   var $931=(($930) & 65535);
   var $932=(($877+($npolys_i_0<<1))|0);
   HEAP16[(($932)>>1)]=$931;
   var $933=HEAP32[(($899)>>2)];
   var $934=(($547+($933<<2))|0);
   var $935=HEAP32[(($934)>>2)];
   var $936=(($935) & 255);
   var $937=(($890+$npolys_i_0)|0);
   HEAP8[($937)]=$936;
   var $938=((($npolys_i_0)+(1))|0);
   var $npolys_i_1 = $938;label = 241; break;
  case 241: 
   var $npolys_i_1;
   var $940=((($storemerge6_i39)+(1))|0);
   var $storemerge6_i39 = $940;var $npolys_i_0 = $npolys_i_1;label = 237; break;
  case 242: 
   var $942=(($npolys_i_0)|(0))==0;
   if ($942) { var $_01159 = 1;label = 263; break; } else { label = 243; break; }
  case 243: 
   var $944=(($488)|(0)) > 3;
   if ($944) { var $npolys_i_2 = $npolys_i_0;label = 244; break; } else { var $npolys_i_3_ph = $npolys_i_0;label = 254; break; }
  case 244: 
   var $npolys_i_2;
   var $945=((($npolys_i_2)-(1))|0);
   var $storemerge9_i = 0;var $bestMergeVal_i_0 = 0;var $bestPa_i_0 = 0;var $bestPb_i_0 = 0;var $bestEa_i_0 = 0;var $bestEb_i_0 = 0;label = 245; break;
  case 245: 
   var $bestEb_i_0;
   var $bestEa_i_0;
   var $bestPb_i_0;
   var $bestPa_i_0;
   var $bestMergeVal_i_0;
   var $storemerge9_i;
   var $947=(($storemerge9_i)|(0)) < (($945)|(0));
   if ($947) { label = 246; break; } else { label = 252; break; }
  case 246: 
   var $949=(Math.imul($storemerge9_i,$488)|0);
   var $950=(($867+($949<<1))|0);
   var $storemerge10_in_i_in_sroa_speculated_ph = $storemerge9_i;var $bestMergeVal_i_1_ph = $bestMergeVal_i_0;var $bestPa_i_1_ph = $bestPa_i_0;var $bestPb_i_1_ph = $bestPb_i_0;var $bestEa_i_1_ph = $bestEa_i_0;var $bestEb_i_1_ph = $bestEb_i_0;label = 247; break;
  case 247: 
   var $bestEb_i_1_ph;
   var $bestEa_i_1_ph;
   var $bestPb_i_1_ph;
   var $bestPa_i_1_ph;
   var $bestMergeVal_i_1_ph;
   var $storemerge10_in_i_in_sroa_speculated_ph;
   var $storemerge10_in_i_in_sroa_speculated = $storemerge10_in_i_in_sroa_speculated_ph;label = 248; break;
  case 248: 
   var $storemerge10_in_i_in_sroa_speculated;
   var $storemerge10_i=((($storemerge10_in_i_in_sroa_speculated)+(1))|0);
   var $952=(($storemerge10_i)|(0)) < (($npolys_i_2)|(0));
   if ($952) { label = 249; break; } else { label = 251; break; }
  case 249: 
   var $954=(Math.imul($storemerge10_i,$488)|0);
   var $955=(($867+($954<<1))|0);
   var $956=HEAP32[(($70)>>2)];
   var $957=__ZL17getPolyMergeValuePtS_PKtRiS2_i($950, $955, $956, $ea18_i, $eb19_i, $488);
   var $958=(($957)|(0)) > (($bestMergeVal_i_1_ph)|(0));
   if ($958) { label = 250; break; } else { var $storemerge10_in_i_in_sroa_speculated = $storemerge10_i;label = 248; break; }
  case 250: 
   var $960=HEAP32[(($ea18_i)>>2)];
   var $961=HEAP32[(($eb19_i)>>2)];
   var $storemerge10_in_i_in_sroa_speculated_ph = $storemerge10_i;var $bestMergeVal_i_1_ph = $957;var $bestPa_i_1_ph = $storemerge9_i;var $bestPb_i_1_ph = $storemerge10_i;var $bestEa_i_1_ph = $960;var $bestEb_i_1_ph = $961;label = 247; break;
  case 251: 
   var $963=((($storemerge9_i)+(1))|0);
   var $storemerge9_i = $963;var $bestMergeVal_i_0 = $bestMergeVal_i_1_ph;var $bestPa_i_0 = $bestPa_i_1_ph;var $bestPb_i_0 = $bestPb_i_1_ph;var $bestEa_i_0 = $bestEa_i_1_ph;var $bestEb_i_0 = $bestEb_i_1_ph;label = 245; break;
  case 252: 
   var $965=(($bestMergeVal_i_0)|(0)) > 0;
   if ($965) { label = 253; break; } else { var $npolys_i_3_ph = $npolys_i_2;label = 254; break; }
  case 253: 
   var $967=(Math.imul($bestPa_i_0,$488)|0);
   var $968=(($867+($967<<1))|0);
   var $969=(Math.imul($bestPb_i_0,$488)|0);
   var $970=(($867+($969<<1))|0);
   __ZL10mergePolysPtS_iiS_i($968, $970, $bestEa_i_0, $bestEb_i_0, $893, $488);
   var $971=(Math.imul($945,$488)|0);
   var $972=$970;
   var $973=(($867+($971<<1))|0);
   var $974=$973;
   assert($549 % 1 === 0);(_memcpy($972, $974, $549)|0);
   var $975=(($877+($945<<1))|0);
   var $976=HEAP16[(($975)>>1)];
   var $977=(($877+($bestPb_i_0<<1))|0);
   HEAP16[(($977)>>1)]=$976;
   var $978=(($890+$945)|0);
   var $979=HEAP8[($978)];
   var $980=(($890+$bestPb_i_0)|0);
   HEAP8[($980)]=$979;
   var $npolys_i_2 = $945;label = 244; break;
  case 254: 
   var $npolys_i_3_ph;
   var $981=$488 << 2;
   var $storemerge7_i = 0;label = 255; break;
  case 255: 
   var $storemerge7_i;
   var $983=(($storemerge7_i)|(0)) < (($npolys_i_3_ph)|(0));
   if ($983) { label = 256; break; } else { var $_01159 = 1;label = 263; break; }
  case 256: 
   var $985=HEAP32[(($97)>>2)];
   var $986=(($985)|(0)) < (($maxTris_0)|(0));
   if ($986) { label = 257; break; } else { var $_01159 = 1;label = 263; break; }
  case 257: 
   var $988=(Math.imul($985,$488)|0);
   var $989=$988 << 1;
   var $990=HEAP32[(($79)>>2)];
   var $991=(($990+($989<<1))|0);
   var $992=$991;
   _memset($992, -1, $981);
   var $993=(Math.imul($storemerge7_i,$488)|0);
   var $storemerge8_i = 0;label = 258; break;
  case 258: 
   var $storemerge8_i;
   var $995=(($storemerge8_i)|(0)) < (($488)|(0));
   if ($995) { label = 259; break; } else { label = 260; break; }
  case 259: 
   var $997=((($993)+($storemerge8_i))|0);
   var $998=(($867+($997<<1))|0);
   var $999=HEAP16[(($998)>>1)];
   var $_sum1277=((($989)+($storemerge8_i))|0);
   var $1000=(($990+($_sum1277<<1))|0);
   HEAP16[(($1000)>>1)]=$999;
   var $1001=((($storemerge8_i)+(1))|0);
   var $storemerge8_i = $1001;label = 258; break;
  case 260: 
   var $1003=(($877+($storemerge7_i<<1))|0);
   var $1004=HEAP16[(($1003)>>1)];
   var $1005=HEAP32[(($97)>>2)];
   var $1006=HEAP32[(($87)>>2)];
   var $1007=(($1006+($1005<<1))|0);
   HEAP16[(($1007)>>1)]=$1004;
   var $1008=(($890+$storemerge7_i)|0);
   var $1009=HEAP8[($1008)];
   var $1010=HEAP32[(($97)>>2)];
   var $1011=HEAP32[(($92)>>2)];
   var $1012=(($1011+$1010)|0);
   HEAP8[($1012)]=$1009;
   var $1013=HEAP32[(($97)>>2)];
   var $1014=((($1013)+(1))|0);
   HEAP32[(($97)>>2)]=$1014;
   var $1015=(($1014)|(0)) > (($maxTris_0)|(0));
   if ($1015) { label = 261; break; } else { label = 262; break; }
  case 261: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2416)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1014,HEAP32[(((tempVarArgs)+(8))>>2)]=$maxTris_0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01159 = 0;label = 263; break; } else { label = 234; break; }
  case 262: 
   var $1018=((($storemerge7_i)+(1))|0);
   var $storemerge7_i = $1018;label = 255; break;
  case 263: 
   var $_01159;
   var $1020=(($890)|(0))==0;
   if ($1020) { label = 265; break; } else { label = 264; break; }
  case 264: 
   _free($890);
   label = 265; break;
  case 265: 
   var $1022=(($876)|(0))==0;
   if ($1022) { label = 269; break; } else { label = 266; break; }
  case 266: 
   _free($876);
   label = 269; break;
  case 267: 
   var $1024=(($876)|(0))==0;
   if ($1024) { var $_11161 = $885;var $_11170 = $886;label = 271; break; } else { label = 268; break; }
  case 268: 
   _free($876);
   var $_11161 = $885;var $_11170 = $886;label = 271; break;
  case 269: 
   var $1026=(($866)|(0))==0;
   if ($1026) { var $_21328 = $_01159;label = 273; break; } else { var $_21367 = $_01159;label = 270; break; }
  case 270: 
   var $_21367;
   _free($866);
   var $_21328 = $_21367;label = 273; break;
  case 271: 
   var $_11170;
   var $_11161;
   var $1027=(($866)|(0))==0;
   if ($1027) { var $_21162 = $_11161;var $_21171 = $_11170;label = 275; break; } else { label = 272; break; }
  case 272: 
   _free($866);
   var $_21162 = $_11161;var $_21171 = $_11170;label = 275; break;
  case 273: 
   var $_21328;
   var $1029=(($820)|(0))==0;
   if ($1029) { label = 277; break; } else { label = 274; break; }
  case 274: 
   _free($820);
   label = 277; break;
  case 275: 
   var $_21171;
   var $_21162;
   var $1031=(($820)|(0))==0;
   if ($1031) { label = 279; break; } else { label = 276; break; }
  case 276: 
   _free($820);
   label = 279; break;
  case 277: 
   var $1033=(($812)|(0))==0;
   if ($1033) { label = 281; break; } else { label = 278; break; }
  case 278: 
   _free($812);
   label = 281; break;
  case 279: 
   var $1035=(($812)|(0))==0;
   if ($1035) { var $_41164 = $_21162;var $_41173 = $_21171;label = 283; break; } else { label = 280; break; }
  case 280: 
   _free($812);
   var $_41164 = $_21162;var $_41173 = $_21171;label = 283; break;
  case 281: 
   var $1037=(($802)|(0))==0;
   if ($1037) { var $_6 = $_21328;label = 285; break; } else { var $_51368 = $_21328;label = 282; break; }
  case 282: 
   var $_51368;
   _free($802);
   var $_6 = $_51368;label = 285; break;
  case 283: 
   var $_41173;
   var $_41164;
   var $1038=(($802)|(0))==0;
   if ($1038) { var $_51165 = $_41164;var $_51174 = $_41173;label = 287; break; } else { label = 284; break; }
  case 284: 
   _free($802);
   var $_51165 = $_41164;var $_51174 = $_41173;label = 287; break;
  case 285: 
   var $_6;
   var $1040=(($546)|(0))==0;
   if ($1040) { label = 289; break; } else { label = 286; break; }
  case 286: 
   _free($546);
   label = 289; break;
  case 287: 
   var $_51174;
   var $_51165;
   var $1042=(($546)|(0))==0;
   if ($1042) { var $_61166 = $_51165;var $_61175 = $_51174;label = 291; break; } else { label = 288; break; }
  case 288: 
   _free($546);
   var $_61166 = $_51165;var $_61175 = $_51174;label = 291; break;
  case 289: 
   var $1044=(($537)|(0))==0;
   if ($1044) { var $_8 = $_6;label = 293; break; } else { var $_71369 = $_6;label = 290; break; }
  case 290: 
   var $_71369;
   _free($537);
   var $_8 = $_71369;label = 293; break;
  case 291: 
   var $_61175;
   var $_61166;
   var $1045=(($537)|(0))==0;
   if ($1045) { var $_71167 = $_61166;var $_71176 = $_61175;label = 295; break; } else { label = 292; break; }
  case 292: 
   _free($537);
   var $_71167 = $_61166;var $_71176 = $_61175;label = 295; break;
  case 293: 
   var $_8;
   var $1047=(($528)|(0))==0;
   if ($1047) { var $_9 = $_8;label = 297; break; } else { var $_81370 = $_8;label = 294; break; }
  case 294: 
   var $_81370;
   _free($528);
   var $_9 = $_81370;label = 297; break;
  case 295: 
   var $_71176;
   var $_71167;
   var $1048=(($528)|(0))==0;
   if ($1048) { var $_81168 = $_71167;var $_81177 = $_71176;label = 299; break; } else { label = 296; break; }
  case 296: 
   _free($528);
   var $_81168 = $_71167;var $_81177 = $_71176;label = 299; break;
  case 297: 
   var $_9;
   var $1050=(($518)|(0))==0;
   if ($1050) { label = 302; break; } else { label = 298; break; }
  case 298: 
   _free($518);
   if ($_9) { var $storemerge6 = $storemerge3;label = 305; break; } else { label = 304; break; }
  case 299: 
   var $_81177;
   var $_81168;
   var $1051=(($518)|(0))==0;
   if ($1051) { var $_811771347 = $_81177;var $_811681348 = $_81168;label = 301; break; } else { label = 300; break; }
  case 300: 
   _free($518);
   var $_811771347 = $_81177;var $_811681348 = $_81168;label = 301; break;
  case 301: 
   var $_811681348;
   var $_811771347;
   var $1053$0=$_811681348;
   var $1053$1=0;
   var $1054$0=$1053$0;
   var $1054$1=$_811771347;
   var $eh_lpad_body$1 = $1054$1;var $eh_lpad_body$0 = $1054$0;label = 39; break;
  case 302: 
   if ($_9) { var $storemerge6 = $storemerge3;label = 305; break; } else { label = 304; break; }
  case 303: 
   _free($518);
   label = 304; break;
  case 304: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5784)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge3,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01188 = 0;var $_pre_phi1257 = $150;label = 380; break; } else { label = 38; break; }
  case 305: 
   var $storemerge6;
   var $1057=HEAP32[(($96)>>2)];
   var $1058=(($storemerge6)|(0)) < (($1057)|(0));
   if ($1058) { label = 306; break; } else { label = 307; break; }
  case 306: 
   var $1060=((($storemerge6)+(1))|0);
   var $1061=(($59+$1060)|0);
   var $1062=HEAP8[($1061)];
   var $1063=(($59+$storemerge6)|0);
   HEAP8[($1063)]=$1062;
   var $storemerge6 = $1060;label = 305; break;
  case 307: 
   var $1065=((($storemerge3)-(1))|0);
   var $i9_0 = $1065;label = 308; break;
  case 308: 
   var $i9_0;
   var $1066=((($i9_0)+(1))|0);
   var $storemerge3 = $1066;label = 89; break;
  case 309: 
   var $1068=HEAP32[(($79)>>2)];
   var $1069=HEAP32[(($97)>>2)];
   var $1070=(Math.imul($1069,$nvp)|0);
   var $1071=((($1070)+($358))|0);
   var $1072=$1071 << 1;
   var $1073=_malloc($1072);
   var $1074=$1073;
   var $1075=(($1073)|(0))==0;
   if ($1075) { label = 347; break; } else { label = 310; break; }
  case 310: 
   var $1077=((($1070)*(12))&-1);
   var $1078=_malloc($1077);
   var $1079=$1078;
   var $1080=(($1078)|(0))==0;
   if ($1080) { label = 311; break; } else { var $storemerge_i = 0;label = 312; break; }
  case 311: 
   var $1081=(($1073)|(0))==0;
   _free($1073);
   label = 347; break;
  case 312: 
   var $storemerge_i;
   var $1082=(($storemerge_i)|(0)) < (($358)|(0));
   if ($1082) { label = 313; break; } else { var $storemerge1_i = 0;var $edgeCount_i_0 = 0;label = 314; break; }
  case 313: 
   var $1084=(($1074+($storemerge_i<<1))|0);
   HEAP16[(($1084)>>1)]=-1;
   var $1085=((($storemerge_i)+(1))|0);
   var $storemerge_i = $1085;label = 312; break;
  case 314: 
   var $edgeCount_i_0;
   var $storemerge1_i;
   var $1086=(($storemerge1_i)|(0)) < (($1069)|(0));
   if ($1086) { label = 315; break; } else { var $storemerge2_i = 0;label = 324; break; }
  case 315: 
   var $1088=(Math.imul($storemerge1_i,$nvp)|0);
   var $1089=$1088 << 1;
   var $1090=(($1068+($1089<<1))|0);
   var $1091=(($storemerge1_i) & 65535);
   var $storemerge6_i = 0;var $edgeCount_i_1 = $edgeCount_i_0;label = 316; break;
  case 316: 
   var $edgeCount_i_1;
   var $storemerge6_i;
   var $1093=(($storemerge6_i)|(0)) < (($nvp)|(0));
   if ($1093) { label = 317; break; } else { label = 323; break; }
  case 317: 
   var $_sum1274=((($1089)+($storemerge6_i))|0);
   var $1095=(($1068+($_sum1274<<1))|0);
   var $1096=HEAP16[(($1095)>>1)];
   var $1097=(($1096 << 16) >> 16)==-1;
   if ($1097) { label = 323; break; } else { label = 318; break; }
  case 318: 
   var $1099=((($storemerge6_i)+(1))|0);
   var $1100=(($1099)|(0)) < (($nvp)|(0));
   if ($1100) { label = 319; break; } else { label = 320; break; }
  case 319: 
   var $_sum1276=((($1089)+($1099))|0);
   var $1102=(($1068+($_sum1276<<1))|0);
   var $1103=HEAP16[(($1102)>>1)];
   var $1104=(($1103 << 16) >> 16)==-1;
   if ($1104) { label = 320; break; } else { var $1106 = $1103;label = 321; break; }
  case 320: 
   var $_pre1241=HEAP16[(($1090)>>1)];
   var $1106 = $_pre1241;label = 321; break;
  case 321: 
   var $1106;
   var $1107=(($1096)&(65535)) < (($1106)&(65535));
   if ($1107) { label = 322; break; } else { var $storemerge6_i = $1099;var $edgeCount_i_1 = $edgeCount_i_1;label = 316; break; }
  case 322: 
   var $1109=(($1079+((($edgeCount_i_1)*(12))&-1))|0);
   HEAP16[(($1109)>>1)]=$1096;
   var $1110=(($1079+((($edgeCount_i_1)*(12))&-1)+2)|0);
   HEAP16[(($1110)>>1)]=$1106;
   var $1111=(($1079+((($edgeCount_i_1)*(12))&-1)+8)|0);
   HEAP16[(($1111)>>1)]=$1091;
   var $1112=(($storemerge6_i) & 65535);
   var $1113=(($1079+((($edgeCount_i_1)*(12))&-1)+4)|0);
   HEAP16[(($1113)>>1)]=$1112;
   var $1114=(($1079+((($edgeCount_i_1)*(12))&-1)+10)|0);
   HEAP16[(($1114)>>1)]=$1091;
   var $1115=(($1079+((($edgeCount_i_1)*(12))&-1)+6)|0);
   HEAP16[(($1115)>>1)]=0;
   var $1116=(($1096)&(65535));
   var $1117=(($1074+($1116<<1))|0);
   var $1118=HEAP16[(($1117)>>1)];
   var $_sum1275=((($358)+($edgeCount_i_1))|0);
   var $1119=(($1074+($_sum1275<<1))|0);
   HEAP16[(($1119)>>1)]=$1118;
   var $1120=(($edgeCount_i_1) & 65535);
   HEAP16[(($1117)>>1)]=$1120;
   var $1121=((($edgeCount_i_1)+(1))|0);
   var $storemerge6_i = $1099;var $edgeCount_i_1 = $1121;label = 316; break;
  case 323: 
   var $1123=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $1123;var $edgeCount_i_0 = $edgeCount_i_1;label = 314; break;
  case 324: 
   var $storemerge2_i;
   var $1124=(($storemerge2_i)|(0)) < (($1069)|(0));
   if ($1124) { label = 325; break; } else { var $storemerge3_i = 0;label = 339; break; }
  case 325: 
   var $1126=(Math.imul($storemerge2_i,$nvp)|0);
   var $1127=$1126 << 1;
   var $1128=(($1068+($1127<<1))|0);
   var $1129=(($storemerge2_i) & 65535);
   var $storemerge4_i = 0;label = 326; break;
  case 326: 
   var $storemerge4_i;
   var $1130=(($storemerge4_i)|(0)) < (($nvp)|(0));
   if ($1130) { label = 327; break; } else { label = 338; break; }
  case 327: 
   var $_sum1271=((($1127)+($storemerge4_i))|0);
   var $1132=(($1068+($_sum1271<<1))|0);
   var $1133=HEAP16[(($1132)>>1)];
   var $1134=(($1133 << 16) >> 16)==-1;
   if ($1134) { label = 338; break; } else { label = 328; break; }
  case 328: 
   var $1136=((($storemerge4_i)+(1))|0);
   var $1137=(($1136)|(0)) < (($nvp)|(0));
   if ($1137) { label = 329; break; } else { label = 330; break; }
  case 329: 
   var $_sum1273=((($1127)+($1136))|0);
   var $1139=(($1068+($_sum1273<<1))|0);
   var $1140=HEAP16[(($1139)>>1)];
   var $1141=(($1140 << 16) >> 16)==-1;
   if ($1141) { label = 330; break; } else { var $1143 = $1140;label = 331; break; }
  case 330: 
   var $_pre1242=HEAP16[(($1128)>>1)];
   var $1143 = $_pre1242;label = 331; break;
  case 331: 
   var $1143;
   var $1144=(($1133)&(65535)) > (($1143)&(65535));
   if ($1144) { label = 332; break; } else { var $storemerge4_i = $1136;label = 326; break; }
  case 332: 
   var $1146=(($1143)&(65535));
   var $_pn = $1146;label = 333; break;
  case 333: 
   var $_pn;
   var $storemerge5_in_i=(($1074+($_pn<<1))|0);
   var $storemerge5_i=HEAP16[(($storemerge5_in_i)>>1)];
   var $1148=(($storemerge5_i << 16) >> 16)==-1;
   if ($1148) { var $storemerge4_i = $1136;label = 326; break; } else { label = 334; break; }
  case 334: 
   var $1150=(($storemerge5_i)&(65535));
   var $1151=(($1079+((($1150)*(12))&-1)+2)|0);
   var $1152=HEAP16[(($1151)>>1)];
   var $1153=(($1152 << 16) >> 16)==(($1133 << 16) >> 16);
   if ($1153) { label = 335; break; } else { label = 337; break; }
  case 335: 
   var $1155=(($1079+((($1150)*(12))&-1)+8)|0);
   var $1156=HEAP16[(($1155)>>1)];
   var $1157=(($1079+((($1150)*(12))&-1)+10)|0);
   var $1158=HEAP16[(($1157)>>1)];
   var $1159=(($1156 << 16) >> 16)==(($1158 << 16) >> 16);
   if ($1159) { label = 336; break; } else { label = 337; break; }
  case 336: 
   HEAP16[(($1157)>>1)]=$1129;
   var $1161=(($storemerge4_i) & 65535);
   var $1162=(($1079+((($1150)*(12))&-1)+6)|0);
   HEAP16[(($1162)>>1)]=$1161;
   var $storemerge4_i = $1136;label = 326; break;
  case 337: 
   var $_sum1272=((($358)+($1150))|0);
   var $_pn = $_sum1272;label = 333; break;
  case 338: 
   var $1165=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $1165;label = 324; break;
  case 339: 
   var $storemerge3_i;
   var $1166=(($storemerge3_i)|(0)) < (($edgeCount_i_0)|(0));
   if ($1166) { label = 340; break; } else { label = 343; break; }
  case 340: 
   var $1168=(($1079+((($storemerge3_i)*(12))&-1)+8)|0);
   var $1169=HEAP16[(($1168)>>1)];
   var $1170=(($1079+((($storemerge3_i)*(12))&-1)+10)|0);
   var $1171=HEAP16[(($1170)>>1)];
   var $1172=(($1169 << 16) >> 16)==(($1171 << 16) >> 16);
   if ($1172) { label = 342; break; } else { label = 341; break; }
  case 341: 
   var $1174=(($1079+((($storemerge3_i)*(12))&-1)+8)|0);
   var $1175=(($1169)&(65535));
   var $1176=(Math.imul($1175,$nvp)|0);
   var $1177=$1176 << 1;
   var $1178=(($1171)&(65535));
   var $1179=(Math.imul($1178,$nvp)|0);
   var $1180=$1179 << 1;
   var $1181=(($1079+((($storemerge3_i)*(12))&-1)+4)|0);
   var $1182=HEAP16[(($1181)>>1)];
   var $1183=(($1182)&(65535));
   var $1184=((($1183)+($nvp))|0);
   var $_sum1269=((($1177)+($1184))|0);
   var $1185=(($1068+($_sum1269<<1))|0);
   HEAP16[(($1185)>>1)]=$1171;
   var $1186=HEAP16[(($1174)>>1)];
   var $1187=(($1079+((($storemerge3_i)*(12))&-1)+6)|0);
   var $1188=HEAP16[(($1187)>>1)];
   var $1189=(($1188)&(65535));
   var $1190=((($1189)+($nvp))|0);
   var $_sum1270=((($1180)+($1190))|0);
   var $1191=(($1068+($_sum1270<<1))|0);
   HEAP16[(($1191)>>1)]=$1186;
   label = 342; break;
  case 342: 
   var $1193=((($storemerge3_i)+(1))|0);
   var $storemerge3_i = $1193;label = 339; break;
  case 343: 
   var $1195=(($1073)|(0))==0;
   if ($1195) { label = 345; break; } else { label = 344; break; }
  case 344: 
   _free($1073);
   label = 345; break;
  case 345: 
   var $1197=(($1078)|(0))==0;
   if ($1197) { label = 348; break; } else { label = 346; break; }
  case 346: 
   _free($1078);
   label = 348; break;
  case 347: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5576)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01188 = 0;var $_pre_phi1257 = $150;label = 380; break; } else { label = 38; break; }
  case 348: 
   var $1200=HEAP32[(($36)>>2)];
   var $1201=(($1200)|(0)) > 0;
   if ($1201) { label = 350; break; } else { label = 349; break; }
  case 349: 
   var $_pre1246=HEAP32[(($97)>>2)];
   var $1274 = $_pre1246;label = 372; break;
  case 350: 
   var $1203=(($cset+40)|0);
   var $1204=HEAP32[(($1203)>>2)];
   var $1205=(($cset+44)|0);
   var $1206=HEAP32[(($1205)>>2)];
   var $storemerge4 = 0;label = 351; break;
  case 351: 
   var $storemerge4;
   var $1208=HEAP32[(($97)>>2)];
   var $1209=(($storemerge4)|(0)) < (($1208)|(0));
   if ($1209) { label = 352; break; } else { var $1274 = $1208;label = 372; break; }
  case 352: 
   var $1211=$storemerge4 << 1;
   var $1212=(Math.imul($1211,$nvp)|0);
   var $1213=HEAP32[(($79)>>2)];
   var $1214=(($1213+($1212<<1))|0);
   var $storemerge5 = 0;label = 353; break;
  case 353: 
   var $storemerge5;
   var $1215=(($storemerge5)|(0)) < (($nvp)|(0));
   if ($1215) { label = 354; break; } else { label = 371; break; }
  case 354: 
   var $_sum1263=((($1212)+($storemerge5))|0);
   var $1217=(($1213+($_sum1263<<1))|0);
   var $1218=HEAP16[(($1217)>>1)];
   var $1219=(($1218 << 16) >> 16)==-1;
   if ($1219) { label = 371; break; } else { label = 355; break; }
  case 355: 
   var $1221=((($storemerge5)+($nvp))|0);
   var $_sum1264=((($1212)+($1221))|0);
   var $1222=(($1213+($_sum1264<<1))|0);
   var $1223=HEAP16[(($1222)>>1)];
   var $1224=(($1223 << 16) >> 16)==-1;
   var $1225=((($storemerge5)+(1))|0);
   if ($1224) { label = 356; break; } else { var $storemerge5 = $1225;label = 353; break; }
  case 356: 
   var $1227=(($1225)|(0)) < (($nvp)|(0));
   if ($1227) { label = 357; break; } else { label = 358; break; }
  case 357: 
   var $_sum1268=((($1212)+($1225))|0);
   var $1229=(($1213+($_sum1268<<1))|0);
   var $1230=HEAP16[(($1229)>>1)];
   var $1231=(($1230 << 16) >> 16)==-1;
   if ($1231) { label = 358; break; } else { var $1232 = $1230;label = 359; break; }
  case 358: 
   var $_pre1240=HEAP16[(($1214)>>1)];
   var $1232 = $_pre1240;label = 359; break;
  case 359: 
   var $1232;
   var $1233=(($1218)&(65535));
   var $1234=((($1233)*(3))&-1);
   var $1235=HEAP32[(($70)>>2)];
   var $1236=(($1235+($1234<<1))|0);
   var $1237=(($1232)&(65535));
   var $1238=((($1237)*(3))&-1);
   var $1239=(($1235+($1238<<1))|0);
   var $1240=HEAP16[(($1236)>>1)];
   var $1241=(($1240 << 16) >> 16)==0;
   if ($1241) { label = 360; break; } else { label = 362; break; }
  case 360: 
   var $1243=HEAP16[(($1239)>>1)];
   var $1244=(($1243 << 16) >> 16)==0;
   if ($1244) { label = 361; break; } else { label = 362; break; }
  case 361: 
   HEAP16[(($1222)>>1)]=-32768;
   var $storemerge5 = $1225;label = 353; break;
  case 362: 
   var $_sum1265=((($1234)+(2))|0);
   var $1247=(($1235+($_sum1265<<1))|0);
   var $1248=HEAP16[(($1247)>>1)];
   var $1249=(($1248)&(65535));
   var $1250=(($1249)|(0))==(($1206)|(0));
   if ($1250) { label = 363; break; } else { label = 365; break; }
  case 363: 
   var $_sum1267=((($1238)+(2))|0);
   var $1252=(($1235+($_sum1267<<1))|0);
   var $1253=HEAP16[(($1252)>>1)];
   var $1254=(($1253)&(65535));
   var $1255=(($1254)|(0))==(($1206)|(0));
   if ($1255) { label = 364; break; } else { label = 365; break; }
  case 364: 
   HEAP16[(($1222)>>1)]=-32767;
   var $storemerge5 = $1225;label = 353; break;
  case 365: 
   var $1258=(($1240)&(65535));
   var $1259=(($1258)|(0))==(($1204)|(0));
   if ($1259) { label = 366; break; } else { label = 368; break; }
  case 366: 
   var $1261=HEAP16[(($1239)>>1)];
   var $1262=(($1261)&(65535));
   var $1263=(($1262)|(0))==(($1204)|(0));
   if ($1263) { label = 367; break; } else { label = 368; break; }
  case 367: 
   HEAP16[(($1222)>>1)]=-32766;
   var $storemerge5 = $1225;label = 353; break;
  case 368: 
   var $1266=(($1248 << 16) >> 16)==0;
   if ($1266) { label = 369; break; } else { var $storemerge5 = $1225;label = 353; break; }
  case 369: 
   var $_sum1266=((($1238)+(2))|0);
   var $1268=(($1235+($_sum1266<<1))|0);
   var $1269=HEAP16[(($1268)>>1)];
   var $1270=(($1269 << 16) >> 16)==0;
   if ($1270) { label = 370; break; } else { var $storemerge5 = $1225;label = 353; break; }
  case 370: 
   HEAP16[(($1222)>>1)]=-32765;
   var $storemerge5 = $1225;label = 353; break;
  case 371: 
   var $1273=((($storemerge4)+(1))|0);
   var $storemerge4 = $1273;label = 351; break;
  case 372: 
   var $1274;
   var $1275=$1274 << 1;
   var $1276=_malloc($1275);
   var $1277=$1276;
   var $1278=(($mesh+12)|0);
   HEAP32[(($1278)>>2)]=$1277;
   var $1279=(($1276)|(0))==0;
   var $1280=HEAP32[(($97)>>2)];
   if ($1279) { label = 373; break; } else { label = 374; break; }
  case 373: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5448)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1280,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01188 = 0;var $_pre_phi1257 = $150;label = 380; break; } else { label = 38; break; }
  case 374: 
   var $1283=$1280 << 1;
   _memset($1276, 0, $1283);
   var $1284=HEAP32[(($96)>>2)];
   var $1285=(($1284)|(0)) > 65535;
   if ($1285) { label = 375; break; } else { label = 376; break; }
  case 375: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5304)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1284,HEAP32[(((tempVarArgs)+(8))>>2)]=65535,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 376; break; } else { label = 38; break; }
  case 376: 
   var $1288=HEAP32[(($97)>>2)];
   var $1289=(($1288)|(0)) > 65535;
   if ($1289) { label = 377; break; } else { label = 378; break; }
  case 377: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5184)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1288,HEAP32[(((tempVarArgs)+(8))>>2)]=65535,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { label = 378; break; } else { label = 38; break; }
  case 378: 
   var $1292=HEAP8[($1)];
   var $1293=$1292 & 1;
   var $1294=(($1293 << 24) >> 24)==0;
   if ($1294) { var $_01188 = 1;var $_pre_phi1257 = $150;label = 380; break; } else { label = 379; break; }
  case 379: 
   var $1296=$ctx;
   var $1297=HEAP32[(($1296)>>2)];
   var $1298=(($1297+24)|0);
   var $1299=HEAP32[(($1298)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$1299]($ctx, 11) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $_01188 = 1;var $_pre_phi1257 = $150;label = 380; break; } else { label = 38; break; }
  case 380: 
   var $_pre_phi1257;
   var $_01188;
   if ($152) { label = 382; break; } else { label = 381; break; }
  case 381: 
   _free($_pre_phi1257);
   label = 382; break;
  case 382: 
   if ($140) { var $_21190 = $_01188;label = 386; break; } else { var $_111891372 = $_01188;label = 383; break; }
  case 383: 
   var $_111891372;
   _free($138);
   var $_21190 = $_111891372;label = 386; break;
  case 384: 
   if ($140) { var $_11179 = $156;var $_11184 = $155;label = 388; break; } else { label = 385; break; }
  case 385: 
   _free($138);
   var $_11179 = $156;var $_11184 = $155;label = 388; break;
  case 386: 
   var $_21190;
   if ($131) { var $_31191 = $_21190;label = 390; break; } else { var $_211901373 = $_21190;label = 387; break; }
  case 387: 
   var $_211901373;
   _free($129);
   var $_31191 = $_211901373;label = 390; break;
  case 388: 
   var $_11184;
   var $_11179;
   if ($131) { var $_21180 = $_11179;var $_21185 = $_11184;label = 392; break; } else { label = 389; break; }
  case 389: 
   _free($129);
   var $_21180 = $_11179;var $_21185 = $_11184;label = 392; break;
  case 390: 
   var $_31191;
   if ($118) { label = 394; break; } else { label = 391; break; }
  case 391: 
   _free($116);
   label = 394; break;
  case 392: 
   var $_21185;
   var $_21180;
   if ($118) { var $_31181 = $_21180;var $_31186 = $_21185;var $_pre_phi1255 = $108;label = 396; break; } else { label = 393; break; }
  case 393: 
   _free($116);
   var $_31181 = $_21180;var $_31186 = $_21185;var $_pre_phi1255 = $108;label = 396; break;
  case 394: 
   if ($110) { var $_51193 = $_31191;label = 398; break; } else { var $_pre_phi1374 = $108;var $_411921375 = $_31191;label = 395; break; }
  case 395: 
   var $_411921375;
   var $_pre_phi1374;
   _free($_pre_phi1374);
   var $_51193 = $_411921375;label = 398; break;
  case 396: 
   var $_pre_phi1255;
   var $_31186;
   var $_31181;
   if ($110) { var $_41182 = $_31181;var $_41187 = $_31186;label = 400; break; } else { label = 397; break; }
  case 397: 
   _free($_pre_phi1255);
   var $_41182 = $_31181;var $_41187 = $_31186;label = 400; break;
  case 398: 
   var $_51193;
   if ($60) { var $_61194 = $_51193;label = 402; break; } else { var $_511931366 = $_51193;label = 399; break; }
  case 399: 
   var $_511931366;
   _free($59);
   var $_61194 = $_511931366;label = 402; break;
  case 400: 
   var $_41187;
   var $_41182;
   if ($60) { label = 403; break; } else { label = 401; break; }
  case 401: 
   _free($59);
   label = 403; break;
  case 402: 
   var $_61194;
   STACKTOP = sp;
   return $_61194;
  case 403: 
   var $1309$0=$_41187;
   var $1309$1=0;
   var $1310$0=$1309$0;
   var $1310$1=$_41182;
   ___resumeException($1310$0)
  default: assert(0, "bad label: " + label);
 }
}
function __ZL17getPolyMergeValuePtS_PKtRiS2_i($pa, $pb, $verts, $ea, $eb, $nvp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $storemerge_i = 0;label = 2; break;
  case 2: 
   var $storemerge_i;
   var $2=(($storemerge_i)|(0)) < (($nvp)|(0));
   if ($2) { label = 3; break; } else { var $storemerge1_i_in_sroa_speculated = $nvp;label = 5; break; }
  case 3: 
   var $4=(($pa+($storemerge_i<<1))|0);
   var $5=HEAP16[(($4)>>1)];
   var $6=(($5 << 16) >> 16)==-1;
   if ($6) { var $storemerge1_i_in_sroa_speculated = $storemerge_i;label = 5; break; } else { label = 4; break; }
  case 4: 
   var $8=((($storemerge_i)+(1))|0);
   var $storemerge_i = $8;label = 2; break;
  case 5: 
   var $storemerge1_i_in_sroa_speculated;
   var $storemerge_i4 = 0;label = 6; break;
  case 6: 
   var $storemerge_i4;
   var $10=(($storemerge_i4)|(0)) < (($nvp)|(0));
   if ($10) { label = 7; break; } else { var $storemerge1_i5_in_sroa_speculated = $nvp;label = 9; break; }
  case 7: 
   var $12=(($pb+($storemerge_i4<<1))|0);
   var $13=HEAP16[(($12)>>1)];
   var $14=(($13 << 16) >> 16)==-1;
   if ($14) { var $storemerge1_i5_in_sroa_speculated = $storemerge_i4;label = 9; break; } else { label = 8; break; }
  case 8: 
   var $16=((($storemerge_i4)+(1))|0);
   var $storemerge_i4 = $16;label = 6; break;
  case 9: 
   var $storemerge1_i5_in_sroa_speculated;
   var $17=((($storemerge1_i_in_sroa_speculated)+($storemerge1_i5_in_sroa_speculated))|0);
   var $18=((($17)-(2))|0);
   var $19=(($18)|(0)) > (($nvp)|(0));
   if ($19) { var $_0 = -1;label = 20; break; } else { label = 10; break; }
  case 10: 
   HEAP32[(($ea)>>2)]=-1;
   HEAP32[(($eb)>>2)]=-1;
   var $storemerge = 0;var $21 = -1;label = 11; break;
  case 11: 
   var $21;
   var $storemerge;
   var $22=(($storemerge)|(0)) < (($storemerge1_i_in_sroa_speculated)|(0));
   if ($22) { label = 12; break; } else { label = 16; break; }
  case 12: 
   var $23=(($pa+($storemerge<<1))|0);
   var $24=HEAP16[(($23)>>1)];
   var $25=((($storemerge)+(1))|0);
   var $26=((((($25)|(0)))%((($storemerge1_i_in_sroa_speculated)|(0))))&-1);
   var $27=(($pa+($26<<1))|0);
   var $28=HEAP16[(($27)>>1)];
   var $29=(($24)&(65535)) > (($28)&(65535));
   var $_=$29 ? $24 : $28;
   var $_114=$29 ? $28 : $24;
   var $storemerge1 = 0;label = 13; break;
  case 13: 
   var $storemerge1;
   var $31=(($storemerge1)|(0)) < (($storemerge1_i5_in_sroa_speculated)|(0));
   if ($31) { label = 14; break; } else { var $storemerge = $25;var $21 = $21;label = 11; break; }
  case 14: 
   var $33=(($pb+($storemerge1<<1))|0);
   var $34=HEAP16[(($33)>>1)];
   var $35=((($storemerge1)+(1))|0);
   var $36=((((($35)|(0)))%((($storemerge1_i5_in_sroa_speculated)|(0))))&-1);
   var $37=(($pb+($36<<1))|0);
   var $38=HEAP16[(($37)>>1)];
   var $39=(($34)&(65535)) > (($38)&(65535));
   var $_115=$39 ? $38 : $34;
   var $_116=$39 ? $34 : $38;
   var $40=(($_114 << 16) >> 16)==(($_115 << 16) >> 16);
   var $41=(($_ << 16) >> 16)==(($_116 << 16) >> 16);
   var $or_cond=$40 & $41;
   if ($or_cond) { label = 15; break; } else { var $storemerge1 = $35;label = 13; break; }
  case 15: 
   HEAP32[(($ea)>>2)]=$storemerge;
   HEAP32[(($eb)>>2)]=$storemerge1;
   var $storemerge = $25;var $21 = $storemerge1;label = 11; break;
  case 16: 
   var $44=HEAP32[(($ea)>>2)];
   var $45=(($44)|(0))==-1;
   var $46=(($21)|(0))==-1;
   var $or_cond117=$45 | $46;
   if ($or_cond117) { var $_0 = -1;label = 20; break; } else { label = 17; break; }
  case 17: 
   var $48=((($44)+($storemerge1_i_in_sroa_speculated))|0);
   var $49=((($48)-(1))|0);
   var $50=((((($49)|(0)))%((($storemerge1_i_in_sroa_speculated)|(0))))&-1);
   var $51=(($pa+($50<<1))|0);
   var $52=HEAP16[(($51)>>1)];
   var $53=(($pa+($44<<1))|0);
   var $54=HEAP16[(($53)>>1)];
   var $55=((($21)+(2))|0);
   var $56=((((($55)|(0)))%((($storemerge1_i5_in_sroa_speculated)|(0))))&-1);
   var $57=(($pb+($56<<1))|0);
   var $58=HEAP16[(($57)>>1)];
   var $59=(($52)&(65535));
   var $60=((($59)*(3))&-1);
   var $61=(($verts+($60<<1))|0);
   var $62=(($54)&(65535));
   var $63=((($62)*(3))&-1);
   var $64=(($verts+($63<<1))|0);
   var $65=(($58)&(65535));
   var $66=((($65)*(3))&-1);
   var $67=(($verts+($66<<1))|0);
   var $68=HEAP16[(($64)>>1)];
   var $69=(($68)&(65535));
   var $70=HEAP16[(($61)>>1)];
   var $71=(($70)&(65535));
   var $72=((($69)-($71))|0);
   var $_sum=((($66)+(2))|0);
   var $73=(($verts+($_sum<<1))|0);
   var $74=HEAP16[(($73)>>1)];
   var $75=(($74)&(65535));
   var $_sum110=((($60)+(2))|0);
   var $76=(($verts+($_sum110<<1))|0);
   var $77=HEAP16[(($76)>>1)];
   var $78=(($77)&(65535));
   var $79=((($75)-($78))|0);
   var $80=(Math.imul($72,$79)|0);
   var $81=HEAP16[(($67)>>1)];
   var $82=(($81)&(65535));
   var $83=((($82)-($71))|0);
   var $_sum111=((($63)+(2))|0);
   var $84=(($verts+($_sum111<<1))|0);
   var $85=HEAP16[(($84)>>1)];
   var $86=(($85)&(65535));
   var $87=((($86)-($78))|0);
   var $88=(Math.imul($83,$87)|0);
   var $89=((($80)-($88))|0);
   var $90=(($89)|(0)) < 0;
   if ($90) { label = 18; break; } else { var $_0 = -1;label = 20; break; }
  case 18: 
   var $92=((($21)+($storemerge1_i5_in_sroa_speculated))|0);
   var $93=((($92)-(1))|0);
   var $94=((((($93)|(0)))%((($storemerge1_i5_in_sroa_speculated)|(0))))&-1);
   var $95=(($pb+($94<<1))|0);
   var $96=HEAP16[(($95)>>1)];
   var $97=(($pb+($21<<1))|0);
   var $98=HEAP16[(($97)>>1)];
   var $99=((($44)+(2))|0);
   var $100=((((($99)|(0)))%((($storemerge1_i_in_sroa_speculated)|(0))))&-1);
   var $101=(($pa+($100<<1))|0);
   var $102=HEAP16[(($101)>>1)];
   var $103=(($96)&(65535));
   var $104=((($103)*(3))&-1);
   var $105=(($verts+($104<<1))|0);
   var $106=(($98)&(65535));
   var $107=((($106)*(3))&-1);
   var $108=(($verts+($107<<1))|0);
   var $109=(($102)&(65535));
   var $110=((($109)*(3))&-1);
   var $111=(($verts+($110<<1))|0);
   var $112=HEAP16[(($108)>>1)];
   var $113=(($112)&(65535));
   var $114=HEAP16[(($105)>>1)];
   var $115=(($114)&(65535));
   var $116=((($113)-($115))|0);
   var $_sum7=((($110)+(2))|0);
   var $117=(($verts+($_sum7<<1))|0);
   var $118=HEAP16[(($117)>>1)];
   var $119=(($118)&(65535));
   var $_sum112=((($104)+(2))|0);
   var $120=(($verts+($_sum112<<1))|0);
   var $121=HEAP16[(($120)>>1)];
   var $122=(($121)&(65535));
   var $123=((($119)-($122))|0);
   var $124=(Math.imul($116,$123)|0);
   var $125=HEAP16[(($111)>>1)];
   var $126=(($125)&(65535));
   var $127=((($126)-($115))|0);
   var $_sum113=((($107)+(2))|0);
   var $128=(($verts+($_sum113<<1))|0);
   var $129=HEAP16[(($128)>>1)];
   var $130=(($129)&(65535));
   var $131=((($130)-($122))|0);
   var $132=(Math.imul($127,$131)|0);
   var $133=((($124)-($132))|0);
   var $134=(($133)|(0)) < 0;
   if ($134) { label = 19; break; } else { var $_0 = -1;label = 20; break; }
  case 19: 
   var $136=((($44)+(1))|0);
   var $137=((((($136)|(0)))%((($storemerge1_i_in_sroa_speculated)|(0))))&-1);
   var $138=(($pa+($137<<1))|0);
   var $139=HEAP16[(($138)>>1)];
   var $140=(($139)&(65535));
   var $141=((($140)*(3))&-1);
   var $142=(($verts+($141<<1))|0);
   var $143=HEAP16[(($142)>>1)];
   var $144=(($143)&(65535));
   var $145=((($69)-($144))|0);
   var $146=((($141)+(2))|0);
   var $147=(($verts+($146<<1))|0);
   var $148=HEAP16[(($147)>>1)];
   var $149=(($148)&(65535));
   var $150=((($86)-($149))|0);
   var $151=(Math.imul($145,$145)|0);
   var $152=(Math.imul($150,$150)|0);
   var $153=((($151)+($152))|0);
   var $_0 = $153;label = 20; break;
  case 20: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL7betweenPKiS0_S0_($a, $b, $c) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAP32[(($b)>>2)];
   var $2=HEAP32[(($a)>>2)];
   var $3=((($1)-($2))|0);
   var $4=(($c+8)|0);
   var $5=HEAP32[(($4)>>2)];
   var $6=(($a+8)|0);
   var $7=HEAP32[(($6)>>2)];
   var $8=((($5)-($7))|0);
   var $9=(Math.imul($3,$8)|0);
   var $10=HEAP32[(($c)>>2)];
   var $11=((($10)-($2))|0);
   var $12=(($b+8)|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=((($13)-($7))|0);
   var $15=(Math.imul($11,$14)|0);
   var $16=(($9)|(0))==(($15)|(0));
   if ($16) { label = 2; break; } else { var $_0 = 0;label = 7; break; }
  case 2: 
   var $18=(($2)|(0))==(($1)|(0));
   if ($18) { label = 5; break; } else { label = 3; break; }
  case 3: 
   var $20=(($2)|(0)) > (($10)|(0));
   var $21=(($10)|(0)) > (($1)|(0));
   var $or_cond=$20 | $21;
   if ($or_cond) { label = 4; break; } else { var $_0 = 1;label = 7; break; }
  case 4: 
   var $23=(($2)|(0)) < (($10)|(0));
   var $24=(($10)|(0)) >= (($1)|(0));
   var $_=$23 ? 0 : $24;
   return $_;
  case 5: 
   var $26=(($7)|(0)) > (($5)|(0));
   var $27=(($5)|(0)) > (($13)|(0));
   var $or_cond28=$26 | $27;
   if ($or_cond28) { label = 6; break; } else { var $_0 = 1;label = 7; break; }
  case 6: 
   var $29=(($7)|(0)) < (($5)|(0));
   var $30=(($5)|(0)) >= (($13)|(0));
   var $_29=$29 ? 0 : $30;
   var $_0 = $_29;label = 7; break;
  case 7: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL11triangulateiPKiPiS1_($n, $verts, $indices, $tris) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $storemerge = 0;label = 2; break;
  case 2: 
   var $storemerge;
   var $2=(($storemerge)|(0)) < (($n)|(0));
   if ($2) { label = 3; break; } else { var $_0 = $n;var $ntris_0 = 0;var $dst_0 = $tris;label = 5; break; }
  case 3: 
   var $3=((($storemerge)+(1))|0);
   var $4=(($3)|(0)) < (($n)|(0));
   var $_=$4 ? $3 : 0;
   var $5=((($_)+(1))|0);
   var $6=(($5)|(0)) < (($n)|(0));
   var $7=$6 ? $5 : 0;
   var $8=__ZL8diagonaliiiPKiPi($storemerge, $7, $n, $verts, $indices);
   if ($8) { label = 4; break; } else { var $storemerge = $3;label = 2; break; }
  case 4: 
   var $10=(($indices+($_<<2))|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=$11 | -2147483648;
   HEAP32[(($10)>>2)]=$12;
   var $storemerge = $3;label = 2; break;
  case 5: 
   var $dst_0;
   var $ntris_0;
   var $_0;
   var $13=(($_0)|(0)) > 3;
   if ($13) { var $storemerge1 = 0;var $minLen_0 = -1;var $mini_0 = -1;label = 6; break; } else { label = 23; break; }
  case 6: 
   var $mini_0;
   var $minLen_0;
   var $storemerge1;
   var $15=(($storemerge1)|(0)) < (($_0)|(0));
   if ($15) { label = 7; break; } else { label = 9; break; }
  case 7: 
   var $16=((($storemerge1)+(1))|0);
   var $17=(($16)|(0)) < (($_0)|(0));
   var $_115=$17 ? $16 : 0;
   var $18=(($indices+($_115<<2))|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0)) < 0;
   if ($20) { label = 8; break; } else { var $storemerge1 = $16;var $minLen_0 = $minLen_0;var $mini_0 = $mini_0;label = 6; break; }
  case 8: 
   var $21=(($indices+($storemerge1<<2))|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=$22 << 2;
   var $24=$23 & 1073741820;
   var $25=(($verts+($24<<2))|0);
   var $26=((($_115)+(1))|0);
   var $27=(($26)|(0)) < (($_0)|(0));
   var $_116=$27 ? $26 : 0;
   var $28=(($indices+($_116<<2))|0);
   var $29=HEAP32[(($28)>>2)];
   var $30=$29 << 2;
   var $31=$30 & 1073741820;
   var $32=(($verts+($31<<2))|0);
   var $33=HEAP32[(($32)>>2)];
   var $34=HEAP32[(($25)>>2)];
   var $35=((($33)-($34))|0);
   var $_sum4=$31 | 2;
   var $36=(($verts+($_sum4<<2))|0);
   var $37=HEAP32[(($36)>>2)];
   var $_sum112=$24 | 2;
   var $38=(($verts+($_sum112<<2))|0);
   var $39=HEAP32[(($38)>>2)];
   var $40=((($37)-($39))|0);
   var $41=(Math.imul($35,$35)|0);
   var $42=(Math.imul($40,$40)|0);
   var $43=((($41)+($42))|0);
   var $44=(($minLen_0)|(0)) < 0;
   var $45=(($43)|(0)) < (($minLen_0)|(0));
   var $or_cond=$44 | $45;
   var $storemerge1_mini_0=$or_cond ? $storemerge1 : $mini_0;
   var $_minLen_0=$or_cond ? $43 : $minLen_0;
   var $storemerge1 = $16;var $minLen_0 = $_minLen_0;var $mini_0 = $storemerge1_mini_0;label = 6; break;
  case 9: 
   var $47=(($mini_0)|(0))==-1;
   if ($47) { label = 10; break; } else { label = 11; break; }
  case 10: 
   var $49=(((-$ntris_0))|0);
   var $storemerge3 = $49;label = 24; break;
  case 11: 
   var $50=((($mini_0)+(1))|0);
   var $51=(($50)|(0)) < (($_0)|(0));
   var $_117=$51 ? $50 : 0;
   var $52=((($_117)+(1))|0);
   var $53=(($52)|(0)) < (($_0)|(0));
   var $54=$53 ? $52 : 0;
   var $55=(($indices+($mini_0<<2))|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=$56 & 268435455;
   var $58=(($dst_0+4)|0);
   HEAP32[(($dst_0)>>2)]=$57;
   var $59=(($indices+($_117<<2))|0);
   var $60=HEAP32[(($59)>>2)];
   var $61=$60 & 268435455;
   var $62=(($dst_0+8)|0);
   HEAP32[(($58)>>2)]=$61;
   var $63=(($indices+($54<<2))|0);
   var $64=HEAP32[(($63)>>2)];
   var $65=$64 & 268435455;
   var $66=(($dst_0+12)|0);
   HEAP32[(($62)>>2)]=$65;
   var $67=((($ntris_0)+(1))|0);
   var $68=((($_0)-(1))|0);
   var $storemerge2 = $_117;label = 12; break;
  case 12: 
   var $storemerge2;
   var $70=(($storemerge2)|(0)) < (($68)|(0));
   if ($70) { label = 13; break; } else { label = 14; break; }
  case 13: 
   var $72=((($storemerge2)+(1))|0);
   var $73=(($indices+($72<<2))|0);
   var $74=HEAP32[(($73)>>2)];
   var $75=(($indices+($storemerge2<<2))|0);
   HEAP32[(($75)>>2)]=$74;
   var $storemerge2 = $72;label = 12; break;
  case 14: 
   var $77=(($_117)|(0)) < (($68)|(0));
   if ($77) { var $i16_0 = $_117;label = 15; break; } else { var $i16_0113 = 0;label = 16; break; }
  case 15: 
   var $i16_0;
   var $79=(($i16_0)|(0)) > 0;
   if ($79) { var $_in_i8_in_sroa_speculated = $i16_0;var $i16_0114 = $i16_0;label = 17; break; } else { var $i16_0113 = $i16_0;label = 16; break; }
  case 16: 
   var $i16_0113;
   var $_in_i8_in_sroa_speculated = $68;var $i16_0114 = $i16_0113;label = 17; break;
  case 17: 
   var $i16_0114;
   var $_in_i8_in_sroa_speculated;
   var $80=((($_in_i8_in_sroa_speculated)-(1))|0);
   var $81=(($80)|(0)) > 0;
   var $_118=$81 ? $80 : $68;
   var $82=((($_118)-(1))|0);
   var $83=__ZL8diagonaliiiPKiPi($82, $i16_0114, $68, $verts, $indices);
   var $84=(($indices+($80<<2))|0);
   var $85=HEAP32[(($84)>>2)];
   if ($83) { label = 18; break; } else { label = 19; break; }
  case 18: 
   var $87=$85 | -2147483648;
   HEAP32[(($84)>>2)]=$87;
   label = 20; break;
  case 19: 
   var $89=$85 & 268435455;
   HEAP32[(($84)>>2)]=$89;
   label = 20; break;
  case 20: 
   var $90=((($i16_0114)+(1))|0);
   var $91=(($90)|(0)) < (($68)|(0));
   var $_119=$91 ? $90 : 0;
   var $92=__ZL8diagonaliiiPKiPi($80, $_119, $68, $verts, $indices);
   var $93=(($indices+($i16_0114<<2))|0);
   var $94=HEAP32[(($93)>>2)];
   if ($92) { label = 21; break; } else { label = 22; break; }
  case 21: 
   var $96=$94 | -2147483648;
   HEAP32[(($93)>>2)]=$96;
   var $_0 = $68;var $ntris_0 = $67;var $dst_0 = $66;label = 5; break;
  case 22: 
   var $98=$94 & 268435455;
   HEAP32[(($93)>>2)]=$98;
   var $_0 = $68;var $ntris_0 = $67;var $dst_0 = $66;label = 5; break;
  case 23: 
   var $100=HEAP32[(($indices)>>2)];
   var $101=$100 & 268435455;
   var $102=(($dst_0+4)|0);
   HEAP32[(($dst_0)>>2)]=$101;
   var $103=(($indices+4)|0);
   var $104=HEAP32[(($103)>>2)];
   var $105=$104 & 268435455;
   var $106=(($dst_0+8)|0);
   HEAP32[(($102)>>2)]=$105;
   var $107=(($indices+8)|0);
   var $108=HEAP32[(($107)>>2)];
   var $109=$108 & 268435455;
   HEAP32[(($106)>>2)]=$109;
   var $110=((($ntris_0)+(1))|0);
   var $storemerge3 = $110;label = 24; break;
  case 24: 
   var $storemerge3;
   return $storemerge3;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL10mergePolysPtS_iiS_i($pa, $pb, $ea, $eb, $tmp, $nvp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $storemerge_i = 0;label = 2; break;
  case 2: 
   var $storemerge_i;
   var $2=(($storemerge_i)|(0)) < (($nvp)|(0));
   if ($2) { label = 3; break; } else { var $storemerge1_i_in_sroa_speculated = $nvp;label = 5; break; }
  case 3: 
   var $4=(($pa+($storemerge_i<<1))|0);
   var $5=HEAP16[(($4)>>1)];
   var $6=(($5 << 16) >> 16)==-1;
   if ($6) { var $storemerge1_i_in_sroa_speculated = $storemerge_i;label = 5; break; } else { label = 4; break; }
  case 4: 
   var $8=((($storemerge_i)+(1))|0);
   var $storemerge_i = $8;label = 2; break;
  case 5: 
   var $storemerge1_i_in_sroa_speculated;
   var $storemerge_i3 = 0;label = 6; break;
  case 6: 
   var $storemerge_i3;
   var $10=(($storemerge_i3)|(0)) < (($nvp)|(0));
   if ($10) { label = 7; break; } else { var $storemerge1_i4_in_sroa_speculated = $nvp;label = 9; break; }
  case 7: 
   var $12=(($pb+($storemerge_i3<<1))|0);
   var $13=HEAP16[(($12)>>1)];
   var $14=(($13 << 16) >> 16)==-1;
   if ($14) { var $storemerge1_i4_in_sroa_speculated = $storemerge_i3;label = 9; break; } else { label = 8; break; }
  case 8: 
   var $16=((($storemerge_i3)+(1))|0);
   var $storemerge_i3 = $16;label = 6; break;
  case 9: 
   var $storemerge1_i4_in_sroa_speculated;
   var $17=$tmp;
   var $18=$nvp << 1;
   _memset($17, -1, $18);
   var $19=((($storemerge1_i_in_sroa_speculated)-(1))|0);
   var $20=((($ea)+(1))|0);
   var $storemerge = 0;var $n_0 = 0;label = 10; break;
  case 10: 
   var $n_0;
   var $storemerge;
   var $22=(($storemerge)|(0)) < (($19)|(0));
   if ($22) { label = 12; break; } else { label = 11; break; }
  case 11: 
   var $23=((($storemerge1_i4_in_sroa_speculated)-(1))|0);
   var $24=((($eb)+(1))|0);
   var $storemerge1 = 0;var $n_1 = $n_0;label = 13; break;
  case 12: 
   var $26=((($20)+($storemerge))|0);
   var $27=((((($26)|(0)))%((($storemerge1_i_in_sroa_speculated)|(0))))&-1);
   var $28=(($pa+($27<<1))|0);
   var $29=HEAP16[(($28)>>1)];
   var $30=((($n_0)+(1))|0);
   var $31=(($tmp+($n_0<<1))|0);
   HEAP16[(($31)>>1)]=$29;
   var $32=((($storemerge)+(1))|0);
   var $storemerge = $32;var $n_0 = $30;label = 10; break;
  case 13: 
   var $n_1;
   var $storemerge1;
   var $34=(($storemerge1)|(0)) < (($23)|(0));
   if ($34) { label = 14; break; } else { label = 15; break; }
  case 14: 
   var $36=((($24)+($storemerge1))|0);
   var $37=((((($36)|(0)))%((($storemerge1_i4_in_sroa_speculated)|(0))))&-1);
   var $38=(($pb+($37<<1))|0);
   var $39=HEAP16[(($38)>>1)];
   var $40=((($n_1)+(1))|0);
   var $41=(($tmp+($n_1<<1))|0);
   HEAP16[(($41)>>1)]=$39;
   var $42=((($storemerge1)+(1))|0);
   var $storemerge1 = $42;var $n_1 = $40;label = 13; break;
  case 15: 
   var $44=$pa;
   assert($18 % 1 === 0);(_memcpy($44, $17, $18)|0);
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL8diagonaliiiPKiPi($i, $j, $n, $verts, $indices) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $0=(($indices+($i<<2))|0);
   var $1=HEAP32[(($0)>>2)];
   var $2=$1 << 2;
   var $3=$2 & 1073741820;
   var $4=(($verts+($3<<2))|0);
   var $5=(($indices+($j<<2))|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=$6 << 2;
   var $8=$7 & 1073741820;
   var $9=(($verts+($8<<2))|0);
   var $10=((($i)+(1))|0);
   var $11=(($10)|(0)) < (($n)|(0));
   var $_=$11 ? $10 : 0;
   var $12=(($indices+($_<<2))|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=$13 << 2;
   var $15=$14 & 1073741820;
   var $16=(($verts+($15<<2))|0);
   var $17=(($i)|(0)) > 0;
   var $_in_i_i_in_sroa_speculated=$17 ? $i : $n;
   var $18=((($_in_i_i_in_sroa_speculated)-(1))|0);
   var $19=(($indices+($18<<2))|0);
   var $20=HEAP32[(($19)>>2)];
   var $21=$20 << 2;
   var $22=$21 & 1073741820;
   var $23=(($verts+($22<<2))|0);
   var $24=HEAP32[(($4)>>2)];
   var $25=HEAP32[(($23)>>2)];
   var $26=((($24)-($25))|0);
   var $_sum309=$15 | 2;
   var $27=(($verts+($_sum309<<2))|0);
   var $28=HEAP32[(($27)>>2)];
   var $_sum310=$22 | 2;
   var $29=(($verts+($_sum310<<2))|0);
   var $30=HEAP32[(($29)>>2)];
   var $31=((($28)-($30))|0);
   var $32=(Math.imul($26,$31)|0);
   var $33=HEAP32[(($16)>>2)];
   var $34=((($33)-($25))|0);
   var $_sum311=$3 | 2;
   var $35=(($verts+($_sum311<<2))|0);
   var $36=HEAP32[(($35)>>2)];
   var $37=((($36)-($30))|0);
   var $38=(Math.imul($34,$37)|0);
   var $39=((($32)-($38))|0);
   var $40=(($39)|(0)) < 1;
   var $41=HEAP32[(($9)>>2)];
   var $42=((($41)-($24))|0);
   if ($40) { label = 2; break; } else { label = 4; break; }
  case 2: 
   var $44=((($30)-($36))|0);
   var $45=(Math.imul($42,$44)|0);
   var $46=((($25)-($24))|0);
   var $_sum319=$8 | 2;
   var $47=(($verts+($_sum319<<2))|0);
   var $48=HEAP32[(($47)>>2)];
   var $49=((($48)-($36))|0);
   var $50=(Math.imul($46,$49)|0);
   var $51=((($45)-($50))|0);
   var $52=(($51)|(0)) < 0;
   if ($52) { label = 3; break; } else { var $166 = 0;label = 27; break; }
  case 3: 
   var $54=((($24)-($41))|0);
   var $55=((($28)-($48))|0);
   var $56=(Math.imul($54,$55)|0);
   var $57=((($33)-($41))|0);
   var $58=((($36)-($48))|0);
   var $59=(Math.imul($57,$58)|0);
   var $60=((($56)-($59))|0);
   var $61=(($60)|(0)) < 0;
   if ($61) { var $80 = $48;var $79 = $41;label = 6; break; } else { var $166 = 0;label = 27; break; }
  case 4: 
   var $63=((($28)-($36))|0);
   var $64=(Math.imul($42,$63)|0);
   var $65=((($33)-($24))|0);
   var $_sum312=$8 | 2;
   var $66=(($verts+($_sum312<<2))|0);
   var $67=HEAP32[(($66)>>2)];
   var $68=((($67)-($36))|0);
   var $69=(Math.imul($65,$68)|0);
   var $70=((($64)-($69))|0);
   var $71=(($70)|(0)) < 1;
   if ($71) { label = 5; break; } else { var $80 = $67;var $79 = $41;label = 6; break; }
  case 5: 
   var $72=((($24)-($41))|0);
   var $73=((($30)-($67))|0);
   var $74=(Math.imul($72,$73)|0);
   var $75=((($25)-($41))|0);
   var $76=((($36)-($67))|0);
   var $77=(Math.imul($75,$76)|0);
   var $78=((($74)-($77))|0);
   var $phitmp_i=(($78)|(0)) > 0;
   if ($phitmp_i) { var $80 = $67;var $79 = $41;label = 6; break; } else { var $166 = 0;label = 27; break; }
  case 6: 
   var $79;
   var $80;
   var $storemerge_i1 = 0;label = 7; break;
  case 7: 
   var $storemerge_i1;
   var $81=(($storemerge_i1)|(0)) < (($n)|(0));
   if ($81) { label = 8; break; } else { var $166 = 1;label = 27; break; }
  case 8: 
   var $82=((($storemerge_i1)+(1))|0);
   var $83=(($82)|(0)) < (($n)|(0));
   var $_321=$83 ? $82 : 0;
   var $84=(($storemerge_i1)|(0))==(($i)|(0));
   var $85=(($_321)|(0))==(($i)|(0));
   var $or_cond=$84 | $85;
   var $86=(($storemerge_i1)|(0))==(($j)|(0));
   var $or_cond322=$or_cond | $86;
   var $87=(($_321)|(0))==(($j)|(0));
   var $or_cond323=$or_cond322 | $87;
   if ($or_cond323) { var $storemerge_i1 = $82;label = 7; break; } else { label = 9; break; }
  case 9: 
   var $89=(($indices+($storemerge_i1<<2))|0);
   var $90=HEAP32[(($89)>>2)];
   var $91=$90 << 2;
   var $92=$91 & 1073741820;
   var $93=(($verts+($92<<2))|0);
   var $94=(($indices+($_321<<2))|0);
   var $95=HEAP32[(($94)>>2)];
   var $96=$95 << 2;
   var $97=$96 & 1073741820;
   var $98=(($verts+($97<<2))|0);
   var $99=HEAP32[(($93)>>2)];
   var $100=(($24)|(0))==(($99)|(0));
   if ($100) { label = 10; break; } else { label = 11; break; }
  case 10: 
   var $_sum318=$92 | 2;
   var $101=(($verts+($_sum318<<2))|0);
   var $102=HEAP32[(($101)>>2)];
   var $103=(($36)|(0))==(($102)|(0));
   if ($103) { var $storemerge_i1 = $82;label = 7; break; } else { label = 11; break; }
  case 11: 
   var $104=(($79)|(0))==(($99)|(0));
   if ($104) { label = 12; break; } else { label = 13; break; }
  case 12: 
   var $_sum317=$92 | 2;
   var $105=(($verts+($_sum317<<2))|0);
   var $106=HEAP32[(($105)>>2)];
   var $107=(($80)|(0))==(($106)|(0));
   if ($107) { var $storemerge_i1 = $82;label = 7; break; } else { label = 13; break; }
  case 13: 
   var $108=HEAP32[(($98)>>2)];
   var $109=(($24)|(0))==(($108)|(0));
   if ($109) { label = 14; break; } else { label = 15; break; }
  case 14: 
   var $_sum316=$97 | 2;
   var $110=(($verts+($_sum316<<2))|0);
   var $111=HEAP32[(($110)>>2)];
   var $112=(($36)|(0))==(($111)|(0));
   if ($112) { var $storemerge_i1 = $82;label = 7; break; } else { label = 15; break; }
  case 15: 
   var $113=(($79)|(0))==(($108)|(0));
   if ($113) { label = 16; break; } else { label = 17; break; }
  case 16: 
   var $_sum315=$97 | 2;
   var $114=(($verts+($_sum315<<2))|0);
   var $115=HEAP32[(($114)>>2)];
   var $116=(($80)|(0))==(($115)|(0));
   if ($116) { var $storemerge_i1 = $82;label = 7; break; } else { label = 17; break; }
  case 17: 
   var $117=((($79)-($24))|0);
   var $_sum313=$92 | 2;
   var $118=(($verts+($_sum313<<2))|0);
   var $119=HEAP32[(($118)>>2)];
   var $120=((($119)-($36))|0);
   var $121=(Math.imul($117,$120)|0);
   var $122=((($99)-($24))|0);
   var $123=((($80)-($36))|0);
   var $124=(Math.imul($122,$123)|0);
   var $125=(($121)|(0))==(($124)|(0));
   if ($125) { label = 23; break; } else { label = 18; break; }
  case 18: 
   var $_sum314=$97 | 2;
   var $127=(($verts+($_sum314<<2))|0);
   var $128=HEAP32[(($127)>>2)];
   var $129=((($128)-($36))|0);
   var $130=(Math.imul($117,$129)|0);
   var $131=((($108)-($24))|0);
   var $132=(Math.imul($131,$123)|0);
   var $133=(($130)|(0))==(($132)|(0));
   if ($133) { label = 23; break; } else { label = 19; break; }
  case 19: 
   var $135=((($108)-($99))|0);
   var $136=((($36)-($119))|0);
   var $137=(Math.imul($135,$136)|0);
   var $138=((($24)-($99))|0);
   var $139=((($128)-($119))|0);
   var $140=(Math.imul($138,$139)|0);
   var $141=(($137)|(0))==(($140)|(0));
   if ($141) { label = 23; break; } else { label = 20; break; }
  case 20: 
   var $143=((($80)-($119))|0);
   var $144=(Math.imul($135,$143)|0);
   var $145=((($79)-($99))|0);
   var $146=(Math.imul($145,$139)|0);
   var $147=(($144)|(0))==(($146)|(0));
   if ($147) { label = 23; break; } else { label = 21; break; }
  case 21: 
   var $149=((($121)-($124))|0);
   var $150=(($149)|(0)) < 0;
   var $151=((($130)-($132))|0);
   var $152=(($151)|(0)) < 0;
   var $153=$150 ^ $152;
   if ($153) { label = 22; break; } else { label = 23; break; }
  case 22: 
   var $154=((($137)-($140))|0);
   var $155=(($154)|(0)) < 0;
   var $156=((($144)-($146))|0);
   var $157=(($156)|(0)) < 0;
   var $158=$155 ^ $157;
   if ($158) { var $166 = 0;label = 27; break; } else { label = 23; break; }
  case 23: 
   var $159=__ZL7betweenPKiS0_S0_($4, $9, $93);
   if ($159) { var $166 = 0;label = 27; break; } else { label = 24; break; }
  case 24: 
   var $161=__ZL7betweenPKiS0_S0_($4, $9, $98);
   if ($161) { var $166 = 0;label = 27; break; } else { label = 25; break; }
  case 25: 
   var $163=__ZL7betweenPKiS0_S0_($93, $98, $4);
   if ($163) { var $166 = 0;label = 27; break; } else { label = 26; break; }
  case 26: 
   var $165=__ZL7betweenPKiS0_S0_($93, $98, $9);
   if ($165) { var $166 = 0;label = 27; break; } else { var $storemerge_i1 = $82;label = 7; break; }
  case 27: 
   var $166;
   return $166;
  default: assert(0, "bad label: " + label);
 }
}
function __Z21rcBuildPolyMeshDetailP9rcContextRK10rcPolyMeshRK20rcCompactHeightfieldffR16rcPolyMeshDetail($ctx, $mesh, $chf, $sampleDist, $sampleMaxError, $dmesh) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 4216)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $edge_i=sp;
   var $hull_i=(sp)+(400);
   var $idx_i=(sp)+(912);
   var $pt_i=(sp)+(1040);
   var $edges=(sp)+(1056);
   var $tris=(sp)+(1072);
   var $stack=(sp)+(1088);
   var $samples=(sp)+(1104);
   var $verts=(sp)+(1120);
   var $hp=(sp)+(4192);
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 26);
   label = 3; break;
  case 3: 
   var $10=(($mesh+20)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($11)|(0))==0;
   if ($12) { var $_2 = 1;label = 235; break; } else { label = 4; break; }
  case 4: 
   var $14=(($mesh+24)|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=(($15)|(0))==0;
   if ($16) { var $_2 = 1;label = 235; break; } else { label = 5; break; }
  case 5: 
   var $18=(($mesh+32)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($mesh+60)|0);
   var $21=HEAPF32[(($20)>>2)];
   var $22=(($mesh+64)|0);
   var $23=HEAPF32[(($22)>>2)];
   var $24=(($mesh+36)|0);
   var $25=(($mesh+68)|0);
   var $26=HEAP32[(($25)>>2)];
   var $27=(($edges)|0);
   HEAP32[(($27)>>2)]=0;
   var $28=(($edges+4)|0);
   HEAP32[(($28)>>2)]=0;
   var $29=(($edges+8)|0);
   HEAP32[(($29)>>2)]=0;
   __ZN10rcIntArray6resizeEi($edges, 64);
   var $30=(($tris)|0);
   HEAP32[(($30)>>2)]=0;
   var $31=(($tris+4)|0);
   HEAP32[(($31)>>2)]=0;
   var $32=(($tris+8)|0);
   HEAP32[(($32)>>2)]=0;
   __ZN10rcIntArray6resizeEi($tris, 512);
   var $33=(($stack)|0);
   HEAP32[(($33)>>2)]=0;
   var $34=(($stack+4)|0);
   HEAP32[(($34)>>2)]=0;
   var $35=(($stack+8)|0);
   HEAP32[(($35)>>2)]=0;
   __ZN10rcIntArray6resizeEi($stack, 512);
   var $36=(($samples)|0);
   HEAP32[(($36)>>2)]=0;
   var $37=(($samples+4)|0);
   HEAP32[(($37)>>2)]=0;
   var $38=(($samples+8)|0);
   HEAP32[(($38)>>2)]=0;
   __ZN10rcIntArray6resizeEi($samples, 512);
   var $39=(($hp)|0);
   var $40=(($hp+4)|0);
   var $41=(($hp+8)|0);
   var $42=(($hp+12)|0);
   var $43=(($hp+16)|0);
   var $44=$hp;
   HEAP32[(($44)>>2)]=0; HEAP32[((($44)+(4))>>2)]=0; HEAP32[((($44)+(8))>>2)]=0; HEAP32[((($44)+(12))>>2)]=0; HEAP32[((($44)+(16))>>2)]=0;
   var $45=HEAP32[(($14)>>2)];
   var $46=$45 << 4;
   var $47=_malloc($46);
   var $48=$47;
   var $49=(($47)|(0))==0;
   if ($49) { label = 6; break; } else { label = 8; break; }
  case 6: 
   var $51=HEAP32[(($14)>>2)];
   var $52=$51 << 2;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3968)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$52,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_111951196 = 0;label = 215; break; } else { label = 7; break; }
  case 7: 
   var $53$0 = ___cxa_find_matching_catch(-1, -1); $53$1 = tempRet0;
   var $54=$53$0;
   var $55=$53$1;
   var $_011991201 = $55;var $_0105211981203 = $54;label = 227; break;
  case 8: 
   var $57=((($19)*(12))&-1);
   var $58=_malloc($57);
   var $59=$58;
   var $60=(($58)|(0))==0;
   if ($60) { label = 10; break; } else { label = 9; break; }
  case 9: 
   var $61=(($mesh+4)|0);
   var $62=(($chf)|0);
   var $63=(($chf+4)|0);
   var $64=(($mesh)|0);
   var $storemerge = 0;var $maxhh_0 = 0;var $maxhw_0 = 0;var $nPolyVerts_0 = 0;label = 17; break;
  case 10: 
   var $66=((($19)*(3))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5840)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$66,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $1357 = 0;var $_11205 = 0;label = 212; break; } else { var $67 = 0;label = 14; break; }
  case 11: 
   var $lpad_loopexit$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit$1 = tempRet0;
   var $lpad_phi$1 = $lpad_loopexit$1;var $lpad_phi$0 = $lpad_loopexit$0;var $68 = $511;label = 15; break;
  case 12: 
   var $lpad_loopexit1130$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit1130$1 = tempRet0;
   var $lpad_phi$1 = $lpad_loopexit1130$1;var $lpad_phi$0 = $lpad_loopexit1130$0;var $68 = $511;label = 15; break;
  case 13: 
   var $lpad_loopexit1134$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit1134$1 = tempRet0;
   var $lpad_phi$1 = $lpad_loopexit1134$1;var $lpad_phi$0 = $lpad_loopexit1134$0;var $68 = $511;label = 15; break;
  case 14: 
   var $67;
   var $lpad_nonloopexit$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit$1 = tempRet0;
   var $lpad_phi$1 = $lpad_nonloopexit$1;var $lpad_phi$0 = $lpad_nonloopexit$0;var $68 = $67;label = 15; break;
  case 15: 
   var $68;
   var $lpad_phi$0;
   var $lpad_phi$1;
   var $69=$lpad_phi$0;
   var $70=$lpad_phi$1;
   if ($60) { label = 223; break; } else { label = 16; break; }
  case 16: 
   _free($58);
   label = 223; break;
  case 17: 
   var $nPolyVerts_0;
   var $maxhw_0;
   var $maxhh_0;
   var $storemerge;
   var $73=HEAP32[(($14)>>2)];
   var $74=(($storemerge)|(0)) < (($73)|(0));
   if ($74) { label = 18; break; } else { label = 25; break; }
  case 18: 
   var $76=(Math.imul($storemerge,$19)|0);
   var $77=$76 << 1;
   var $78=HEAP32[(($61)>>2)];
   var $79=$storemerge << 2;
   var $80=(($48+($79<<2))|0);
   var $81=$79 | 1;
   var $82=(($48+($81<<2))|0);
   var $83=$79 | 2;
   var $84=(($48+($83<<2))|0);
   var $85=$79 | 3;
   var $86=(($48+($85<<2))|0);
   var $87=HEAP32[(($62)>>2)];
   HEAP32[(($80)>>2)]=$87;
   HEAP32[(($82)>>2)]=0;
   var $88=HEAP32[(($63)>>2)];
   HEAP32[(($84)>>2)]=$88;
   HEAP32[(($86)>>2)]=0;
   var $storemerge7 = 0;var $nPolyVerts_1 = $nPolyVerts_0;var $93 = $87;var $92 = 0;var $91 = $88;var $90 = 0;label = 19; break;
  case 19: 
   var $90;
   var $91;
   var $92;
   var $93;
   var $nPolyVerts_1;
   var $storemerge7;
   var $94=(($storemerge7)|(0)) < (($19)|(0));
   if ($94) { label = 20; break; } else { label = 22; break; }
  case 20: 
   var $_sum1192=((($77)+($storemerge7))|0);
   var $96=(($78+($_sum1192<<1))|0);
   var $97=HEAP16[(($96)>>1)];
   var $98=(($97 << 16) >> 16)==-1;
   if ($98) { label = 22; break; } else { label = 21; break; }
  case 21: 
   var $100=(($97)&(65535));
   var $101=((($100)*(3))&-1);
   var $102=HEAP32[(($64)>>2)];
   var $103=(($102+($101<<1))|0);
   var $104=HEAP16[(($103)>>1)];
   var $105=(($104)&(65535));
   var $106=(($93)|(0)) < (($105)|(0));
   var $107=$106 ? $93 : $105;
   HEAP32[(($80)>>2)]=$107;
   var $108=HEAP16[(($103)>>1)];
   var $109=(($108)&(65535));
   var $110=(($92)|(0)) > (($109)|(0));
   var $111=$110 ? $92 : $109;
   HEAP32[(($82)>>2)]=$111;
   var $_sum1193=((($101)+(2))|0);
   var $112=(($102+($_sum1193<<1))|0);
   var $113=HEAP16[(($112)>>1)];
   var $114=(($113)&(65535));
   var $115=(($91)|(0)) < (($114)|(0));
   var $116=$115 ? $91 : $114;
   HEAP32[(($84)>>2)]=$116;
   var $117=HEAP16[(($112)>>1)];
   var $118=(($117)&(65535));
   var $119=(($90)|(0)) > (($118)|(0));
   var $120=$119 ? $90 : $118;
   HEAP32[(($86)>>2)]=$120;
   var $121=((($nPolyVerts_1)+(1))|0);
   var $122=((($storemerge7)+(1))|0);
   var $storemerge7 = $122;var $nPolyVerts_1 = $121;var $93 = $107;var $92 = $111;var $91 = $116;var $90 = $120;label = 19; break;
  case 22: 
   var $124=((($93)-(1))|0);
   var $125=(($124)|(0)) < 0;
   var $126=$125 ? 0 : $124;
   HEAP32[(($80)>>2)]=$126;
   var $127=HEAP32[(($62)>>2)];
   var $128=((($92)+(1))|0);
   var $129=(($127)|(0)) < (($128)|(0));
   var $130=$129 ? $127 : $128;
   HEAP32[(($82)>>2)]=$130;
   var $131=((($91)-(1))|0);
   var $132=(($131)|(0)) < 0;
   var $133=$132 ? 0 : $131;
   HEAP32[(($84)>>2)]=$133;
   var $134=HEAP32[(($63)>>2)];
   var $135=((($90)+(1))|0);
   var $136=(($134)|(0)) < (($135)|(0));
   var $137=$136 ? $134 : $135;
   HEAP32[(($86)>>2)]=$137;
   var $138=(($126)|(0)) < (($130)|(0));
   var $139=(($133)|(0)) < (($137)|(0));
   var $or_cond=$138 & $139;
   if ($or_cond) { label = 23; break; } else { var $maxhh_1 = $maxhh_0;var $maxhw_1 = $maxhw_0;label = 24; break; }
  case 23: 
   var $141=((($130)-($126))|0);
   var $142=(($maxhw_0)|(0)) > (($141)|(0));
   var $143=$142 ? $maxhw_0 : $141;
   var $144=((($137)-($133))|0);
   var $145=(($maxhh_0)|(0)) > (($144)|(0));
   var $146=$145 ? $maxhh_0 : $144;
   var $maxhh_1 = $146;var $maxhw_1 = $143;label = 24; break;
  case 24: 
   var $maxhw_1;
   var $maxhh_1;
   var $148=((($storemerge)+(1))|0);
   var $storemerge = $148;var $maxhh_0 = $maxhh_1;var $maxhw_0 = $maxhw_1;var $nPolyVerts_0 = $nPolyVerts_1;label = 17; break;
  case 25: 
   var $150=$maxhw_0 << 1;
   var $151=(Math.imul($150,$maxhh_0)|0);
   var $152=_malloc($151);
   var $153=$152;
   HEAP32[(($39)>>2)]=$153;
   var $154=(($152)|(0))==0;
   if ($154) { label = 26; break; } else { label = 27; break; }
  case 26: 
   var $156=(Math.imul($maxhw_0,$maxhh_0)|0);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((4544)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$156,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $153;label = 209; break; } else { var $67 = $153;label = 14; break; }
  case 27: 
   var $158=HEAP32[(($14)>>2)];
   var $159=(($dmesh+12)|0);
   HEAP32[(($159)>>2)]=$158;
   var $160=(($dmesh+16)|0);
   HEAP32[(($160)>>2)]=0;
   var $161=(($dmesh+20)|0);
   HEAP32[(($161)>>2)]=0;
   var $162=$158 << 4;
   var $163=_malloc($162);
   var $164=$163;
   var $165=(($dmesh)|0);
   HEAP32[(($165)>>2)]=$164;
   var $166=(($163)|(0))==0;
   if ($166) { label = 28; break; } else { label = 29; break; }
  case 28: 
   var $168=HEAP32[(($159)>>2)];
   var $169=$168 << 2;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3616)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$169,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $153;label = 209; break; } else { var $67 = $153;label = 14; break; }
  case 29: 
   var $171=((((($nPolyVerts_0)|(0)))/(2))&-1);
   var $172=((($nPolyVerts_0)+($171))|0);
   var $173=$172 << 1;
   HEAP32[(($160)>>2)]=0;
   var $174=((($172)*(12))&-1);
   var $175=_malloc($174);
   var $176=$175;
   var $177=(($dmesh+4)|0);
   HEAP32[(($177)>>2)]=$176;
   var $178=(($175)|(0))==0;
   if ($178) { label = 30; break; } else { label = 31; break; }
  case 30: 
   var $180=((($172)*(3))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2600)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$180,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $153;label = 209; break; } else { var $67 = $153;label = 14; break; }
  case 31: 
   HEAP32[(($161)>>2)]=0;
   var $182=$172 << 5;
   var $183=_malloc($182);
   var $184=(($dmesh+8)|0);
   HEAP32[(($184)>>2)]=$183;
   var $185=(($183)|(0))==0;
   if ($185) { label = 33; break; } else { label = 32; break; }
  case 32: 
   var $186=(($chf+60)|0);
   var $187=(($chf+64)|0);
   var $188=(($verts)|0);
   var $189=$edge_i;
   var $190=$hull_i;
   var $191=$idx_i;
   var $192=$pt_i;
   var $193=(($chf+52)|0);
   var $194=$sampleDist > 0;
   var $195=(($chf+56)|0);
   var $196=(($idx_i+4)|0);
   var $197=($sampleMaxError)*($sampleMaxError);
   var $198=(($hull_i)|0);
   var $199=(($mesh+40)|0);
   var $200=(($mesh+44)|0);
   var $201=(($58+4)|0);
   var $202=$201;
   var $203=(($58+8)|0);
   var $204=$203;
   var $205=(($pt_i)|0);
   var $206=(($pt_i+4)|0);
   var $207=(($pt_i+8)|0);
   var $208=($sampleDist)*(-0.5);
   var $storemerge1 = 0;var $tcap_0 = $173;var $vcap_0 = $172;var $212 = $153;label = 34; break;
  case 33: 
   var $210=$172 << 3;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((1816)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$210,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $153;label = 209; break; } else { var $67 = $153;label = 14; break; }
  case 34: 
   var $212;
   var $vcap_0;
   var $tcap_0;
   var $storemerge1;
   var $213=HEAP32[(($14)>>2)];
   var $214=(($storemerge1)|(0)) < (($213)|(0));
   if ($214) { label = 35; break; } else { label = 207; break; }
  case 35: 
   var $216=(Math.imul($storemerge1,$19)|0);
   var $217=$216 << 1;
   var $218=HEAP32[(($61)>>2)];
   var $storemerge2 = 0;var $npoly_0 = 0;label = 36; break;
  case 36: 
   var $npoly_0;
   var $storemerge2;
   var $220=(($storemerge2)|(0)) < (($19)|(0));
   if ($220) { label = 37; break; } else { label = 39; break; }
  case 37: 
   var $_sum1189=((($217)+($storemerge2))|0);
   var $222=(($218+($_sum1189<<1))|0);
   var $223=HEAP16[(($222)>>1)];
   var $224=(($223 << 16) >> 16)==-1;
   if ($224) { label = 39; break; } else { label = 38; break; }
  case 38: 
   var $226=(($223)&(65535));
   var $227=((($226)*(3))&-1);
   var $228=HEAP32[(($64)>>2)];
   var $229=(($228+($227<<1))|0);
   var $230=HEAP16[(($229)>>1)];
   var $231=(($230)&(65535));
   var $232=(($231)|(0));
   var $233=((($storemerge2)*(3))&-1);
   var $234=($232)*($21);
   var $235=(($59+($233<<2))|0);
   HEAPF32[(($235)>>2)]=$234;
   var $_sum1190=((($227)+(1))|0);
   var $236=(($228+($_sum1190<<1))|0);
   var $237=HEAP16[(($236)>>1)];
   var $238=(($237)&(65535));
   var $239=(($238)|(0));
   var $240=((($233)+(1))|0);
   var $241=($239)*($23);
   var $242=(($59+($240<<2))|0);
   HEAPF32[(($242)>>2)]=$241;
   var $_sum1191=((($227)+(2))|0);
   var $243=(($228+($_sum1191<<1))|0);
   var $244=HEAP16[(($243)>>1)];
   var $245=(($244)&(65535));
   var $246=(($245)|(0));
   var $247=((($233)+(2))|0);
   var $248=($246)*($21);
   var $249=(($59+($247<<2))|0);
   HEAPF32[(($249)>>2)]=$248;
   var $250=((($npoly_0)+(1))|0);
   var $251=((($storemerge2)+(1))|0);
   var $storemerge2 = $251;var $npoly_0 = $250;label = 36; break;
  case 39: 
   var $253=$storemerge1 << 2;
   var $254=(($48+($253<<2))|0);
   var $255=HEAP32[(($254)>>2)];
   HEAP32[(($40)>>2)]=$255;
   var $256=$253 | 2;
   var $257=(($48+($256<<2))|0);
   var $258=HEAP32[(($257)>>2)];
   HEAP32[(($41)>>2)]=$258;
   var $259=$253 | 1;
   var $260=(($48+($259<<2))|0);
   var $261=HEAP32[(($260)>>2)];
   var $262=((($261)-($255))|0);
   HEAP32[(($42)>>2)]=$262;
   var $263=$253 | 3;
   var $264=(($48+($263<<2))|0);
   var $265=HEAP32[(($264)>>2)];
   var $266=((($265)-($258))|0);
   HEAP32[(($43)>>2)]=$266;
   var $267=HEAP32[(($64)>>2)];
   var $268=$212;
   var $269=$262 << 1;
   var $270=(Math.imul($269,$266)|0);
   _memset($268, 0, $270);
   __ZN10rcIntArray6resizeEi($stack, 0);
   var $storemerge_i30 = 0;label = 40; break;
  case 40: 
   var $storemerge_i30;
   var $272=(($storemerge_i30)|(0)) < (($npoly_0)|(0));
   if ($272) { label = 41; break; } else { var $storemerge1_i32 = 0;var $pcx_i_0 = 0;var $pcz_i_0 = 0;label = 51; break; }
  case 41: 
   var $_sum1188=((($217)+($storemerge_i30))|0);
   var $274=(($218+($_sum1188<<1))|0);
   var $275=HEAP32[(($40)>>2)];
   var $276=HEAP32[(($42)>>2)];
   var $277=((($275)+($276))|0);
   var $278=HEAP32[(($41)>>2)];
   var $279=HEAP32[(($43)>>2)];
   var $280=((($278)+($279))|0);
   var $storemerge6_i31 = 0;var $cx_i_0 = 0;var $cz_i_0 = 0;var $ci_i_0 = -1;var $dmin_i_0 = 65535;label = 42; break;
  case 42: 
   var $dmin_i_0;
   var $ci_i_0;
   var $cz_i_0;
   var $cx_i_0;
   var $storemerge6_i31;
   var $282=(($storemerge6_i31)|(0)) < 9;
   if ($282) { label = 43; break; } else { label = 48; break; }
  case 43: 
   var $284=HEAP16[(($274)>>1)];
   var $285=(($284)&(65535));
   var $286=((($285)*(3))&-1);
   var $287=(($267+($286<<1))|0);
   var $288=HEAP16[(($287)>>1)];
   var $289=(($288)&(65535));
   var $290=$storemerge6_i31 << 1;
   var $291=((6544+($290<<2))|0);
   var $292=HEAP32[(($291)>>2)];
   var $293=((($289)+($292))|0);
   var $294=((($286)+(1))|0);
   var $295=(($267+($294<<1))|0);
   var $296=HEAP16[(($295)>>1)];
   var $297=(($296)&(65535));
   var $298=((($286)+(2))|0);
   var $299=(($267+($298<<1))|0);
   var $300=HEAP16[(($299)>>1)];
   var $301=(($300)&(65535));
   var $302=$290 | 1;
   var $303=((6544+($302<<2))|0);
   var $304=HEAP32[(($303)>>2)];
   var $305=((($301)+($304))|0);
   var $306=(($293)|(0)) >= (($275)|(0));
   var $307=(($293)|(0)) < (($277)|(0));
   var $or_cond1206=$306 & $307;
   var $or_cond1206_not=$or_cond1206 ^ 1;
   var $308=(($305)|(0)) < (($278)|(0));
   var $or_cond1207=$or_cond1206_not | $308;
   var $or_cond1207_not=$or_cond1207 ^ 1;
   var $309=(($305)|(0)) < (($280)|(0));
   var $or_cond1208=$or_cond1207_not & $309;
   if ($or_cond1208) { label = 44; break; } else { var $cx_i_3 = $cx_i_0;var $cz_i_3 = $cz_i_0;var $ci_i_3 = $ci_i_0;var $dmin_i_3 = $dmin_i_0;label = 47; break; }
  case 44: 
   var $311=((($293)+($26))|0);
   var $312=((($305)+($26))|0);
   var $313=HEAP32[(($62)>>2)];
   var $314=(Math.imul($312,$313)|0);
   var $315=((($311)+($314))|0);
   var $316=HEAP32[(($186)>>2)];
   var $317=(($316+($315<<2))|0);
   var $318=$317;
   var $319=HEAP32[(($318)>>2)];
   var $320=$319 & 16777215;
   var $321=$319 >>> 24;
   var $322=((($320)+($321))|0);
   var $cx_i_1 = $cx_i_0;var $cz_i_1 = $cz_i_0;var $ci_i_1 = $ci_i_0;var $dmin_i_1 = $dmin_i_0;var $i_i28_0 = $320;label = 45; break;
  case 45: 
   var $i_i28_0;
   var $dmin_i_1;
   var $ci_i_1;
   var $cz_i_1;
   var $cx_i_1;
   var $324=(($i_i28_0)|(0)) < (($322)|(0));
   if ($324) { label = 46; break; } else { var $cx_i_3 = $cx_i_1;var $cz_i_3 = $cz_i_1;var $ci_i_3 = $ci_i_1;var $dmin_i_3 = $dmin_i_1;label = 47; break; }
  case 46: 
   var $325=HEAP32[(($187)>>2)];
   var $326=(($325+($i_i28_0<<3))|0);
   var $327=HEAP16[(($326)>>1)];
   var $328=(($327)&(65535));
   var $329=((($297)-($328))|0);
   var $330=(($329)|(0)) < 0;
   var $331=(((-$329))|0);
   var $332=$330 ? $331 : $329;
   var $333=(($332)|(0)) < (($dmin_i_1)|(0));
   var $_dmin_i_1=$333 ? $332 : $dmin_i_1;
   var $i_i28_0_ci_i_1=$333 ? $i_i28_0 : $ci_i_1;
   var $_cz_i_1=$333 ? $305 : $cz_i_1;
   var $_cx_i_1=$333 ? $293 : $cx_i_1;
   var $334=((($i_i28_0)+(1))|0);
   var $cx_i_1 = $_cx_i_1;var $cz_i_1 = $_cz_i_1;var $ci_i_1 = $i_i28_0_ci_i_1;var $dmin_i_1 = $_dmin_i_1;var $i_i28_0 = $334;label = 45; break;
  case 47: 
   var $dmin_i_3;
   var $ci_i_3;
   var $cz_i_3;
   var $cx_i_3;
   var $335=((($storemerge6_i31)+(1))|0);
   var $storemerge6_i31 = $335;var $cx_i_0 = $cx_i_3;var $cz_i_0 = $cz_i_3;var $ci_i_0 = $ci_i_3;var $dmin_i_0 = $dmin_i_3;label = 42; break;
  case 48: 
   var $337=(($ci_i_0)|(0))==-1;
   if ($337) { label = 50; break; } else { label = 49; break; }
  case 49: 
   var $339=HEAP32[(($34)>>2)];
   var $340=((($339)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $340);
   var $341=HEAP32[(($34)>>2)];
   var $342=((($341)-(1))|0);
   var $343=HEAP32[(($33)>>2)];
   var $344=(($343+($342<<2))|0);
   HEAP32[(($344)>>2)]=$cx_i_0;
   var $345=((($341)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $345);
   var $346=HEAP32[(($34)>>2)];
   var $347=((($346)-(1))|0);
   var $348=HEAP32[(($33)>>2)];
   var $349=(($348+($347<<2))|0);
   HEAP32[(($349)>>2)]=$cz_i_0;
   var $350=((($346)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $350);
   var $351=HEAP32[(($34)>>2)];
   var $352=((($351)-(1))|0);
   var $353=HEAP32[(($33)>>2)];
   var $354=(($353+($352<<2))|0);
   HEAP32[(($354)>>2)]=$ci_i_0;
   label = 50; break;
  case 50: 
   var $356=((($storemerge_i30)+(1))|0);
   var $storemerge_i30 = $356;label = 40; break;
  case 51: 
   var $pcz_i_0;
   var $pcx_i_0;
   var $storemerge1_i32;
   var $358=(($storemerge1_i32)|(0)) < (($npoly_0)|(0));
   if ($358) { label = 52; break; } else { label = 53; break; }
  case 52: 
   var $_sum1187=((($217)+($storemerge1_i32))|0);
   var $360=(($218+($_sum1187<<1))|0);
   var $361=HEAP16[(($360)>>1)];
   var $362=(($361)&(65535));
   var $363=((($362)*(3))&-1);
   var $364=(($267+($363<<1))|0);
   var $365=HEAP16[(($364)>>1)];
   var $366=(($365)&(65535));
   var $367=((($pcx_i_0)+($366))|0);
   var $368=((($363)+(2))|0);
   var $369=(($267+($368<<1))|0);
   var $370=HEAP16[(($369)>>1)];
   var $371=(($370)&(65535));
   var $372=((($pcz_i_0)+($371))|0);
   var $373=((($storemerge1_i32)+(1))|0);
   var $storemerge1_i32 = $373;var $pcx_i_0 = $367;var $pcz_i_0 = $372;label = 51; break;
  case 53: 
   var $375=((((($pcx_i_0)|(0)))/((($npoly_0)|(0))))&-1);
   var $376=((((($pcz_i_0)|(0)))/((($npoly_0)|(0))))&-1);
   var $_pre=HEAP32[(($34)>>2)];
   var $storemerge2_i33 = 0;label = 54; break;
  case 54: 
   var $storemerge2_i33;
   var $378=(($storemerge2_i33)|(0)) < (($_pre)|(0));
   if ($378) { label = 55; break; } else { var $396 = $_pre;label = 56; break; }
  case 55: 
   var $380=HEAP32[(($33)>>2)];
   var $381=(($380+($storemerge2_i33<<2))|0);
   var $382=HEAP32[(($381)>>2)];
   var $383=((($storemerge2_i33)+(1))|0);
   var $384=(($380+($383<<2))|0);
   var $385=HEAP32[(($384)>>2)];
   var $386=HEAP32[(($40)>>2)];
   var $387=((($382)-($386))|0);
   var $388=HEAP32[(($41)>>2)];
   var $389=((($385)-($388))|0);
   var $390=HEAP32[(($42)>>2)];
   var $391=(Math.imul($389,$390)|0);
   var $392=((($387)+($391))|0);
   var $393=HEAP32[(($39)>>2)];
   var $394=(($393+($392<<1))|0);
   HEAP16[(($394)>>1)]=1;
   var $395=((($storemerge2_i33)+(3))|0);
   var $storemerge2_i33 = $395;label = 54; break;
  case 56: 
   var $396;
   var $397=(($396)|(0)) > 0;
   if ($397) { label = 57; break; } else { var $510 = $396;label = 73; break; }
  case 57: 
   var $398=((($396)-(1))|0);
   HEAP32[(($34)>>2)]=$398;
   var $399=HEAP32[(($33)>>2)];
   var $400=(($399+($398<<2))|0);
   var $401=HEAP32[(($400)>>2)];
   var $402=(($398)|(0)) > 0;
   if ($402) { label = 58; break; } else { var $409 = $398;var $408 = $401;var $407 = $401;label = 60; break; }
  case 58: 
   var $403=((($398)-(1))|0);
   HEAP32[(($34)>>2)]=$403;
   var $_phi_trans_insert=(($399+($403<<2))|0);
   var $_pre1137=HEAP32[(($_phi_trans_insert)>>2)];
   var $404=(($403)|(0)) > 0;
   if ($404) { label = 59; break; } else { var $409 = $403;var $408 = $_pre1137;var $407 = $_pre1137;label = 60; break; }
  case 59: 
   var $406=((($403)-(1))|0);
   HEAP32[(($34)>>2)]=$406;
   var $_phi_trans_insert1138=(($399+($406<<2))|0);
   var $_pre1139=HEAP32[(($_phi_trans_insert1138)>>2)];
   var $409 = $406;var $408 = $_pre1139;var $407 = $_pre1137;label = 60; break;
  case 60: 
   var $407;
   var $408;
   var $409;
   var $410=((($408)-($375))|0);
   var $411=(($410)|(0)) < 0;
   var $412=(((-$410))|0);
   var $413=$411 ? $412 : $410;
   var $414=(($413)|(0)) < 2;
   if ($414) { label = 61; break; } else { var $436 = $407;label = 63; break; }
  case 61: 
   var $415=((($407)-($376))|0);
   var $416=(($415)|(0)) < 0;
   var $417=(((-$415))|0);
   var $_=$416 ? $417 : $415;
   var $418=(($_)|(0)) < 2;
   if ($418) { label = 62; break; } else { var $436 = $407;label = 63; break; }
  case 62: 
   __ZN10rcIntArray6resizeEi($stack, 0);
   var $420=HEAP32[(($34)>>2)];
   var $421=((($420)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $421);
   var $422=HEAP32[(($34)>>2)];
   var $423=((($422)-(1))|0);
   var $424=HEAP32[(($33)>>2)];
   var $425=(($424+($423<<2))|0);
   HEAP32[(($425)>>2)]=$408;
   var $426=((($422)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $426);
   var $427=HEAP32[(($34)>>2)];
   var $428=((($427)-(1))|0);
   var $429=HEAP32[(($33)>>2)];
   var $430=(($429+($428<<2))|0);
   HEAP32[(($430)>>2)]=$407;
   var $431=((($427)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $431);
   var $432=HEAP32[(($34)>>2)];
   var $433=((($432)-(1))|0);
   var $434=HEAP32[(($33)>>2)];
   var $435=(($434+($433<<2))|0);
   HEAP32[(($435)>>2)]=$401;
   var $510 = $432;label = 73; break;
  case 63: 
   var $436;
   var $437=HEAP32[(($187)>>2)];
   var $438=(($437+($401<<3)+4)|0);
   var $439=$438;
   var $storemerge5_i34 = 0;var $441 = $409;label = 64; break;
  case 64: 
   var $441;
   var $storemerge5_i34;
   var $442=(($storemerge5_i34)|(0)) < 4;
   if ($442) { label = 65; break; } else { var $396 = $441;label = 56; break; }
  case 65: 
   var $444=((($storemerge5_i34)*(6))&-1);
   var $445=HEAP32[(($439)>>2)];
   var $446=$445 & 16777215;
   var $447=$446 >>> (($444)>>>(0));
   var $448=$447 & 63;
   var $449=(($448)|(0))==63;
   if ($449) { var $508 = $441;label = 72; break; } else { label = 66; break; }
  case 66: 
   var $451=$storemerge5_i34 & 3;
   var $452=((6640+($451<<2))|0);
   var $453=HEAP32[(($452)>>2)];
   var $454=((($408)+($453))|0);
   var $455=((6624+($451<<2))|0);
   var $456=HEAP32[(($455)>>2)];
   var $457=((($436)+($456))|0);
   var $458=HEAP32[(($40)>>2)];
   var $459=(($454)|(0)) < (($458)|(0));
   if ($459) { var $508 = $441;label = 72; break; } else { label = 67; break; }
  case 67: 
   var $461=HEAP32[(($42)>>2)];
   var $462=((($458)+($461))|0);
   var $463=(($454)|(0)) < (($462)|(0));
   if ($463) { label = 68; break; } else { var $508 = $441;label = 72; break; }
  case 68: 
   var $465=HEAP32[(($41)>>2)];
   var $466=(($457)|(0)) < (($465)|(0));
   if ($466) { var $508 = $441;label = 72; break; } else { label = 69; break; }
  case 69: 
   var $468=HEAP32[(($43)>>2)];
   var $469=((($465)+($468))|0);
   var $470=(($457)|(0)) < (($469)|(0));
   if ($470) { label = 70; break; } else { var $508 = $441;label = 72; break; }
  case 70: 
   var $472=((($454)-($458))|0);
   var $473=((($457)-($465))|0);
   var $474=(Math.imul($473,$461)|0);
   var $475=((($472)+($474))|0);
   var $476=HEAP32[(($39)>>2)];
   var $477=(($476+($475<<1))|0);
   var $478=HEAP16[(($477)>>1)];
   var $479=(($478 << 16) >> 16)==0;
   if ($479) { label = 71; break; } else { var $508 = $441;label = 72; break; }
  case 71: 
   var $481=((($454)+($26))|0);
   var $482=((($457)+($26))|0);
   var $483=HEAP32[(($62)>>2)];
   var $484=(Math.imul($482,$483)|0);
   var $485=((($481)+($484))|0);
   var $486=HEAP32[(($186)>>2)];
   var $487=(($486+($485<<2))|0);
   var $488=$487;
   var $489=HEAP32[(($488)>>2)];
   var $490=$489 & 16777215;
   var $491=((($490)+($448))|0);
   HEAP16[(($477)>>1)]=1;
   var $492=((($441)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $492);
   var $493=HEAP32[(($34)>>2)];
   var $494=((($493)-(1))|0);
   var $495=HEAP32[(($33)>>2)];
   var $496=(($495+($494<<2))|0);
   HEAP32[(($496)>>2)]=$454;
   var $497=((($493)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $497);
   var $498=HEAP32[(($34)>>2)];
   var $499=((($498)-(1))|0);
   var $500=HEAP32[(($33)>>2)];
   var $501=(($500+($499<<2))|0);
   HEAP32[(($501)>>2)]=$457;
   var $502=((($498)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $502);
   var $503=HEAP32[(($34)>>2)];
   var $504=((($503)-(1))|0);
   var $505=HEAP32[(($33)>>2)];
   var $506=(($505+($504<<2))|0);
   HEAP32[(($506)>>2)]=$491;
   var $508 = $503;label = 72; break;
  case 72: 
   var $508;
   var $509=((($storemerge5_i34)+(1))|0);
   var $storemerge5_i34 = $509;var $441 = $508;label = 64; break;
  case 73: 
   var $510;
   var $511=HEAP32[(($39)>>2)];
   var $512=$511;
   var $513=HEAP32[(($42)>>2)];
   var $514=$513 << 1;
   var $515=HEAP32[(($43)>>2)];
   var $516=(Math.imul($514,$515)|0);
   _memset($512, -1, $516);
   var $storemerge3_i35 = 0;label = 74; break;
  case 74: 
   var $storemerge3_i35;
   var $518=(($storemerge3_i35)|(0)) < (($510)|(0));
   if ($518) { label = 75; break; } else { var $head_i_0 = 0;var $541 = $510;label = 77; break; }
  case 75: 
   var $520=HEAP32[(($33)>>2)];
   var $521=(($520+($storemerge3_i35<<2))|0);
   var $522=HEAP32[(($521)>>2)];
   var $523=((($storemerge3_i35)+(1))|0);
   var $524=(($520+($523<<2))|0);
   var $525=HEAP32[(($524)>>2)];
   var $526=((($storemerge3_i35)+(2))|0);
   var $527=(($520+($526<<2))|0);
   var $528=HEAP32[(($527)>>2)];
   var $529=HEAP32[(($40)>>2)];
   var $530=((($522)-($529))|0);
   var $531=HEAP32[(($41)>>2)];
   var $532=((($525)-($531))|0);
   var $533=(Math.imul($532,$513)|0);
   var $534=((($530)+($533))|0);
   var $535=HEAP32[(($187)>>2)];
   var $536=(($535+($528<<3))|0);
   var $537=HEAP16[(($536)>>1)];
   var $538=(($511+($534<<1))|0);
   HEAP16[(($538)>>1)]=$537;
   var $539=((($storemerge3_i35)+(3))|0);
   var $storemerge3_i35 = $539;label = 74; break;
  case 76: 
   var $_pre1140=HEAP32[(($34)>>2)];
   var $head_i_0 = $head_i_1;var $541 = $_pre1140;label = 77; break;
  case 77: 
   var $541;
   var $head_i_0;
   var $542=((($head_i_0)*(3))&-1);
   var $543=(($542)|(0)) < (($541)|(0));
   if ($543) { label = 78; break; } else { var $storemerge_i = 0;label = 92; break; }
  case 78: 
   var $545=HEAP32[(($33)>>2)];
   var $546=(($545+($542<<2))|0);
   var $547=HEAP32[(($546)>>2)];
   var $548=((($542)+(1))|0);
   var $549=(($545+($548<<2))|0);
   var $550=HEAP32[(($549)>>2)];
   var $551=((($542)+(2))|0);
   var $552=(($545+($551<<2))|0);
   var $553=HEAP32[(($552)>>2)];
   var $554=((($head_i_0)+(1))|0);
   var $555=(($554)|(0)) > 255;
   if ($555) { label = 79; break; } else { var $head_i_1 = $554;label = 82; break; }
  case 79: 
   var $557=(($541)|(0)) > 768;
   if ($557) { label = 80; break; } else { label = 81; break; }
  case 80: 
   var $559=$545;
   var $560=(($545+3072)|0);
   var $561=$560;
   var $562=$541 << 2;
   var $563=((($562)-(3072))|0);
   _memmove($559, $561, $563, 4, 0);
   label = 81; break;
  case 81: 
   var $565=((($541)-(768))|0);
   __ZN10rcIntArray6resizeEi($stack, $565);
   var $head_i_1 = 0;label = 82; break;
  case 82: 
   var $head_i_1;
   var $566=HEAP32[(($187)>>2)];
   var $567=(($566+($553<<3)+4)|0);
   var $568=$567;
   var $storemerge4_i36 = 0;label = 83; break;
  case 83: 
   var $storemerge4_i36;
   var $570=(($storemerge4_i36)|(0)) < 4;
   if ($570) { label = 84; break; } else { label = 76; break; }
  case 84: 
   var $572=((($storemerge4_i36)*(6))&-1);
   var $573=HEAP32[(($568)>>2)];
   var $574=$573 & 16777215;
   var $575=$574 >>> (($572)>>>(0));
   var $576=$575 & 63;
   var $577=(($576)|(0))==63;
   if ($577) { label = 91; break; } else { label = 85; break; }
  case 85: 
   var $579=$storemerge4_i36 & 3;
   var $580=((6640+($579<<2))|0);
   var $581=HEAP32[(($580)>>2)];
   var $582=((($547)+($581))|0);
   var $583=((6624+($579<<2))|0);
   var $584=HEAP32[(($583)>>2)];
   var $585=((($550)+($584))|0);
   var $586=HEAP32[(($40)>>2)];
   var $587=(($582)|(0)) < (($586)|(0));
   if ($587) { label = 91; break; } else { label = 86; break; }
  case 86: 
   var $589=((($586)+($513))|0);
   var $590=(($582)|(0)) < (($589)|(0));
   if ($590) { label = 87; break; } else { label = 91; break; }
  case 87: 
   var $592=HEAP32[(($41)>>2)];
   var $593=(($585)|(0)) < (($592)|(0));
   if ($593) { label = 91; break; } else { label = 88; break; }
  case 88: 
   var $595=((($592)+($515))|0);
   var $596=(($585)|(0)) < (($595)|(0));
   if ($596) { label = 89; break; } else { label = 91; break; }
  case 89: 
   var $598=((($582)-($586))|0);
   var $599=((($585)-($592))|0);
   var $600=(Math.imul($599,$513)|0);
   var $601=((($598)+($600))|0);
   var $602=(($511+($601<<1))|0);
   var $603=HEAP16[(($602)>>1)];
   var $604=(($603 << 16) >> 16)==-1;
   if ($604) { label = 90; break; } else { label = 91; break; }
  case 90: 
   var $606=((($582)+($26))|0);
   var $607=((($585)+($26))|0);
   var $608=HEAP32[(($62)>>2)];
   var $609=(Math.imul($607,$608)|0);
   var $610=((($606)+($609))|0);
   var $611=HEAP32[(($186)>>2)];
   var $612=(($611+($610<<2))|0);
   var $613=$612;
   var $614=HEAP32[(($613)>>2)];
   var $615=$614 & 16777215;
   var $616=((($615)+($576))|0);
   var $617=HEAP32[(($187)>>2)];
   var $618=(($617+($616<<3))|0);
   var $619=HEAP16[(($618)>>1)];
   HEAP16[(($602)>>1)]=$619;
   var $620=HEAP32[(($34)>>2)];
   var $621=((($620)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $621);
   var $622=HEAP32[(($34)>>2)];
   var $623=((($622)-(1))|0);
   var $624=HEAP32[(($33)>>2)];
   var $625=(($624+($623<<2))|0);
   HEAP32[(($625)>>2)]=$582;
   var $626=((($622)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $626);
   var $627=HEAP32[(($34)>>2)];
   var $628=((($627)-(1))|0);
   var $629=HEAP32[(($33)>>2)];
   var $630=(($629+($628<<2))|0);
   HEAP32[(($630)>>2)]=$585;
   var $631=((($627)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $631);
   var $632=HEAP32[(($34)>>2)];
   var $633=((($632)-(1))|0);
   var $634=HEAP32[(($33)>>2)];
   var $635=(($634+($633<<2))|0);
   HEAP32[(($635)>>2)]=$616;
   label = 91; break;
  case 91: 
   var $637=((($storemerge4_i36)+(1))|0);
   var $storemerge4_i36 = $637;label = 83; break;
  case 92: 
   var $storemerge_i;
   var $639=(($storemerge_i)|(0)) < (($npoly_0)|(0));
   if ($639) { label = 93; break; } else { label = 94; break; }
  case 93: 
   var $641=((($storemerge_i)*(3))&-1);
   var $642=(($verts+($641<<2))|0);
   var $643=(($59+($641<<2))|0);
   var $644=HEAPF32[(($643)>>2)];
   HEAPF32[(($642)>>2)]=$644;
   var $_sum1183=((($641)+(1))|0);
   var $645=(($59+($_sum1183<<2))|0);
   var $646=HEAPF32[(($645)>>2)];
   var $_sum1184=((($641)+(1))|0);
   var $647=(($verts+($_sum1184<<2))|0);
   HEAPF32[(($647)>>2)]=$646;
   var $_sum1185=((($641)+(2))|0);
   var $648=(($59+($_sum1185<<2))|0);
   var $649=HEAPF32[(($648)>>2)];
   var $_sum1186=((($641)+(2))|0);
   var $650=(($verts+($_sum1186<<2))|0);
   HEAPF32[(($650)>>2)]=$649;
   var $651=((($storemerge_i)+(1))|0);
   var $storemerge_i = $651;label = 92; break;
  case 94: 
   var $653=HEAPF32[(($193)>>2)];
   var $654=(1)/($653);
   if ($194) { label = 95; break; } else { var $nhull_i_4 = 0;var $nverts_4 = $npoly_0;label = 128; break; }
  case 95: 
   var $656=((($npoly_0)-(1))|0);
   var $storemerge7_i = $656;var $nhull_i_0 = 0;var $i1_i_0 = 0;var $nverts_0 = $npoly_0;label = 96; break;
  case 96: 
   var $nverts_0;
   var $i1_i_0;
   var $nhull_i_0;
   var $storemerge7_i;
   var $658=(($i1_i_0)|(0)) < (($npoly_0)|(0));
   if ($658) { label = 97; break; } else { var $nhull_i_4 = $nhull_i_0;var $nverts_4 = $nverts_0;label = 128; break; }
  case 97: 
   var $660=((($storemerge7_i)*(3))&-1);
   var $661=(($59+($660<<2))|0);
   var $662=((($i1_i_0)*(3))&-1);
   var $663=(($59+($662<<2))|0);
   var $664=HEAPF32[(($661)>>2)];
   var $665=HEAPF32[(($663)>>2)];
   var $666=($664)-($665);
   var $667=Math.abs($666);
   var $668=$667 < 9.999999974752427e-7;
   if ($668) { label = 98; break; } else { label = 100; break; }
  case 98: 
   var $_sum1181=((($660)+(2))|0);
   var $670=(($59+($_sum1181<<2))|0);
   var $671=HEAPF32[(($670)>>2)];
   var $_sum1182=((($662)+(2))|0);
   var $672=(($59+($_sum1182<<2))|0);
   var $673=HEAPF32[(($672)>>2)];
   var $674=$671 > $673;
   if ($674) { label = 99; break; } else { var $vj_i_0 = $661;var $vi_i_0 = $663;var $swapped_i_0 = 0;label = 102; break; }
  case 99: 
   var $vj_i_0 = $663;var $vi_i_0 = $661;var $swapped_i_0 = 1;label = 102; break;
  case 100: 
   var $677=$664 > $665;
   if ($677) { label = 101; break; } else { var $vj_i_0 = $661;var $vi_i_0 = $663;var $swapped_i_0 = 0;label = 102; break; }
  case 101: 
   var $vj_i_0 = $663;var $vi_i_0 = $661;var $swapped_i_0 = 1;label = 102; break;
  case 102: 
   var $swapped_i_0;
   var $vi_i_0;
   var $vj_i_0;
   var $679=HEAPF32[(($vi_i_0)>>2)];
   var $680=HEAPF32[(($vj_i_0)>>2)];
   var $681=($679)-($680);
   var $682=(($vi_i_0+4)|0);
   var $683=HEAPF32[(($682)>>2)];
   var $684=(($vj_i_0+4)|0);
   var $685=HEAPF32[(($684)>>2)];
   var $686=($683)-($685);
   var $687=(($vi_i_0+8)|0);
   var $688=HEAPF32[(($687)>>2)];
   var $689=(($vj_i_0+8)|0);
   var $690=HEAPF32[(($689)>>2)];
   var $691=($688)-($690);
   var $692=($681)*($681);
   var $693=($691)*($691);
   var $694=($692)+($693);
   var $695=Math.sqrt($694);
   var $696=($695)/($sampleDist);
   var $697=Math.floor($696);
   var $698=(($697)&-1);
   var $699=((($698)+(1))|0);
   var $700=(($699)|(0)) > 31;
   var $_1209=$700 ? 31 : $699;
   var $701=((($nverts_0)+($_1209))|0);
   var $702=(($701)|(0)) > 126;
   var $703=(((126)-($nverts_0))|0);
   var $nn_i_0_ph=$702 ? $703 : $_1209;
   var $704=(($nn_i_0_ph)|(0));
   var $storemerge8_i = 0;label = 103; break;
  case 103: 
   var $storemerge8_i;
   var $706=(($storemerge8_i)|(0)) > (($nn_i_0_ph)|(0));
   if ($706) { label = 105; break; } else { label = 104; break; }
  case 104: 
   var $708=(($storemerge8_i)|(0));
   var $709=($708)/($704);
   var $710=((($storemerge8_i)*(3))&-1);
   var $711=(($edge_i+($710<<2))|0);
   var $712=($681)*($709);
   var $713=($680)+($712);
   HEAPF32[(($711)>>2)]=$713;
   var $714=($686)*($709);
   var $715=($685)+($714);
   var $_sum1165=((($710)+(1))|0);
   var $716=(($edge_i+($_sum1165<<2))|0);
   var $717=($691)*($709);
   var $718=($690)+($717);
   var $_sum1166=((($710)+(2))|0);
   var $719=(($edge_i+($_sum1166<<2))|0);
   HEAPF32[(($719)>>2)]=$718;
   var $720=HEAPF32[(($195)>>2)];
   var $721=__ZL9getHeightffffffRK13rcHeightPatch($713, $715, $718, $653, $654, $720, $hp);
   var $722=(($721)&(65535));
   var $723=(($722)|(0));
   var $724=($723)*($720);
   HEAPF32[(($716)>>2)]=$724;
   var $725=((($storemerge8_i)+(1))|0);
   var $storemerge8_i = $725;label = 103; break;
  case 105: 
   _memset($191, 0, 128);
   HEAP32[(($196)>>2)]=$nn_i_0_ph;
   var $nidx_i_0_ph = 2;var $k2_i_0_ph = 0;label = 106; break;
  case 106: 
   var $k2_i_0_ph;
   var $nidx_i_0_ph;
   var $727=(($idx_i+($k2_i_0_ph<<2))|0);
   var $728=((($k2_i_0_ph)+(1))|0);
   var $729=(($idx_i+($728<<2))|0);
   var $nidx_i_0 = $nidx_i_0_ph;label = 107; break;
  case 107: 
   var $nidx_i_0;
   var $731=((($nidx_i_0)-(1))|0);
   var $732=(($k2_i_0_ph)|(0)) < (($731)|(0));
   if ($732) { label = 108; break; } else { label = 121; break; }
  case 108: 
   var $734=HEAP32[(($727)>>2)];
   var $735=HEAP32[(($729)>>2)];
   var $736=((($734)*(3))&-1);
   var $737=(($edge_i+($736<<2))|0);
   var $738=((($735)*(3))&-1);
   var $739=(($edge_i+($738<<2))|0);
   var $_sum1175=((($738)+(1))|0);
   var $740=(($edge_i+($_sum1175<<2))|0);
   var $_sum1176=((($736)+(1))|0);
   var $741=(($edge_i+($_sum1176<<2))|0);
   var $_sum1177=((($738)+(2))|0);
   var $742=(($edge_i+($_sum1177<<2))|0);
   var $_sum1178=((($736)+(2))|0);
   var $743=(($edge_i+($_sum1178<<2))|0);
   var $storemerge11_in_i_in_sroa_speculated_ph = $734;var $maxd_i_0_ph = 0;var $maxi_i_0_ph = -1;label = 109; break;
  case 109: 
   var $maxi_i_0_ph;
   var $maxd_i_0_ph;
   var $storemerge11_in_i_in_sroa_speculated_ph;
   var $storemerge11_in_i_in_sroa_speculated = $storemerge11_in_i_in_sroa_speculated_ph;label = 110; break;
  case 110: 
   var $storemerge11_in_i_in_sroa_speculated;
   var $storemerge11_i=((($storemerge11_in_i_in_sroa_speculated)+(1))|0);
   var $745=(($storemerge11_i)|(0)) < (($735)|(0));
   if ($745) { label = 111; break; } else { label = 117; break; }
  case 111: 
   var $747=((($storemerge11_i)*(3))&-1);
   var $748=(($edge_i+($747<<2))|0);
   var $749=HEAPF32[(($739)>>2)];
   var $750=HEAPF32[(($737)>>2)];
   var $751=($749)-($750);
   var $752=HEAPF32[(($740)>>2)];
   var $753=HEAPF32[(($741)>>2)];
   var $754=($752)-($753);
   var $755=HEAPF32[(($742)>>2)];
   var $756=HEAPF32[(($743)>>2)];
   var $757=($755)-($756);
   var $758=HEAPF32[(($748)>>2)];
   var $759=($758)-($750);
   var $_sum1179=((($747)+(1))|0);
   var $760=(($edge_i+($_sum1179<<2))|0);
   var $761=HEAPF32[(($760)>>2)];
   var $762=($761)-($753);
   var $_sum1180=((($747)+(2))|0);
   var $763=(($edge_i+($_sum1180<<2))|0);
   var $764=HEAPF32[(($763)>>2)];
   var $765=($764)-($756);
   var $766=($751)*($751);
   var $767=($754)*($754);
   var $768=($766)+($767);
   var $769=($757)*($757);
   var $770=($768)+($769);
   var $771=($751)*($759);
   var $772=($754)*($762);
   var $773=($771)+($772);
   var $774=($757)*($765);
   var $775=($773)+($774);
   var $776=$770 > 0;
   if ($776) { label = 112; break; } else { var $t_i15_i_0 = $775;label = 113; break; }
  case 112: 
   var $778=($775)/($770);
   var $t_i15_i_0 = $778;label = 113; break;
  case 113: 
   var $t_i15_i_0;
   var $780=$t_i15_i_0 < 0;
   if ($780) { var $t_i15_i_1 = 0;label = 116; break; } else { label = 114; break; }
  case 114: 
   var $782=$t_i15_i_0 > 1;
   if ($782) { label = 115; break; } else { var $t_i15_i_1 = $t_i15_i_0;label = 116; break; }
  case 115: 
   var $t_i15_i_1 = 1;label = 116; break;
  case 116: 
   var $t_i15_i_1;
   var $784=($t_i15_i_1)*($751);
   var $785=($750)+($784);
   var $786=($785)-($758);
   var $787=($t_i15_i_1)*($754);
   var $788=($753)+($787);
   var $789=($788)-($761);
   var $790=($t_i15_i_1)*($757);
   var $791=($756)+($790);
   var $792=($791)-($764);
   var $793=($786)*($786);
   var $794=($789)*($789);
   var $795=($793)+($794);
   var $796=($792)*($792);
   var $797=($795)+($796);
   var $798=$797 > $maxd_i_0_ph;
   if ($798) { var $storemerge11_in_i_in_sroa_speculated_ph = $storemerge11_i;var $maxd_i_0_ph = $797;var $maxi_i_0_ph = $storemerge11_i;label = 109; break; } else { var $storemerge11_in_i_in_sroa_speculated = $storemerge11_i;label = 110; break; }
  case 117: 
   var $800=(($maxi_i_0_ph)|(0))!=-1;
   var $801=$maxd_i_0_ph > $197;
   var $or_cond1210=$800 & $801;
   if ($or_cond1210) { var $storemerge12_i = $nidx_i_0;label = 118; break; } else { var $nidx_i_0_ph = $nidx_i_0;var $k2_i_0_ph = $728;label = 106; break; }
  case 118: 
   var $storemerge12_i;
   var $803=(($storemerge12_i)|(0)) > (($k2_i_0_ph)|(0));
   if ($803) { label = 119; break; } else { label = 120; break; }
  case 119: 
   var $805=((($storemerge12_i)-(1))|0);
   var $806=(($idx_i+($805<<2))|0);
   var $807=HEAP32[(($806)>>2)];
   var $808=(($idx_i+($storemerge12_i<<2))|0);
   HEAP32[(($808)>>2)]=$807;
   var $storemerge12_i = $805;label = 118; break;
  case 120: 
   HEAP32[(($729)>>2)]=$maxi_i_0_ph;
   var $810=((($nidx_i_0)+(1))|0);
   var $nidx_i_0 = $810;label = 107; break;
  case 121: 
   var $812=((($nhull_i_0)+(1))|0);
   var $813=(($hull_i+($nhull_i_0<<2))|0);
   HEAP32[(($813)>>2)]=$storemerge7_i;
   var $814=(($swapped_i_0 << 24) >> 24)==0;
   if ($814) { var $storemerge9_i = 1;var $nhull_i_2 = $812;var $nverts_2 = $nverts_0;label = 125; break; } else { label = 122; break; }
  case 122: 
   var $816=((($nidx_i_0)-(2))|0);
   var $storemerge10_i = $816;var $nhull_i_1 = $812;var $nverts_1 = $nverts_0;label = 123; break;
  case 123: 
   var $nverts_1;
   var $nhull_i_1;
   var $storemerge10_i;
   var $818=(($storemerge10_i)|(0)) > 0;
   if ($818) { label = 124; break; } else { var $nhull_i_3 = $nhull_i_1;var $nverts_3 = $nverts_1;label = 127; break; }
  case 124: 
   var $820=((($nverts_1)*(3))&-1);
   var $821=(($verts+($820<<2))|0);
   var $822=(($idx_i+($storemerge10_i<<2))|0);
   var $823=HEAP32[(($822)>>2)];
   var $824=((($823)*(3))&-1);
   var $825=(($edge_i+($824<<2))|0);
   var $826=HEAPF32[(($825)>>2)];
   HEAPF32[(($821)>>2)]=$826;
   var $_sum1167=((($824)+(1))|0);
   var $827=(($edge_i+($_sum1167<<2))|0);
   var $828=HEAPF32[(($827)>>2)];
   var $_sum1168=((($820)+(1))|0);
   var $829=(($verts+($_sum1168<<2))|0);
   HEAPF32[(($829)>>2)]=$828;
   var $_sum1169=((($824)+(2))|0);
   var $830=(($edge_i+($_sum1169<<2))|0);
   var $831=HEAPF32[(($830)>>2)];
   var $_sum1170=((($820)+(2))|0);
   var $832=(($verts+($_sum1170<<2))|0);
   HEAPF32[(($832)>>2)]=$831;
   var $833=((($nhull_i_1)+(1))|0);
   var $834=(($hull_i+($nhull_i_1<<2))|0);
   HEAP32[(($834)>>2)]=$nverts_1;
   var $835=((($nverts_1)+(1))|0);
   var $836=((($storemerge10_i)-(1))|0);
   var $storemerge10_i = $836;var $nhull_i_1 = $833;var $nverts_1 = $835;label = 123; break;
  case 125: 
   var $nverts_2;
   var $nhull_i_2;
   var $storemerge9_i;
   var $837=(($storemerge9_i)|(0)) < (($731)|(0));
   if ($837) { label = 126; break; } else { var $nhull_i_3 = $nhull_i_2;var $nverts_3 = $nverts_2;label = 127; break; }
  case 126: 
   var $839=((($nverts_2)*(3))&-1);
   var $840=(($verts+($839<<2))|0);
   var $841=(($idx_i+($storemerge9_i<<2))|0);
   var $842=HEAP32[(($841)>>2)];
   var $843=((($842)*(3))&-1);
   var $844=(($edge_i+($843<<2))|0);
   var $845=HEAPF32[(($844)>>2)];
   HEAPF32[(($840)>>2)]=$845;
   var $_sum1171=((($843)+(1))|0);
   var $846=(($edge_i+($_sum1171<<2))|0);
   var $847=HEAPF32[(($846)>>2)];
   var $_sum1172=((($839)+(1))|0);
   var $848=(($verts+($_sum1172<<2))|0);
   HEAPF32[(($848)>>2)]=$847;
   var $_sum1173=((($843)+(2))|0);
   var $849=(($edge_i+($_sum1173<<2))|0);
   var $850=HEAPF32[(($849)>>2)];
   var $_sum1174=((($839)+(2))|0);
   var $851=(($verts+($_sum1174<<2))|0);
   HEAPF32[(($851)>>2)]=$850;
   var $852=((($nhull_i_2)+(1))|0);
   var $853=(($hull_i+($nhull_i_2<<2))|0);
   HEAP32[(($853)>>2)]=$nverts_2;
   var $854=((($nverts_2)+(1))|0);
   var $855=((($storemerge9_i)+(1))|0);
   var $storemerge9_i = $855;var $nhull_i_2 = $852;var $nverts_2 = $854;label = 125; break;
  case 127: 
   var $nverts_3;
   var $nhull_i_3;
   var $856=((($i1_i_0)+(1))|0);
   var $storemerge7_i = $i1_i_0;var $nhull_i_0 = $nhull_i_3;var $i1_i_0 = $856;var $nverts_0 = $nverts_3;label = 96; break;
  case 128: 
   var $nverts_4;
   var $nhull_i_4;
   __ZN10rcIntArray6resizeEi($edges, 0);
   __ZN10rcIntArray6resizeEi($tris, 0);
   (function() { try { __THREW__ = 0; return __ZL12delaunayHullP9rcContextiPKfiPKiR10rcIntArrayS6_($ctx, $nverts_4, $188, $nhull_i_4, $198, $tris, $edges) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 129; break; } else { label = 13; break; }
  case 129: 
   var $857=HEAP32[(($31)>>2)];
   var $858=(($857)|(0))==0;
   if ($858) { label = 130; break; } else { label = 133; break; }
  case 130: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((128)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $storemerge6_i = 2;var $860 = 0;label = 131; break; } else { label = 13; break; }
  case 131: 
   var $860;
   var $storemerge6_i;
   var $861=(($storemerge6_i)|(0)) < (($nverts_4)|(0));
   if ($861) { label = 132; break; } else { var $nverts_7 = $nverts_4;label = 172; break; }
  case 132: 
   var $863=((($860)+(1))|0);
   __ZN10rcIntArray6resizeEi($tris, $863);
   var $864=HEAP32[(($31)>>2)];
   var $865=((($864)-(1))|0);
   var $866=HEAP32[(($30)>>2)];
   var $867=(($866+($865<<2))|0);
   HEAP32[(($867)>>2)]=0;
   var $868=((($storemerge6_i)-(1))|0);
   var $869=((($864)+(1))|0);
   __ZN10rcIntArray6resizeEi($tris, $869);
   var $870=HEAP32[(($31)>>2)];
   var $871=((($870)-(1))|0);
   var $872=HEAP32[(($30)>>2)];
   var $873=(($872+($871<<2))|0);
   HEAP32[(($873)>>2)]=$868;
   var $874=((($870)+(1))|0);
   __ZN10rcIntArray6resizeEi($tris, $874);
   var $875=HEAP32[(($31)>>2)];
   var $876=((($875)-(1))|0);
   var $877=HEAP32[(($30)>>2)];
   var $878=(($877+($876<<2))|0);
   HEAP32[(($878)>>2)]=$storemerge6_i;
   var $879=((($875)+(1))|0);
   __ZN10rcIntArray6resizeEi($tris, $879);
   var $880=HEAP32[(($31)>>2)];
   var $881=((($880)-(1))|0);
   var $882=HEAP32[(($30)>>2)];
   var $883=(($882+($881<<2))|0);
   HEAP32[(($883)>>2)]=0;
   var $884=((($storemerge6_i)+(1))|0);
   var $storemerge6_i = $884;var $860 = $880;label = 131; break;
  case 133: 
   if ($194) { label = 134; break; } else { var $nverts_6 = $nverts_4;var $1156 = $857;label = 170; break; }
  case 134: 
   var $887=HEAPF32[(($59)>>2)];
   var $888=HEAPF32[(($202)>>2)];
   var $889=HEAPF32[(($204)>>2)];
   var $storemerge1_i = 1;var $bmax_i_sroa_0_0 = $887;var $bmax_i_sroa_1_0 = $888;var $bmax_i_sroa_2_0 = $889;var $bmin_i_sroa_0_0 = $887;var $bmin_i_sroa_1_0 = $888;var $bmin_i_sroa_2_0 = $889;label = 135; break;
  case 135: 
   var $bmin_i_sroa_2_0;
   var $bmin_i_sroa_1_0;
   var $bmin_i_sroa_0_0;
   var $bmax_i_sroa_2_0;
   var $bmax_i_sroa_1_0;
   var $bmax_i_sroa_0_0;
   var $storemerge1_i;
   var $891=(($storemerge1_i)|(0)) < (($npoly_0)|(0));
   if ($891) { label = 136; break; } else { label = 137; break; }
  case 136: 
   var $893=((($storemerge1_i)*(3))&-1);
   var $894=(($59+($893<<2))|0);
   var $895=HEAPF32[(($894)>>2)];
   var $896=$bmin_i_sroa_0_0 < $895;
   var $897=$896 ? $bmin_i_sroa_0_0 : $895;
   var $_sum1163=((($893)+(1))|0);
   var $898=(($59+($_sum1163<<2))|0);
   var $899=HEAPF32[(($898)>>2)];
   var $900=$bmin_i_sroa_1_0 < $899;
   var $901=$900 ? $bmin_i_sroa_1_0 : $899;
   var $_sum1164=((($893)+(2))|0);
   var $902=(($59+($_sum1164<<2))|0);
   var $903=HEAPF32[(($902)>>2)];
   var $904=$bmin_i_sroa_2_0 < $903;
   var $905=$904 ? $bmin_i_sroa_2_0 : $903;
   var $906=$bmax_i_sroa_0_0 > $895;
   var $907=$906 ? $bmax_i_sroa_0_0 : $895;
   var $908=$bmax_i_sroa_1_0 > $899;
   var $909=$908 ? $bmax_i_sroa_1_0 : $899;
   var $910=$bmax_i_sroa_2_0 > $903;
   var $911=$910 ? $bmax_i_sroa_2_0 : $903;
   var $912=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $912;var $bmax_i_sroa_0_0 = $907;var $bmax_i_sroa_1_0 = $909;var $bmax_i_sroa_2_0 = $911;var $bmin_i_sroa_0_0 = $897;var $bmin_i_sroa_1_0 = $901;var $bmin_i_sroa_2_0 = $905;label = 135; break;
  case 137: 
   var $914=($bmin_i_sroa_0_0)/($sampleDist);
   var $915=Math.floor($914);
   var $916=(($915)&-1);
   var $917=($bmax_i_sroa_0_0)/($sampleDist);
   var $918=Math.ceil($917);
   var $919=(($918)&-1);
   var $920=($bmin_i_sroa_2_0)/($sampleDist);
   var $921=Math.floor($920);
   var $922=(($921)&-1);
   var $923=($bmax_i_sroa_2_0)/($sampleDist);
   var $924=Math.ceil($923);
   var $925=(($924)&-1);
   __ZN10rcIntArray6resizeEi($samples, 0);
   var $926=($bmax_i_sroa_1_0)+($bmin_i_sroa_1_0);
   var $927=($926)*(0.5);
   var $928=((($npoly_0)-(1))|0);
   var $storemerge2_i = $922;label = 138; break;
  case 138: 
   var $storemerge2_i;
   var $930=(($storemerge2_i)|(0)) < (($925)|(0));
   if ($930) { label = 139; break; } else { label = 154; break; }
  case 139: 
   var $932=(($storemerge2_i)|(0));
   var $933=($932)*($sampleDist);
   var $storemerge5_i = $916;label = 140; break;
  case 140: 
   var $storemerge5_i;
   var $935=(($storemerge5_i)|(0)) < (($919)|(0));
   if ($935) { label = 141; break; } else { label = 153; break; }
  case 141: 
   var $937=(($storemerge5_i)|(0));
   var $938=($937)*($sampleDist);
   HEAPF32[(($205)>>2)]=$938;
   HEAPF32[(($206)>>2)]=$927;
   HEAPF32[(($207)>>2)]=$933;
   var $storemerge_i19_i = $928;var $dmin_i17_i_0 = 3.4028234663852886e+38;var $i_i18_i_0 = 0;var $c_i_i_0 = 0;label = 142; break;
  case 142: 
   var $c_i_i_0;
   var $i_i18_i_0;
   var $dmin_i17_i_0;
   var $storemerge_i19_i;
   var $940=(($i_i18_i_0)|(0)) < (($npoly_0)|(0));
   if ($940) { label = 143; break; } else { label = 148; break; }
  case 143: 
   var $942=((($i_i18_i_0)*(3))&-1);
   var $943=(($59+($942<<2))|0);
   var $944=((($storemerge_i19_i)*(3))&-1);
   var $945=(($59+($944<<2))|0);
   var $_sum_i_i=((($942)+(2))|0);
   var $946=(($59+($_sum_i_i<<2))|0);
   var $947=HEAPF32[(($946)>>2)];
   var $948=$947 > $933;
   var $_sum1162=((($944)+(2))|0);
   var $949=(($59+($_sum1162<<2))|0);
   var $950=HEAPF32[(($949)>>2)];
   var $951=$950 > $933;
   var $952=$948 ^ $951;
   if ($952) { label = 145; break; } else { label = 144; break; }
  case 144: 
   var $_val_pre=HEAPF32[(($943)>>2)];
   var $c_i_i_1 = $c_i_i_0;var $_val = $_val_pre;label = 147; break;
  case 145: 
   var $954=HEAPF32[(($945)>>2)];
   var $955=HEAPF32[(($943)>>2)];
   var $956=($954)-($955);
   var $957=($933)-($947);
   var $958=($956)*($957);
   var $959=($950)-($947);
   var $960=($958)/($959);
   var $961=($960)+($955);
   var $962=$938 < $961;
   if ($962) { label = 146; break; } else { var $c_i_i_1 = $c_i_i_0;var $_val = $955;label = 147; break; }
  case 146: 
   var $964=(($c_i_i_0)|(0))==0;
   var $965=(($964)&(1));
   var $c_i_i_1 = $965;var $_val = $955;label = 147; break;
  case 147: 
   var $_val;
   var $c_i_i_1;
   var $967=__ZL15distancePtSeg2dPKfS0_S0_($205, $945, $_val, $947);
   var $968=$dmin_i17_i_0 < $967;
   var $969=$968 ? $dmin_i17_i_0 : $967;
   var $970=((($i_i18_i_0)+(1))|0);
   var $storemerge_i19_i = $i_i18_i_0;var $dmin_i17_i_0 = $969;var $i_i18_i_0 = $970;var $c_i_i_0 = $c_i_i_1;label = 142; break;
  case 148: 
   var $972=(($c_i_i_0)|(0))==0;
   if ($972) { var $975 = $dmin_i17_i_0;label = 150; break; } else { label = 149; break; }
  case 149: 
   var $974=(-$dmin_i17_i_0);
   var $975 = $974;label = 150; break;
  case 150: 
   var $975;
   var $976=$975 > $208;
   if ($976) { label = 152; break; } else { label = 151; break; }
  case 151: 
   var $978=HEAP32[(($37)>>2)];
   var $979=((($978)+(1))|0);
   __ZN10rcIntArray6resizeEi($samples, $979);
   var $980=HEAP32[(($37)>>2)];
   var $981=((($980)-(1))|0);
   var $982=HEAP32[(($36)>>2)];
   var $983=(($982+($981<<2))|0);
   HEAP32[(($983)>>2)]=$storemerge5_i;
   var $984=HEAPF32[(($195)>>2)];
   var $985=__ZL9getHeightffffffRK13rcHeightPatch($938, $927, $933, $653, $654, $984, $hp);
   var $986=(($985)&(65535));
   var $987=((($980)+(1))|0);
   __ZN10rcIntArray6resizeEi($samples, $987);
   var $988=HEAP32[(($37)>>2)];
   var $989=((($988)-(1))|0);
   var $990=HEAP32[(($36)>>2)];
   var $991=(($990+($989<<2))|0);
   HEAP32[(($991)>>2)]=$986;
   var $992=((($988)+(1))|0);
   __ZN10rcIntArray6resizeEi($samples, $992);
   var $993=HEAP32[(($37)>>2)];
   var $994=((($993)-(1))|0);
   var $995=HEAP32[(($36)>>2)];
   var $996=(($995+($994<<2))|0);
   HEAP32[(($996)>>2)]=$storemerge2_i;
   var $997=((($993)+(1))|0);
   __ZN10rcIntArray6resizeEi($samples, $997);
   var $998=HEAP32[(($37)>>2)];
   var $999=((($998)-(1))|0);
   var $1000=HEAP32[(($36)>>2)];
   var $1001=(($1000+($999<<2))|0);
   HEAP32[(($1001)>>2)]=0;
   label = 152; break;
  case 152: 
   var $1003=((($storemerge5_i)+(1))|0);
   var $storemerge5_i = $1003;label = 140; break;
  case 153: 
   var $1005=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $1005;label = 138; break;
  case 154: 
   var $1007=HEAP32[(($37)>>2)];
   var $1008=((((($1007)|(0)))/(4))&-1);
   var $storemerge3_i = 0;var $nverts_5 = $nverts_4;label = 155; break;
  case 155: 
   var $nverts_5;
   var $storemerge3_i;
   var $1010=(($storemerge3_i)|(0)) >= (($1008)|(0));
   var $1011=(($nverts_5)|(0)) > 126;
   var $or_cond1211=$1010 | $1011;
   if ($or_cond1211) { label = 169; break; } else { label = 156; break; }
  case 156: 
   var $1013=HEAP32[(($36)>>2)];
   var $1014=HEAP32[(($30)>>2)];
   var $1015=HEAP32[(($31)>>2)];
   var $1016=((((($1015)|(0)))/(4))&-1);
   var $storemerge4_i = 0;var $bestd_i_0 = 0;var $besti_i_0 = -1;var $bestpt_i_sroa_2_0 = 0;var $bestpt_i_sroa_1_0 = 0;var $bestpt_i_sroa_0_0 = 0;label = 157; break;
  case 157: 
   var $bestpt_i_sroa_0_0;
   var $bestpt_i_sroa_1_0;
   var $bestpt_i_sroa_2_0;
   var $besti_i_0;
   var $bestd_i_0;
   var $storemerge4_i;
   var $1018=(($storemerge4_i)|(0)) < (($1008)|(0));
   if ($1018) { label = 158; break; } else { label = 166; break; }
  case 158: 
   var $1020=$storemerge4_i << 2;
   var $_sum37=$1020 | 3;
   var $1021=(($1013+($_sum37<<2))|0);
   var $1022=HEAP32[(($1021)>>2)];
   var $1023=(($1022)|(0))==0;
   if ($1023) { label = 159; break; } else { var $bestd_i_1 = $bestd_i_0;var $besti_i_1 = $besti_i_0;var $bestpt_i_sroa_2_1 = $bestpt_i_sroa_2_0;var $bestpt_i_sroa_1_1 = $bestpt_i_sroa_1_0;var $bestpt_i_sroa_0_1 = $bestpt_i_sroa_0_0;label = 165; break; }
  case 159: 
   var $1025=(($1013+($1020<<2))|0);
   var $1026=HEAP32[(($1025)>>2)];
   var $1027=(($1026)|(0));
   var $1028=($1027)*($sampleDist);
   var $1029=(Math.imul($storemerge4_i,-1918454973)|0);
   var $1030=$1029 & 65535;
   var $1031=(($1030)>>>(0));
   var $1032=($1031)/(65535);
   var $1033=($1032)*(2);
   var $1034=($1033)-(1);
   var $1035=($1034)*($653);
   var $1036=($1035)*(0.10000000149011612);
   var $1037=($1028)+($1036);
   var $_sum11521153=$1020 | 1;
   var $1038=(($1013+($_sum11521153<<2))|0);
   var $1039=HEAP32[(($1038)>>2)];
   var $1040=(($1039)|(0));
   var $1041=HEAPF32[(($195)>>2)];
   var $1042=($1040)*($1041);
   var $_sum11541155=$1020 | 2;
   var $1043=(($1013+($_sum11541155<<2))|0);
   var $1044=HEAP32[(($1043)>>2)];
   var $1045=(($1044)|(0));
   var $1046=($1045)*($sampleDist);
   var $1047=(Math.imul($storemerge4_i,-669632447)|0);
   var $1048=$1047 & 65535;
   var $1049=(($1048)>>>(0));
   var $1050=($1049)/(65535);
   var $1051=($1050)*(2);
   var $1052=($1051)-(1);
   var $1053=($1052)*($653);
   var $1054=($1053)*(0.10000000149011612);
   var $1055=($1046)+($1054);
   var $storemerge_i_i = 0;var $dmin_i_i_0 = 3.4028234663852886e+38;label = 160; break;
  case 160: 
   var $dmin_i_i_0;
   var $storemerge_i_i;
   var $1057=(($storemerge_i_i)|(0)) < (($1016)|(0));
   if ($1057) { label = 161; break; } else { label = 164; break; }
  case 161: 
   var $1059=$storemerge_i_i << 2;
   var $1060=(($1014+($1059<<2))|0);
   var $1061=HEAP32[(($1060)>>2)];
   var $1062=((($1061)*(3))&-1);
   var $1063=(($verts+($1062<<2))|0);
   var $1064=$1059 | 1;
   var $1065=(($1014+($1064<<2))|0);
   var $1066=HEAP32[(($1065)>>2)];
   var $1067=((($1066)*(3))&-1);
   var $1068=(($verts+($1067<<2))|0);
   var $1069=$1059 | 2;
   var $1070=(($1014+($1069<<2))|0);
   var $1071=HEAP32[(($1070)>>2)];
   var $1072=((($1071)*(3))&-1);
   var $1073=(($verts+($1072<<2))|0);
   var $1074=HEAPF32[(($1073)>>2)];
   var $1075=HEAPF32[(($1063)>>2)];
   var $1076=($1074)-($1075);
   var $_sum1156=((($1072)+(1))|0);
   var $1077=(($verts+($_sum1156<<2))|0);
   var $1078=HEAPF32[(($1077)>>2)];
   var $_sum1157=((($1062)+(1))|0);
   var $1079=(($verts+($_sum1157<<2))|0);
   var $1080=HEAPF32[(($1079)>>2)];
   var $1081=($1078)-($1080);
   var $_sum1158=((($1072)+(2))|0);
   var $1082=(($verts+($_sum1158<<2))|0);
   var $1083=HEAPF32[(($1082)>>2)];
   var $_sum1159=((($1062)+(2))|0);
   var $1084=(($verts+($_sum1159<<2))|0);
   var $1085=HEAPF32[(($1084)>>2)];
   var $1086=($1083)-($1085);
   var $1087=HEAPF32[(($1068)>>2)];
   var $1088=($1087)-($1075);
   var $_sum1160=((($1067)+(1))|0);
   var $1089=(($verts+($_sum1160<<2))|0);
   var $1090=HEAPF32[(($1089)>>2)];
   var $1091=($1090)-($1080);
   var $_sum1161=((($1067)+(2))|0);
   var $1092=(($verts+($_sum1161<<2))|0);
   var $1093=HEAPF32[(($1092)>>2)];
   var $1094=($1093)-($1085);
   var $1095=($1037)-($1075);
   var $1096=($1055)-($1085);
   var $1097=($1076)*($1076);
   var $1098=($1086)*($1086);
   var $1099=($1097)+($1098);
   var $1100=($1076)*($1088);
   var $1101=($1086)*($1094);
   var $1102=($1100)+($1101);
   var $1103=($1076)*($1095);
   var $1104=($1086)*($1096);
   var $1105=($1103)+($1104);
   var $1106=($1088)*($1088);
   var $1107=($1094)*($1094);
   var $1108=($1106)+($1107);
   var $1109=($1088)*($1095);
   var $1110=($1094)*($1096);
   var $1111=($1109)+($1110);
   var $1112=($1099)*($1108);
   var $1113=($1102)*($1102);
   var $1114=($1112)-($1113);
   var $1115=(1)/($1114);
   var $1116=($1108)*($1105);
   var $1117=($1102)*($1111);
   var $1118=($1116)-($1117);
   var $1119=($1118)*($1115);
   var $1120=($1099)*($1111);
   var $1121=($1102)*($1105);
   var $1122=($1120)-($1121);
   var $1123=($1122)*($1115);
   var $1124=$1119 < -0.00009999999747378752;
   var $1125=$1123 < -0.00009999999747378752;
   var $or_cond1212=$1124 | $1125;
   var $1126=($1119)+($1123);
   var $1127=$1126 > 1.000100016593933;
   var $or_cond1214=$or_cond1212 | $1127;
   if ($or_cond1214) { var $storemerge_i_i_i = 3.4028234663852886e+38;label = 163; break; } else { label = 162; break; }
  case 162: 
   var $1129=($1081)*($1119);
   var $1130=($1080)+($1129);
   var $1131=($1091)*($1123);
   var $1132=($1130)+($1131);
   var $1133=($1132)-($1042);
   var $1134=Math.abs($1133);
   var $storemerge_i_i_i = $1134;label = 163; break;
  case 163: 
   var $storemerge_i_i_i;
   var $1135=$storemerge_i_i_i < $dmin_i_i_0;
   var $dmin_i_i_1=$1135 ? $storemerge_i_i_i : $dmin_i_i_0;
   var $1136=((($storemerge_i_i)+(1))|0);
   var $storemerge_i_i = $1136;var $dmin_i_i_0 = $dmin_i_i_1;label = 160; break;
  case 164: 
   var $1138=$dmin_i_i_0 == 3.4028234663852886e+38;
   var $1139=$dmin_i_i_0 < 0;
   var $or_cond1215=$1138 | $1139;
   var $or_cond1215_not=$or_cond1215 ^ 1;
   var $1140=$dmin_i_i_0 > $bestd_i_0;
   var $or_cond1216=$or_cond1215_not & $1140;
   var $_bestpt_i_sroa_0_0=$or_cond1216 ? $1037 : $bestpt_i_sroa_0_0;
   var $_bestpt_i_sroa_1_0=$or_cond1216 ? $1042 : $bestpt_i_sroa_1_0;
   var $_bestpt_i_sroa_2_0=$or_cond1216 ? $1055 : $bestpt_i_sroa_2_0;
   var $storemerge4_i_besti_i_0=$or_cond1216 ? $storemerge4_i : $besti_i_0;
   var $dmin_i_i_0_bestd_i_0=$or_cond1216 ? $dmin_i_i_0 : $bestd_i_0;
   var $bestd_i_1 = $dmin_i_i_0_bestd_i_0;var $besti_i_1 = $storemerge4_i_besti_i_0;var $bestpt_i_sroa_2_1 = $_bestpt_i_sroa_2_0;var $bestpt_i_sroa_1_1 = $_bestpt_i_sroa_1_0;var $bestpt_i_sroa_0_1 = $_bestpt_i_sroa_0_0;label = 165; break;
  case 165: 
   var $bestpt_i_sroa_0_1;
   var $bestpt_i_sroa_1_1;
   var $bestpt_i_sroa_2_1;
   var $besti_i_1;
   var $bestd_i_1;
   var $1141=((($storemerge4_i)+(1))|0);
   var $storemerge4_i = $1141;var $bestd_i_0 = $bestd_i_1;var $besti_i_0 = $besti_i_1;var $bestpt_i_sroa_2_0 = $bestpt_i_sroa_2_1;var $bestpt_i_sroa_1_0 = $bestpt_i_sroa_1_1;var $bestpt_i_sroa_0_0 = $bestpt_i_sroa_0_1;label = 157; break;
  case 166: 
   var $1143=$bestd_i_0 <= $sampleMaxError;
   var $1144=(($besti_i_0)|(0))==-1;
   var $or_cond1217=$1143 | $1144;
   if ($or_cond1217) { label = 169; break; } else { label = 167; break; }
  case 167: 
   var $1146=$besti_i_0 << 2;
   var $1147=$1146 | 3;
   var $1148=(($1013+($1147<<2))|0);
   HEAP32[(($1148)>>2)]=1;
   var $1149=((($nverts_5)*(3))&-1);
   var $1150=(($verts+($1149<<2))|0);
   HEAPF32[(($1150)>>2)]=$bestpt_i_sroa_0_0;
   var $_sum=((($1149)+(1))|0);
   var $1151=(($verts+($_sum<<2))|0);
   HEAPF32[(($1151)>>2)]=$bestpt_i_sroa_1_0;
   var $_sum1151=((($1149)+(2))|0);
   var $1152=(($verts+($_sum1151<<2))|0);
   HEAPF32[(($1152)>>2)]=$bestpt_i_sroa_2_0;
   var $1153=((($nverts_5)+(1))|0);
   __ZN10rcIntArray6resizeEi($edges, 0);
   __ZN10rcIntArray6resizeEi($tris, 0);
   (function() { try { __THREW__ = 0; return __ZL12delaunayHullP9rcContextiPKfiPKiR10rcIntArrayS6_($ctx, $1153, $188, $nhull_i_4, $198, $tris, $edges) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 168; break; } else { label = 11; break; }
  case 168: 
   var $1154=((($storemerge3_i)+(1))|0);
   var $storemerge3_i = $1154;var $nverts_5 = $1153;label = 155; break;
  case 169: 
   var $_pre1141=HEAP32[(($31)>>2)];
   var $nverts_6 = $nverts_5;var $1156 = $_pre1141;label = 170; break;
  case 170: 
   var $1156;
   var $nverts_6;
   var $1157=(($1156)|(0)) > 1023;
   if ($1157) { label = 171; break; } else { var $nverts_7 = $nverts_6;label = 172; break; }
  case 171: 
   var $1159=((((($1156)|(0)))/(4))&-1);
   __ZN10rcIntArray6resizeEi($tris, 1020);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((6288)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1159,HEAP32[(((tempVarArgs)+(8))>>2)]=255,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $nverts_7 = $nverts_6;label = 172; break; } else { label = 13; break; }
  case 172: 
   var $nverts_7;
   var $storemerge3 = 0;label = 173; break;
  case 173: 
   var $storemerge3;
   var $1161=(($storemerge3)|(0)) < (($nverts_7)|(0));
   if ($1161) { label = 174; break; } else { var $storemerge4 = 0;label = 175; break; }
  case 174: 
   var $1163=HEAPF32[(($24)>>2)];
   var $1164=((($storemerge3)*(3))&-1);
   var $1165=(($verts+($1164<<2))|0);
   var $1166=HEAPF32[(($1165)>>2)];
   var $1167=($1166)+($1163);
   HEAPF32[(($1165)>>2)]=$1167;
   var $1168=HEAPF32[(($199)>>2)];
   var $1169=HEAPF32[(($195)>>2)];
   var $1170=($1168)+($1169);
   var $1171=((($1164)+(1))|0);
   var $1172=(($verts+($1171<<2))|0);
   var $1173=HEAPF32[(($1172)>>2)];
   var $1174=($1173)+($1170);
   HEAPF32[(($1172)>>2)]=$1174;
   var $1175=HEAPF32[(($200)>>2)];
   var $1176=((($1164)+(2))|0);
   var $1177=(($verts+($1176<<2))|0);
   var $1178=HEAPF32[(($1177)>>2)];
   var $1179=($1178)+($1175);
   HEAPF32[(($1177)>>2)]=$1179;
   var $1180=((($storemerge3)+(1))|0);
   var $storemerge3 = $1180;label = 173; break;
  case 175: 
   var $storemerge4;
   var $1181=(($storemerge4)|(0)) < (($npoly_0)|(0));
   if ($1181) { label = 176; break; } else { label = 177; break; }
  case 176: 
   var $1183=HEAPF32[(($24)>>2)];
   var $1184=((($storemerge4)*(3))&-1);
   var $1185=(($59+($1184<<2))|0);
   var $1186=HEAPF32[(($1185)>>2)];
   var $1187=($1186)+($1183);
   HEAPF32[(($1185)>>2)]=$1187;
   var $1188=HEAPF32[(($199)>>2)];
   var $1189=((($1184)+(1))|0);
   var $1190=(($59+($1189<<2))|0);
   var $1191=HEAPF32[(($1190)>>2)];
   var $1192=($1191)+($1188);
   HEAPF32[(($1190)>>2)]=$1192;
   var $1193=HEAPF32[(($200)>>2)];
   var $1194=((($1184)+(2))|0);
   var $1195=(($59+($1194<<2))|0);
   var $1196=HEAPF32[(($1195)>>2)];
   var $1197=($1196)+($1193);
   HEAPF32[(($1195)>>2)]=$1197;
   var $1198=((($storemerge4)+(1))|0);
   var $storemerge4 = $1198;label = 175; break;
  case 177: 
   var $1200=HEAP32[(($31)>>2)];
   var $1201=((((($1200)|(0)))/(4))&-1);
   var $1202=HEAP32[(($160)>>2)];
   var $1203=HEAP32[(($165)>>2)];
   var $1204=(($1203+($253<<2))|0);
   HEAP32[(($1204)>>2)]=$1202;
   var $1205=HEAP32[(($165)>>2)];
   var $1206=(($1205+($259<<2))|0);
   HEAP32[(($1206)>>2)]=$nverts_7;
   var $1207=HEAP32[(($161)>>2)];
   var $1208=HEAP32[(($165)>>2)];
   var $1209=(($1208+($256<<2))|0);
   HEAP32[(($1209)>>2)]=$1207;
   var $1210=HEAP32[(($165)>>2)];
   var $1211=(($1210+($263<<2))|0);
   HEAP32[(($1211)>>2)]=$1201;
   var $1212=HEAP32[(($160)>>2)];
   var $1213=((($1212)+($nverts_7))|0);
   var $1214=(($1213)|(0)) > (($vcap_0)|(0));
   if ($1214) { var $vcap_1 = $vcap_0;label = 178; break; } else { var $vcap_2_ph = $vcap_0;label = 187; break; }
  case 178: 
   var $vcap_1;
   var $1215=(($1213)|(0)) > (($vcap_1)|(0));
   if ($1215) { label = 179; break; } else { label = 180; break; }
  case 179: 
   var $1217=((($vcap_1)+(256))|0);
   var $vcap_1 = $1217;label = 178; break;
  case 180: 
   var $1219=((($vcap_1)*(12))&-1);
   var $1220=_malloc($1219);
   var $1221=$1220;
   var $1222=(($1220)|(0))==0;
   if ($1222) { label = 181; break; } else { label = 182; break; }
  case 181: 
   var $1224=((($vcap_1)*(3))&-1);
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((1152)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1224,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $511;label = 209; break; } else { var $67 = $511;label = 14; break; }
  case 182: 
   var $1226=HEAP32[(($160)>>2)];
   var $1227=(($1226)|(0))==0;
   if ($1227) { label = 184; break; } else { label = 183; break; }
  case 183: 
   var $1229=HEAP32[(($177)>>2)];
   var $1230=$1229;
   var $1231=((($1226)*(12))&-1);
   assert($1231 % 1 === 0);(_memcpy($1220, $1230, $1231)|0);
   label = 184; break;
  case 184: 
   var $1233=HEAP32[(($177)>>2)];
   var $1234=(($1233)|(0))==0;
   if ($1234) { label = 186; break; } else { label = 185; break; }
  case 185: 
   var $1236=$1233;
   _free($1236);
   label = 186; break;
  case 186: 
   HEAP32[(($177)>>2)]=$1221;
   var $vcap_2_ph = $vcap_1;label = 187; break;
  case 187: 
   var $vcap_2_ph;
   var $storemerge5 = 0;label = 188; break;
  case 188: 
   var $storemerge5;
   var $1239=(($storemerge5)|(0)) < (($nverts_7)|(0));
   if ($1239) { label = 189; break; } else { label = 190; break; }
  case 189: 
   var $1241=((($storemerge5)*(3))&-1);
   var $1242=(($verts+($1241<<2))|0);
   var $1243=HEAPF32[(($1242)>>2)];
   var $1244=HEAP32[(($160)>>2)];
   var $1245=((($1244)*(3))&-1);
   var $1246=HEAP32[(($177)>>2)];
   var $1247=(($1246+($1245<<2))|0);
   HEAPF32[(($1247)>>2)]=$1243;
   var $1248=((($1241)+(1))|0);
   var $1249=(($verts+($1248<<2))|0);
   var $1250=HEAPF32[(($1249)>>2)];
   var $1251=HEAP32[(($160)>>2)];
   var $1252=((($1251)*(3))&-1);
   var $1253=((($1252)+(1))|0);
   var $1254=HEAP32[(($177)>>2)];
   var $1255=(($1254+($1253<<2))|0);
   HEAPF32[(($1255)>>2)]=$1250;
   var $1256=((($1241)+(2))|0);
   var $1257=(($verts+($1256<<2))|0);
   var $1258=HEAPF32[(($1257)>>2)];
   var $1259=HEAP32[(($160)>>2)];
   var $1260=((($1259)*(3))&-1);
   var $1261=((($1260)+(2))|0);
   var $1262=HEAP32[(($177)>>2)];
   var $1263=(($1262+($1261<<2))|0);
   HEAPF32[(($1263)>>2)]=$1258;
   var $1264=HEAP32[(($160)>>2)];
   var $1265=((($1264)+(1))|0);
   HEAP32[(($160)>>2)]=$1265;
   var $1266=((($storemerge5)+(1))|0);
   var $storemerge5 = $1266;label = 188; break;
  case 190: 
   var $1268=HEAP32[(($161)>>2)];
   var $1269=((($1268)+($1201))|0);
   var $1270=(($1269)|(0)) > (($tcap_0)|(0));
   if ($1270) { var $tcap_1 = $tcap_0;label = 191; break; } else { var $tcap_2_ph = $tcap_0;label = 200; break; }
  case 191: 
   var $tcap_1;
   var $1271=(($1269)|(0)) > (($tcap_1)|(0));
   if ($1271) { label = 192; break; } else { label = 193; break; }
  case 192: 
   var $1273=((($tcap_1)+(256))|0);
   var $tcap_1 = $1273;label = 191; break;
  case 193: 
   var $1275=$tcap_1 << 2;
   var $1276=_malloc($1275);
   var $1277=(($1276)|(0))==0;
   if ($1277) { label = 194; break; } else { label = 195; break; }
  case 194: 
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((760)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1275,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_01053 = 0;var $1355 = $511;label = 209; break; } else { var $67 = $511;label = 14; break; }
  case 195: 
   var $1280=HEAP32[(($161)>>2)];
   var $1281=(($1280)|(0))==0;
   if ($1281) { label = 197; break; } else { label = 196; break; }
  case 196: 
   var $1283=HEAP32[(($184)>>2)];
   var $1284=$1280 << 2;
   assert($1284 % 1 === 0);(_memcpy($1276, $1283, $1284)|0);
   label = 197; break;
  case 197: 
   var $1286=HEAP32[(($184)>>2)];
   var $1287=(($1286)|(0))==0;
   if ($1287) { label = 199; break; } else { label = 198; break; }
  case 198: 
   _free($1286);
   label = 199; break;
  case 199: 
   HEAP32[(($184)>>2)]=$1276;
   var $tcap_2_ph = $tcap_1;label = 200; break;
  case 200: 
   var $tcap_2_ph;
   var $storemerge6 = 0;label = 201; break;
  case 201: 
   var $storemerge6;
   var $1291=(($storemerge6)|(0)) < (($1201)|(0));
   if ($1291) { label = 202; break; } else { label = 206; break; }
  case 202: 
   var $1293=$storemerge6 << 2;
   var $1294=HEAP32[(($30)>>2)];
   var $1295=(($1294+($1293<<2))|0);
   var $1296=HEAP32[(($1295)>>2)];
   var $1297=(($1296) & 255);
   var $1298=HEAP32[(($161)>>2)];
   var $1299=$1298 << 2;
   var $1300=HEAP32[(($184)>>2)];
   var $1301=(($1300+$1299)|0);
   HEAP8[($1301)]=$1297;
   var $_sum1149=$1293 | 1;
   var $1302=(($1294+($_sum1149<<2))|0);
   var $1303=HEAP32[(($1302)>>2)];
   var $1304=(($1303) & 255);
   var $1305=HEAP32[(($161)>>2)];
   var $1306=$1305 << 2;
   var $1307=$1306 | 1;
   var $1308=HEAP32[(($184)>>2)];
   var $1309=(($1308+$1307)|0);
   HEAP8[($1309)]=$1304;
   var $_sum1150=$1293 | 2;
   var $1310=(($1294+($_sum1150<<2))|0);
   var $1311=HEAP32[(($1310)>>2)];
   var $1312=(($1311) & 255);
   var $1313=HEAP32[(($161)>>2)];
   var $1314=$1313 << 2;
   var $1315=$1314 | 2;
   var $1316=HEAP32[(($184)>>2)];
   var $1317=(($1316+$1315)|0);
   HEAP8[($1317)]=$1312;
   var $1318=HEAP32[(($1310)>>2)];
   var $1319=HEAP32[(($1302)>>2)];
   var $1320=HEAP32[(($1295)>>2)];
   var $1321=((($1318)*(3))&-1);
   var $1322=((($1319)*(3))&-1);
   var $1323=((($1320)*(3))&-1);
   var $1324=(($verts+($1321<<2))|0);
   var $1325=(($verts+($1322<<2))|0);
   var $1326=(($verts+($1323<<2))|0);
   var $1327 = (function() { try { __THREW__ = 0; return __ZL12getEdgeFlagsPKfS0_S0_i($1326, $1325, $59, $npoly_0) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 203; break; } else { label = 12; break; }
  case 203: 
   var $1328 = (function() { try { __THREW__ = 0; return __ZL12getEdgeFlagsPKfS0_S0_i($1325, $1324, $59, $npoly_0) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 204; break; } else { label = 12; break; }
  case 204: 
   var $1329 = (function() { try { __THREW__ = 0; return __ZL12getEdgeFlagsPKfS0_S0_i($1324, $1326, $59, $npoly_0) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 205; break; } else { label = 12; break; }
  case 205: 
   var $1331=$1328 << 2;
   var $1332=$1327 | $1331;
   var $1333=$1329 << 4;
   var $1334=$1332 | $1333;
   var $1335=HEAP32[(($161)>>2)];
   var $1336=$1335 << 2;
   var $1337=$1336 | 3;
   var $1338=HEAP32[(($184)>>2)];
   var $1339=(($1338+$1337)|0);
   HEAP8[($1339)]=$1334;
   var $1340=HEAP32[(($161)>>2)];
   var $1341=((($1340)+(1))|0);
   HEAP32[(($161)>>2)]=$1341;
   var $1342=((($storemerge6)+(1))|0);
   var $storemerge6 = $1342;label = 201; break;
  case 206: 
   var $1344=((($storemerge1)+(1))|0);
   var $storemerge1 = $1344;var $tcap_0 = $tcap_2_ph;var $vcap_0 = $vcap_2_ph;var $212 = $511;label = 34; break;
  case 207: 
   var $1346=HEAP8[($1)];
   var $1347=$1346 & 1;
   var $1348=(($1347 << 24) >> 24)==0;
   if ($1348) { var $_01053 = 1;var $1355 = $212;label = 209; break; } else { label = 208; break; }
  case 208: 
   var $1350=$ctx;
   var $1351=HEAP32[(($1350)>>2)];
   var $1352=(($1351+24)|0);
   var $1353=HEAP32[(($1352)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$1353]($ctx, 26) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $_01053 = 1;var $1355 = $212;label = 209; break; } else { var $67 = $212;label = 14; break; }
  case 209: 
   var $1355;
   var $_01053;
   if ($60) { label = 211; break; } else { label = 210; break; }
  case 210: 
   _free($58);
   label = 211; break;
  case 211: 
   if ($49) { var $1358 = $1355;var $_11195 = $_01053;label = 213; break; } else { var $1357 = $1355;var $_11205 = $_01053;label = 212; break; }
  case 212: 
   var $_11205;
   var $1357;
   _free($47);
   var $1358 = $1357;var $_11195 = $_11205;label = 213; break;
  case 213: 
   var $_11195;
   var $1358;
   var $1359=(($1358)|(0))==0;
   if ($1359) { var $_111951196 = $_11195;label = 215; break; } else { label = 214; break; }
  case 214: 
   var $1361=$1358;
   _free($1361);
   var $_111951196 = $_11195;label = 215; break;
  case 215: 
   var $_111951196;
   var $1362=HEAP32[(($36)>>2)];
   var $1363=(($1362)|(0))==0;
   if ($1363) { label = 217; break; } else { label = 216; break; }
  case 216: 
   var $1365=$1362;
   _free($1365);
   label = 217; break;
  case 217: 
   var $1366=HEAP32[(($33)>>2)];
   var $1367=(($1366)|(0))==0;
   if ($1367) { label = 219; break; } else { label = 218; break; }
  case 218: 
   var $1369=$1366;
   _free($1369);
   label = 219; break;
  case 219: 
   var $1370=HEAP32[(($30)>>2)];
   var $1371=(($1370)|(0))==0;
   if ($1371) { label = 221; break; } else { label = 220; break; }
  case 220: 
   var $1373=$1370;
   _free($1373);
   label = 221; break;
  case 221: 
   var $1374=HEAP32[(($27)>>2)];
   var $1375=(($1374)|(0))==0;
   if ($1375) { var $_2 = $_111951196;label = 235; break; } else { label = 222; break; }
  case 222: 
   var $1377=$1374;
   _free($1377);
   var $_2 = $_111951196;label = 235; break;
  case 223: 
   if ($49) { label = 225; break; } else { label = 224; break; }
  case 224: 
   _free($47);
   label = 225; break;
  case 225: 
   var $1380=(($68)|(0))==0;
   if ($1380) { var $_011991201 = $70;var $_0105211981203 = $69;label = 227; break; } else { label = 226; break; }
  case 226: 
   var $1382=$68;
   _free($1382);
   var $_011991201 = $70;var $_0105211981203 = $69;label = 227; break;
  case 227: 
   var $_0105211981203;
   var $_011991201;
   var $1383=HEAP32[(($36)>>2)];
   var $1384=(($1383)|(0))==0;
   if ($1384) { label = 229; break; } else { label = 228; break; }
  case 228: 
   var $1386=$1383;
   _free($1386);
   label = 229; break;
  case 229: 
   var $1387=HEAP32[(($33)>>2)];
   var $1388=(($1387)|(0))==0;
   if ($1388) { label = 231; break; } else { label = 230; break; }
  case 230: 
   var $1390=$1387;
   _free($1390);
   label = 231; break;
  case 231: 
   var $1391=HEAP32[(($30)>>2)];
   var $1392=(($1391)|(0))==0;
   if ($1392) { label = 233; break; } else { label = 232; break; }
  case 232: 
   var $1394=$1391;
   _free($1394);
   label = 233; break;
  case 233: 
   var $1396=HEAP32[(($27)>>2)];
   var $1397=(($1396)|(0))==0;
   if ($1397) { label = 236; break; } else { label = 234; break; }
  case 234: 
   var $1399=$1396;
   _free($1399);
   label = 236; break;
  case 235: 
   var $_2;
   STACKTOP = sp;
   return $_2;
  case 236: 
   var $1401$0=$_0105211981203;
   var $1401$1=0;
   var $1402$0=$1401$0;
   var $1402$1=$_011991201;
   ___resumeException($1402$0)
  default: assert(0, "bad label: " + label);
 }
}
function __ZL15distancePtSeg2dPKfS0_S0_($pt, $p, $q_val, $q_2_val) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAPF32[(($p)>>2)];
   var $2=($q_val)-($1);
   var $3=(($p+8)|0);
   var $4=HEAPF32[(($3)>>2)];
   var $5=($q_2_val)-($4);
   var $6=HEAPF32[(($pt)>>2)];
   var $7=($6)-($1);
   var $8=(($pt+8)|0);
   var $9=HEAPF32[(($8)>>2)];
   var $10=($9)-($4);
   var $11=($2)*($2);
   var $12=($5)*($5);
   var $13=($11)+($12);
   var $14=($2)*($7);
   var $15=($5)*($10);
   var $16=($14)+($15);
   var $17=$13 > 0;
   if ($17) { label = 2; break; } else { var $t_0 = $16;label = 3; break; }
  case 2: 
   var $19=($16)/($13);
   var $t_0 = $19;label = 3; break;
  case 3: 
   var $t_0;
   var $21=$t_0 < 0;
   if ($21) { var $t_1 = 0;label = 6; break; } else { label = 4; break; }
  case 4: 
   var $23=$t_0 > 1;
   if ($23) { label = 5; break; } else { var $t_1 = $t_0;label = 6; break; }
  case 5: 
   var $t_1 = 1;label = 6; break;
  case 6: 
   var $t_1;
   var $26=($t_1)*($2);
   var $27=($1)+($26);
   var $28=($27)-($6);
   var $29=($t_1)*($5);
   var $30=($4)+($29);
   var $31=($30)-($9);
   var $32=($28)*($28);
   var $33=($31)*($31);
   var $34=($32)+($33);
   return $34;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12getEdgeFlagsPKfS0_S0_i($va, $vb, $vpoly, $npoly) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAP8[(8232)];
   var $2=(($1 << 24) >> 24)==0;
   if ($2) { label = 2; break; } else { label = 4; break; }
  case 2: 
   var $4=___cxa_guard_acquire(8232);
   var $5=(($4)|(0))==0;
   if ($5) { label = 4; break; } else { label = 3; break; }
  case 3: 
   HEAPF32[((6616)>>2)]=0.0000010000001111620804;
   label = 4; break;
  case 4: 
   var $8=((($npoly)-(1))|0);
   var $9=HEAPF32[((6616)>>2)];
   var $storemerge = $8;var $i_0 = 0;label = 5; break;
  case 5: 
   var $i_0;
   var $storemerge;
   var $11=(($i_0)|(0)) < (($npoly)|(0));
   if ($11) { label = 6; break; } else { var $storemerge1 = 0;label = 9; break; }
  case 6: 
   var $13=((($storemerge)*(3))&-1);
   var $14=(($vpoly+($13<<2))|0);
   var $15=((($i_0)*(3))&-1);
   var $16=(($vpoly+($15<<2))|0);
   var $_val2=HEAPF32[(($16)>>2)];
   var $_sum=((($15)+(2))|0);
   var $_idx3=(($vpoly+($_sum<<2))|0);
   var $_idx3_val=HEAPF32[(($_idx3)>>2)];
   var $17=__ZL15distancePtSeg2dPKfS0_S0_($va, $14, $_val2, $_idx3_val);
   var $18=$17 < $9;
   if ($18) { label = 7; break; } else { label = 8; break; }
  case 7: 
   var $20=__ZL15distancePtSeg2dPKfS0_S0_($vb, $14, $_val2, $_idx3_val);
   var $21=$20 < $9;
   if ($21) { var $storemerge1 = 1;label = 9; break; } else { label = 8; break; }
  case 8: 
   var $23=((($i_0)+(1))|0);
   var $storemerge = $i_0;var $i_0 = $23;label = 5; break;
  case 9: 
   var $storemerge1;
   return $storemerge1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL9getHeightffffffRK13rcHeightPatch($fx, $fy, $fz, $0, $ics, $ch, $hp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $2=($fx)*($ics);
   var $3=($2)+(0.009999999776482582);
   var $4=Math.floor($3);
   var $5=(($4)&-1);
   var $6=($fz)*($ics);
   var $7=($6)+(0.009999999776482582);
   var $8=Math.floor($7);
   var $9=(($8)&-1);
   var $10=(($hp+4)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=((($5)-($11))|0);
   var $13=(($hp+12)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($12)|(0)) < 0;
   if ($15) { var $19 = 0;label = 3; break; } else { label = 2; break; }
  case 2: 
   var $17=(($12)|(0)) > (($14)|(0));
   var $18=$17 ? $14 : $12;
   var $19 = $18;label = 3; break;
  case 3: 
   var $19;
   var $20=(($hp+8)|0);
   var $21=HEAP32[(($20)>>2)];
   var $22=((($9)-($21))|0);
   var $23=(($hp+16)|0);
   var $24=HEAP32[(($23)>>2)];
   var $25=(($22)|(0)) < 0;
   if ($25) { var $29 = 0;label = 5; break; } else { label = 4; break; }
  case 4: 
   var $27=(($22)|(0)) > (($24)|(0));
   var $28=$27 ? $24 : $22;
   var $29 = $28;label = 5; break;
  case 5: 
   var $29;
   var $30=(Math.imul($29,$14)|0);
   var $31=((($19)+($30))|0);
   var $32=(($hp)|0);
   var $33=HEAP32[(($32)>>2)];
   var $34=(($33+($31<<1))|0);
   var $35=HEAP16[(($34)>>1)];
   var $36=(($35 << 16) >> 16)==-1;
   if ($36) { var $storemerge = 0;var $h_0 = -1;var $dmin_0 = 3.4028234663852886e+38;label = 6; break; } else { var $h_2 = $35;label = 12; break; }
  case 6: 
   var $dmin_0;
   var $h_0;
   var $storemerge;
   var $38=(($storemerge)|(0)) < 8;
   if ($38) { label = 7; break; } else { var $h_2 = $h_0;label = 12; break; }
  case 7: 
   var $40=$storemerge << 1;
   var $41=((6480+($40<<2))|0);
   var $42=HEAP32[(($41)>>2)];
   var $43=((($19)+($42))|0);
   var $44=$40 | 1;
   var $45=((6480+($44<<2))|0);
   var $46=HEAP32[(($45)>>2)];
   var $47=((($29)+($46))|0);
   var $48=(($43)|(0)) < 0;
   var $49=(($47)|(0)) < 0;
   var $or_cond=$48 | $49;
   var $or_cond_not=$or_cond ^ 1;
   var $50=(($43)|(0)) < (($14)|(0));
   var $or_cond38=$or_cond_not & $50;
   var $51=(($47)|(0)) < (($24)|(0));
   var $or_cond39=$or_cond38 & $51;
   if ($or_cond39) { label = 8; break; } else { var $h_1 = $h_0;var $dmin_1 = $dmin_0;label = 11; break; }
  case 8: 
   var $53=(Math.imul($47,$14)|0);
   var $54=((($43)+($53))|0);
   var $55=(($33+($54<<1))|0);
   var $56=HEAP16[(($55)>>1)];
   var $57=(($56 << 16) >> 16)==-1;
   if ($57) { var $h_1 = $h_0;var $dmin_1 = $dmin_0;label = 11; break; } else { label = 9; break; }
  case 9: 
   var $59=(($56)&(65535));
   var $60=(($59)|(0));
   var $61=($60)*($ch);
   var $62=($61)-($fy);
   var $63=Math.abs($62);
   var $64=$63 < $dmin_0;
   if ($64) { label = 10; break; } else { var $h_1 = $h_0;var $dmin_1 = $dmin_0;label = 11; break; }
  case 10: 
   var $h_1 = $56;var $dmin_1 = $63;label = 11; break;
  case 11: 
   var $dmin_1;
   var $h_1;
   var $67=((($storemerge)+(1))|0);
   var $storemerge = $67;var $h_0 = $h_1;var $dmin_0 = $dmin_1;label = 6; break;
  case 12: 
   var $h_2;
   return $h_2;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12delaunayHullP9rcContextiPKfiPKiR10rcIntArrayS6_($ctx, $npts, $pts, $nhull, $hull, $tris, $edges) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 16)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $nfaces=sp;
   var $nedges=(sp)+(8);
   HEAP32[(($nfaces)>>2)]=0;
   HEAP32[(($nedges)>>2)]=0;
   var $1=((($npts)*(10))&-1);
   var $2=((($npts)*(40))&-1);
   __ZN10rcIntArray6resizeEi($edges, $2);
   var $3=((($nhull)-(1))|0);
   var $4=(($edges)|0);
   var $storemerge = $3;var $i_0 = 0;label = 2; break;
  case 2: 
   var $i_0;
   var $storemerge;
   var $6=(($i_0)|(0)) < (($nhull)|(0));
   if ($6) { label = 3; break; } else { var $storemerge1 = 0;label = 4; break; }
  case 3: 
   var $8=HEAP32[(($4)>>2)];
   var $9=(($hull+($storemerge<<2))|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=(($hull+($i_0<<2))|0);
   var $12=HEAP32[(($11)>>2)];
   __ZL7addEdgeP9rcContextPiRiiiiii($ctx, $8, $nedges, $1, $10, $12, -2);
   var $13=((($i_0)+(1))|0);
   var $storemerge = $i_0;var $i_0 = $13;label = 2; break;
  case 4: 
   var $storemerge1;
   var $14=HEAP32[(($nedges)>>2)];
   var $15=(($storemerge1)|(0)) < (($14)|(0));
   if ($15) { label = 5; break; } else { label = 10; break; }
  case 5: 
   var $17=$storemerge1 << 2;
   var $18=$17 | 2;
   var $19=HEAP32[(($4)>>2)];
   var $20=(($19+($18<<2))|0);
   var $21=HEAP32[(($20)>>2)];
   var $22=(($21)|(0))==-1;
   if ($22) { label = 6; break; } else { var $25 = $19;label = 7; break; }
  case 6: 
   __ZL13completeFacetP9rcContextPKfiPiRiiS4_i($ctx, $pts, $npts, $19, $nedges, $1, $nfaces, $storemerge1);
   var $_pre=HEAP32[(($4)>>2)];
   var $25 = $_pre;label = 7; break;
  case 7: 
   var $25;
   var $26=$17 | 3;
   var $27=(($25+($26<<2))|0);
   var $28=HEAP32[(($27)>>2)];
   var $29=(($28)|(0))==-1;
   if ($29) { label = 8; break; } else { label = 9; break; }
  case 8: 
   __ZL13completeFacetP9rcContextPKfiPiRiiS4_i($ctx, $pts, $npts, $25, $nedges, $1, $nfaces, $storemerge1);
   label = 9; break;
  case 9: 
   var $32=((($storemerge1)+(1))|0);
   var $storemerge1 = $32;label = 4; break;
  case 10: 
   var $34=HEAP32[(($nfaces)>>2)];
   var $35=$34 << 2;
   __ZN10rcIntArray6resizeEi($tris, $35);
   var $36=(($tris)|0);
   var $storemerge2 = 0;label = 11; break;
  case 11: 
   var $storemerge2;
   var $38=(($storemerge2)|(0)) < (($35)|(0));
   if ($38) { label = 12; break; } else { var $storemerge3 = 0;label = 13; break; }
  case 12: 
   var $40=HEAP32[(($36)>>2)];
   var $41=(($40+($storemerge2<<2))|0);
   HEAP32[(($41)>>2)]=-1;
   var $42=((($storemerge2)+(1))|0);
   var $storemerge2 = $42;label = 11; break;
  case 13: 
   var $storemerge3;
   var $43=(($storemerge3)|(0)) < (($14)|(0));
   if ($43) { label = 15; break; } else { label = 14; break; }
  case 14: 
   var $44=(($tris+4)|0);
   var $storemerge4 = 0;label = 30; break;
  case 15: 
   var $46=$storemerge3 << 2;
   var $47=HEAP32[(($4)>>2)];
   var $48=(($47+($46<<2))|0);
   var $_sum5=$46 | 3;
   var $49=(($47+($_sum5<<2))|0);
   var $50=HEAP32[(($49)>>2)];
   var $51=(($50)|(0)) > -1;
   if ($51) { label = 16; break; } else { label = 22; break; }
  case 16: 
   var $53=$50 << 2;
   var $54=HEAP32[(($36)>>2)];
   var $55=(($54+($53<<2))|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=(($56)|(0))==-1;
   if ($57) { label = 17; break; } else { label = 18; break; }
  case 17: 
   var $59=HEAP32[(($48)>>2)];
   HEAP32[(($55)>>2)]=$59;
   var $_sum99=$46 | 1;
   var $60=(($47+($_sum99<<2))|0);
   var $61=HEAP32[(($60)>>2)];
   var $_sum100=$53 | 1;
   var $62=(($54+($_sum100<<2))|0);
   HEAP32[(($62)>>2)]=$61;
   label = 22; break;
  case 18: 
   var $_sum95=$46 | 1;
   var $64=(($47+($_sum95<<2))|0);
   var $65=HEAP32[(($64)>>2)];
   var $66=(($56)|(0))==(($65)|(0));
   if ($66) { label = 19; break; } else { label = 20; break; }
  case 19: 
   var $68=HEAP32[(($48)>>2)];
   var $_sum98=$53 | 2;
   var $69=(($54+($_sum98<<2))|0);
   HEAP32[(($69)>>2)]=$68;
   label = 22; break;
  case 20: 
   var $_sum96=$53 | 1;
   var $71=(($54+($_sum96<<2))|0);
   var $72=HEAP32[(($71)>>2)];
   var $73=HEAP32[(($48)>>2)];
   var $74=(($72)|(0))==(($73)|(0));
   if ($74) { label = 21; break; } else { label = 22; break; }
  case 21: 
   var $_sum97=$53 | 2;
   var $76=(($54+($_sum97<<2))|0);
   HEAP32[(($76)>>2)]=$65;
   label = 22; break;
  case 22: 
   var $_sum87=$46 | 2;
   var $78=(($47+($_sum87<<2))|0);
   var $79=HEAP32[(($78)>>2)];
   var $80=(($79)|(0)) > -1;
   if ($80) { label = 23; break; } else { label = 29; break; }
  case 23: 
   var $82=$79 << 2;
   var $83=HEAP32[(($36)>>2)];
   var $84=(($83+($82<<2))|0);
   var $85=HEAP32[(($84)>>2)];
   var $86=(($85)|(0))==-1;
   if ($86) { label = 24; break; } else { label = 25; break; }
  case 24: 
   var $_sum93=$46 | 1;
   var $88=(($47+($_sum93<<2))|0);
   var $89=HEAP32[(($88)>>2)];
   HEAP32[(($84)>>2)]=$89;
   var $90=HEAP32[(($48)>>2)];
   var $_sum94=$82 | 1;
   var $91=(($83+($_sum94<<2))|0);
   HEAP32[(($91)>>2)]=$90;
   label = 29; break;
  case 25: 
   var $93=HEAP32[(($48)>>2)];
   var $94=(($85)|(0))==(($93)|(0));
   if ($94) { label = 26; break; } else { label = 27; break; }
  case 26: 
   var $_sum91=$46 | 1;
   var $96=(($47+($_sum91<<2))|0);
   var $97=HEAP32[(($96)>>2)];
   var $_sum92=$82 | 2;
   var $98=(($83+($_sum92<<2))|0);
   HEAP32[(($98)>>2)]=$97;
   label = 29; break;
  case 27: 
   var $_sum88=$82 | 1;
   var $100=(($83+($_sum88<<2))|0);
   var $101=HEAP32[(($100)>>2)];
   var $_sum89=$46 | 1;
   var $102=(($47+($_sum89<<2))|0);
   var $103=HEAP32[(($102)>>2)];
   var $104=(($101)|(0))==(($103)|(0));
   if ($104) { label = 28; break; } else { label = 29; break; }
  case 28: 
   var $_sum90=$82 | 2;
   var $106=(($83+($_sum90<<2))|0);
   HEAP32[(($106)>>2)]=$93;
   label = 29; break;
  case 29: 
   var $108=((($storemerge3)+(1))|0);
   var $storemerge3 = $108;label = 13; break;
  case 30: 
   var $storemerge4;
   var $110=HEAP32[(($44)>>2)];
   var $111=((((($110)|(0)))/(4))&-1);
   var $112=(($storemerge4)|(0)) < (($111)|(0));
   if ($112) { label = 31; break; } else { label = 36; break; }
  case 31: 
   var $114=$storemerge4 << 2;
   var $115=HEAP32[(($36)>>2)];
   var $116=(($115+($114<<2))|0);
   var $117=HEAP32[(($116)>>2)];
   var $118=(($117)|(0))==-1;
   var $_sum86=$114 | 1;
   var $_phi_trans_insert=(($115+($_sum86<<2))|0);
   var $_pre80=HEAP32[(($_phi_trans_insert)>>2)];
   if ($118) { var $125 = $_pre80;label = 34; break; } else { label = 32; break; }
  case 32: 
   var $120=(($_pre80)|(0))==-1;
   if ($120) { var $125 = -1;label = 34; break; } else { label = 33; break; }
  case 33: 
   var $_sum82=$114 | 2;
   var $122=(($115+($_sum82<<2))|0);
   var $123=HEAP32[(($122)>>2)];
   var $124=(($123)|(0))==-1;
   if ($124) { var $125 = $_pre80;label = 34; break; } else { var $i4_0 = $storemerge4;label = 35; break; }
  case 34: 
   var $125;
   var $_sum83=$114 | 1;
   var $126=(($115+($_sum83<<2))|0);
   var $_sum84=$114 | 2;
   var $127=(($115+($_sum84<<2))|0);
   var $128=HEAP32[(($127)>>2)];
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 2, ((6168)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$storemerge4,HEAP32[(((tempVarArgs)+(8))>>2)]=$117,HEAP32[(((tempVarArgs)+(16))>>2)]=$125,HEAP32[(((tempVarArgs)+(24))>>2)]=$128,tempVarArgs)); STACKTOP=tempVarArgs;
   var $129=HEAP32[(($44)>>2)];
   var $130=((($129)-(4))|0);
   var $131=HEAP32[(($36)>>2)];
   var $132=(($131+($130<<2))|0);
   var $133=HEAP32[(($132)>>2)];
   HEAP32[(($116)>>2)]=$133;
   var $134=HEAP32[(($44)>>2)];
   var $135=((($134)-(3))|0);
   var $136=HEAP32[(($36)>>2)];
   var $137=(($136+($135<<2))|0);
   var $138=HEAP32[(($137)>>2)];
   HEAP32[(($126)>>2)]=$138;
   var $139=HEAP32[(($44)>>2)];
   var $140=((($139)-(2))|0);
   var $141=HEAP32[(($36)>>2)];
   var $142=(($141+($140<<2))|0);
   var $143=HEAP32[(($142)>>2)];
   HEAP32[(($127)>>2)]=$143;
   var $144=HEAP32[(($44)>>2)];
   var $145=((($144)-(1))|0);
   var $146=HEAP32[(($36)>>2)];
   var $147=(($146+($145<<2))|0);
   var $148=HEAP32[(($147)>>2)];
   var $_sum85=$114 | 3;
   var $149=(($115+($_sum85<<2))|0);
   HEAP32[(($149)>>2)]=$148;
   var $150=HEAP32[(($44)>>2)];
   var $151=((($150)-(4))|0);
   __ZN10rcIntArray6resizeEi($tris, $151);
   var $152=((($storemerge4)-(1))|0);
   var $i4_0 = $152;label = 35; break;
  case 35: 
   var $i4_0;
   var $154=((($i4_0)+(1))|0);
   var $storemerge4 = $154;label = 30; break;
  case 36: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL7addEdgeP9rcContextPiRiiiiii($ctx, $edges, $nedges, $maxEdges, $s, $t, $l) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAP32[(($nedges)>>2)];
   var $2=(($1)|(0)) < (($maxEdges)|(0));
   if ($2) { var $storemerge_i = 0;label = 3; break; } else { label = 2; break; }
  case 2: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((6008)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$1,HEAP32[(((tempVarArgs)+(8))>>2)]=$maxEdges,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 11; break;
  case 3: 
   var $storemerge_i;
   var $5=(($storemerge_i)|(0)) < (($1)|(0));
   if ($5) { label = 4; break; } else { label = 10; break; }
  case 4: 
   var $7=$storemerge_i << 2;
   var $8=(($edges+($7<<2))|0);
   var $9=HEAP32[(($8)>>2)];
   var $10=(($9)|(0))==(($s)|(0));
   if ($10) { label = 5; break; } else { label = 6; break; }
  case 5: 
   var $_sum39=$7 | 1;
   var $12=(($edges+($_sum39<<2))|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($13)|(0))==(($t)|(0));
   if ($14) { label = 9; break; } else { label = 6; break; }
  case 6: 
   var $16=(($9)|(0))==(($t)|(0));
   if ($16) { label = 7; break; } else { label = 8; break; }
  case 7: 
   var $_sum38=$7 | 1;
   var $18=(($edges+($_sum38<<2))|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==(($s)|(0));
   if ($20) { label = 9; break; } else { label = 8; break; }
  case 8: 
   var $22=((($storemerge_i)+(1))|0);
   var $storemerge_i = $22;label = 3; break;
  case 9: 
   var $phitmp=(($storemerge_i)|(0))==-1;
   if ($phitmp) { label = 10; break; } else { label = 11; break; }
  case 10: 
   var $23=$1 << 2;
   var $24=(($edges+($23<<2))|0);
   HEAP32[(($24)>>2)]=$s;
   var $_sum35=$23 | 1;
   var $25=(($edges+($_sum35<<2))|0);
   HEAP32[(($25)>>2)]=$t;
   var $_sum36=$23 | 2;
   var $26=(($edges+($_sum36<<2))|0);
   HEAP32[(($26)>>2)]=$l;
   var $_sum37=$23 | 3;
   var $27=(($edges+($_sum37<<2))|0);
   HEAP32[(($27)>>2)]=-1;
   var $28=HEAP32[(($nedges)>>2)];
   var $29=((($28)+(1))|0);
   HEAP32[(($nedges)>>2)]=$29;
   label = 11; break;
  case 11: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL13completeFacetP9rcContextPKfiPiRiiS4_i($ctx, $pts, $npts, $edges, $nedges, $maxEdges, $nfaces, $e) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 24)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $c=sp;
   var $r=(sp)+(16);
   var $1=$e << 2;
   var $2=(($edges+($1<<2))|0);
   var $_sum1=$1 | 2;
   var $3=(($edges+($_sum1<<2))|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($4)|(0))==-1;
   if ($5) { label = 2; break; } else { label = 3; break; }
  case 2: 
   var $_sum288289=$1 | 1;
   var $7=(($edges+($_sum288289<<2))|0);
   var $s_0_in = $2;var $t_0_in = $7;label = 5; break;
  case 3: 
   var $_sum242243=$1 | 3;
   var $9=(($edges+($_sum242243<<2))|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=(($10)|(0))==-1;
   if ($11) { label = 4; break; } else { label = 62; break; }
  case 4: 
   var $_sum244245=$1 | 1;
   var $13=(($edges+($_sum244245<<2))|0);
   var $s_0_in = $13;var $t_0_in = $2;label = 5; break;
  case 5: 
   var $t_0_in;
   var $s_0_in;
   var $s_0=HEAP32[(($s_0_in)>>2)];
   var $t_0=HEAP32[(($t_0_in)>>2)];
   var $15=$c;
   HEAP32[(($15)>>2)]=0; HEAP32[((($15)+(4))>>2)]=0; HEAP32[((($15)+(8))>>2)]=0;
   HEAPF32[(($r)>>2)]=-1;
   var $16=((($s_0)*(3))&-1);
   var $17=(($pts+($16<<2))|0);
   var $18=((($t_0)*(3))&-1);
   var $19=(($pts+($18<<2))|0);
   var $_sum=((($18)+(2))|0);
   var $20=(($pts+($_sum<<2))|0);
   var $_sum246=((($16)+(2))|0);
   var $21=(($pts+($_sum246<<2))|0);
   var $22=(($c)|0);
   var $23=(($c+8)|0);
   var $storemerge = 0;var $pt_0 = $npts;label = 6; break;
  case 6: 
   var $pt_0;
   var $storemerge;
   var $25=(($storemerge)|(0)) < (($npts)|(0));
   if ($25) { label = 7; break; } else { label = 18; break; }
  case 7: 
   var $27=(($storemerge)|(0))==(($s_0)|(0));
   var $28=(($storemerge)|(0))==(($t_0)|(0));
   var $or_cond=$27 | $28;
   if ($or_cond) { var $pt_1 = $pt_0;label = 17; break; } else { label = 8; break; }
  case 8: 
   var $30=((($storemerge)*(3))&-1);
   var $31=(($pts+($30<<2))|0);
   var $32=HEAPF32[(($19)>>2)];
   var $33=HEAPF32[(($17)>>2)];
   var $34=($32)-($33);
   var $35=HEAPF32[(($20)>>2)];
   var $36=HEAPF32[(($21)>>2)];
   var $37=($35)-($36);
   var $38=HEAPF32[(($31)>>2)];
   var $39=($38)-($33);
   var $_sum287=((($30)+(2))|0);
   var $40=(($pts+($_sum287<<2))|0);
   var $41=HEAPF32[(($40)>>2)];
   var $42=($41)-($36);
   var $43=($34)*($42);
   var $44=($37)*($39);
   var $45=($43)-($44);
   var $46=$45 > 0.000009999999747378752;
   if ($46) { label = 9; break; } else { var $pt_1 = $pt_0;label = 17; break; }
  case 9: 
   var $48=HEAPF32[(($r)>>2)];
   var $49=$48 < 0;
   if ($49) { label = 10; break; } else { label = 11; break; }
  case 10: 
   __ZL12circumCirclePKfS0_S0_PfRf($17, $19, $31, $22, $r);
   var $pt_1 = $storemerge;label = 17; break;
  case 11: 
   var $52=HEAPF32[(($22)>>2)];
   var $53=($38)-($52);
   var $54=HEAPF32[(($23)>>2)];
   var $55=($41)-($54);
   var $56=($53)*($53);
   var $57=($55)*($55);
   var $58=($56)+($57);
   var $59=Math.sqrt($58);
   var $60=($48)*(1.0010000467300415);
   var $61=$59 > $60;
   if ($61) { var $pt_1 = $pt_0;label = 17; break; } else { label = 12; break; }
  case 12: 
   var $63=($48)*(0.9990000128746033);
   var $64=$59 < $63;
   if ($64) { label = 13; break; } else { label = 14; break; }
  case 13: 
   __ZL12circumCirclePKfS0_S0_PfRf($17, $19, $31, $22, $r);
   var $pt_1 = $storemerge;label = 17; break;
  case 14: 
   var $67=HEAP32[(($nedges)>>2)];
   var $68=__ZL12overlapEdgesPKfPKiiii($pts, $edges, $67, $s_0, $storemerge);
   if ($68) { var $pt_1 = $pt_0;label = 17; break; } else { label = 15; break; }
  case 15: 
   var $70=__ZL12overlapEdgesPKfPKiiii($pts, $edges, $67, $t_0, $storemerge);
   if ($70) { var $pt_1 = $pt_0;label = 17; break; } else { label = 16; break; }
  case 16: 
   __ZL12circumCirclePKfS0_S0_PfRf($17, $19, $31, $22, $r);
   var $pt_1 = $storemerge;label = 17; break;
  case 17: 
   var $pt_1;
   var $73=((($storemerge)+(1))|0);
   var $storemerge = $73;var $pt_0 = $pt_1;label = 6; break;
  case 18: 
   var $75=(($pt_0)|(0)) < (($npts)|(0));
   if ($75) { label = 19; break; } else { label = 56; break; }
  case 19: 
   var $77=HEAP32[(($nfaces)>>2)];
   var $78=HEAP32[(($2)>>2)];
   var $79=(($78)|(0))==(($s_0)|(0));
   var $_sum283284=$1 | 1;
   var $80=(($edges+($_sum283284<<2))|0);
   var $81=HEAP32[(($80)>>2)];
   var $82=(($81)|(0))==(($t_0)|(0));
   var $or_cond290=$79 & $82;
   if ($or_cond290) { label = 20; break; } else { var $88 = $81;label = 22; break; }
  case 20: 
   var $_sum285286=$1 | 2;
   var $84=(($edges+($_sum285286<<2))|0);
   var $85=HEAP32[(($84)>>2)];
   var $86=(($85)|(0))==-1;
   if ($86) { label = 21; break; } else { var $88 = $t_0;label = 22; break; }
  case 21: 
   HEAP32[(($84)>>2)]=$77;
   label = 25; break;
  case 22: 
   var $88;
   var $89=(($88)|(0))==(($s_0)|(0));
   var $90=(($78)|(0))==(($t_0)|(0));
   var $or_cond291=$89 & $90;
   if ($or_cond291) { label = 23; break; } else { label = 25; break; }
  case 23: 
   var $_sum281282=$1 | 3;
   var $92=(($edges+($_sum281282<<2))|0);
   var $93=HEAP32[(($92)>>2)];
   var $94=(($93)|(0))==-1;
   if ($94) { label = 24; break; } else { label = 25; break; }
  case 24: 
   HEAP32[(($92)>>2)]=$77;
   label = 25; break;
  case 25: 
   var $96=HEAP32[(($nedges)>>2)];
   var $storemerge_i7 = 0;label = 26; break;
  case 26: 
   var $storemerge_i7;
   var $98=(($storemerge_i7)|(0)) < (($96)|(0));
   if ($98) { label = 27; break; } else { label = 33; break; }
  case 27: 
   var $100=$storemerge_i7 << 2;
   var $101=(($edges+($100<<2))|0);
   var $102=HEAP32[(($101)>>2)];
   var $103=(($102)|(0))==(($pt_0)|(0));
   if ($103) { label = 28; break; } else { label = 29; break; }
  case 28: 
   var $_sum279280=$100 | 1;
   var $105=(($edges+($_sum279280<<2))|0);
   var $106=HEAP32[(($105)>>2)];
   var $107=(($106)|(0))==(($s_0)|(0));
   if ($107) { var $storemerge1_i8 = $storemerge_i7;label = 32; break; } else { label = 29; break; }
  case 29: 
   var $109=(($102)|(0))==(($s_0)|(0));
   if ($109) { label = 30; break; } else { label = 31; break; }
  case 30: 
   var $_sum277278=$100 | 1;
   var $111=(($edges+($_sum277278<<2))|0);
   var $112=HEAP32[(($111)>>2)];
   var $113=(($112)|(0))==(($pt_0)|(0));
   if ($113) { var $storemerge1_i8 = $storemerge_i7;label = 32; break; } else { label = 31; break; }
  case 31: 
   var $115=((($storemerge_i7)+(1))|0);
   var $storemerge_i7 = $115;label = 26; break;
  case 32: 
   var $storemerge1_i8;
   var $116=(($storemerge1_i8)|(0))==-1;
   if ($116) { label = 33; break; } else { label = 34; break; }
  case 33: 
   var $117=HEAP32[(($nfaces)>>2)];
   __ZL7addEdgeP9rcContextPiRiiiiii($ctx, $edges, $nedges, $maxEdges, $pt_0, $s_0, $117);
   label = 40; break;
  case 34: 
   var $119=$storemerge1_i8 << 2;
   var $120=(($edges+($119<<2))|0);
   var $121=HEAP32[(($nfaces)>>2)];
   var $122=HEAP32[(($120)>>2)];
   var $123=(($122)|(0))==(($pt_0)|(0));
   var $_sum273274=$119 | 1;
   var $124=(($edges+($_sum273274<<2))|0);
   var $125=HEAP32[(($124)>>2)];
   var $126=(($125)|(0))==(($s_0)|(0));
   var $or_cond292=$123 & $126;
   if ($or_cond292) { label = 35; break; } else { var $132 = $125;label = 37; break; }
  case 35: 
   var $_sum275276=$119 | 2;
   var $128=(($edges+($_sum275276<<2))|0);
   var $129=HEAP32[(($128)>>2)];
   var $130=(($129)|(0))==-1;
   if ($130) { label = 36; break; } else { var $132 = $s_0;label = 37; break; }
  case 36: 
   HEAP32[(($128)>>2)]=$121;
   label = 40; break;
  case 37: 
   var $132;
   var $133=(($132)|(0))==(($pt_0)|(0));
   var $134=(($122)|(0))==(($s_0)|(0));
   var $or_cond293=$133 & $134;
   if ($or_cond293) { label = 38; break; } else { label = 40; break; }
  case 38: 
   var $_sum271272=$119 | 3;
   var $136=(($edges+($_sum271272<<2))|0);
   var $137=HEAP32[(($136)>>2)];
   var $138=(($137)|(0))==-1;
   if ($138) { label = 39; break; } else { label = 40; break; }
  case 39: 
   HEAP32[(($136)>>2)]=$121;
   label = 40; break;
  case 40: 
   var $140=HEAP32[(($nedges)>>2)];
   var $storemerge_i = 0;label = 41; break;
  case 41: 
   var $storemerge_i;
   var $142=(($storemerge_i)|(0)) < (($140)|(0));
   if ($142) { label = 42; break; } else { label = 48; break; }
  case 42: 
   var $144=$storemerge_i << 2;
   var $145=(($edges+($144<<2))|0);
   var $146=HEAP32[(($145)>>2)];
   var $147=(($146)|(0))==(($t_0)|(0));
   if ($147) { label = 43; break; } else { label = 44; break; }
  case 43: 
   var $_sum269270=$144 | 1;
   var $149=(($edges+($_sum269270<<2))|0);
   var $150=HEAP32[(($149)>>2)];
   var $151=(($150)|(0))==(($pt_0)|(0));
   if ($151) { var $storemerge1_i = $storemerge_i;label = 47; break; } else { label = 44; break; }
  case 44: 
   var $153=(($146)|(0))==(($pt_0)|(0));
   if ($153) { label = 45; break; } else { label = 46; break; }
  case 45: 
   var $_sum267268=$144 | 1;
   var $155=(($edges+($_sum267268<<2))|0);
   var $156=HEAP32[(($155)>>2)];
   var $157=(($156)|(0))==(($t_0)|(0));
   if ($157) { var $storemerge1_i = $storemerge_i;label = 47; break; } else { label = 46; break; }
  case 46: 
   var $159=((($storemerge_i)+(1))|0);
   var $storemerge_i = $159;label = 41; break;
  case 47: 
   var $storemerge1_i;
   var $160=(($storemerge1_i)|(0))==-1;
   if ($160) { label = 48; break; } else { label = 49; break; }
  case 48: 
   var $161=HEAP32[(($nfaces)>>2)];
   __ZL7addEdgeP9rcContextPiRiiiiii($ctx, $edges, $nedges, $maxEdges, $t_0, $pt_0, $161);
   label = 55; break;
  case 49: 
   var $163=$storemerge1_i << 2;
   var $164=(($edges+($163<<2))|0);
   var $165=HEAP32[(($nfaces)>>2)];
   var $166=HEAP32[(($164)>>2)];
   var $167=(($166)|(0))==(($t_0)|(0));
   var $_sum263264=$163 | 1;
   var $168=(($edges+($_sum263264<<2))|0);
   var $169=HEAP32[(($168)>>2)];
   var $170=(($169)|(0))==(($pt_0)|(0));
   var $or_cond294=$167 & $170;
   if ($or_cond294) { label = 50; break; } else { var $176 = $169;label = 52; break; }
  case 50: 
   var $_sum265266=$163 | 2;
   var $172=(($edges+($_sum265266<<2))|0);
   var $173=HEAP32[(($172)>>2)];
   var $174=(($173)|(0))==-1;
   if ($174) { label = 51; break; } else { var $176 = $pt_0;label = 52; break; }
  case 51: 
   HEAP32[(($172)>>2)]=$165;
   label = 55; break;
  case 52: 
   var $176;
   var $177=(($176)|(0))==(($t_0)|(0));
   var $178=(($166)|(0))==(($pt_0)|(0));
   var $or_cond295=$177 & $178;
   if ($or_cond295) { label = 53; break; } else { label = 55; break; }
  case 53: 
   var $_sum261262=$163 | 3;
   var $180=(($edges+($_sum261262<<2))|0);
   var $181=HEAP32[(($180)>>2)];
   var $182=(($181)|(0))==-1;
   if ($182) { label = 54; break; } else { label = 55; break; }
  case 54: 
   HEAP32[(($180)>>2)]=$165;
   label = 55; break;
  case 55: 
   var $184=HEAP32[(($nfaces)>>2)];
   var $185=((($184)+(1))|0);
   HEAP32[(($nfaces)>>2)]=$185;
   label = 62; break;
  case 56: 
   var $187=HEAP32[(($2)>>2)];
   var $188=(($187)|(0))==(($s_0)|(0));
   var $_sum251252=$1 | 1;
   var $189=(($edges+($_sum251252<<2))|0);
   var $190=HEAP32[(($189)>>2)];
   var $191=(($190)|(0))==(($t_0)|(0));
   var $or_cond296=$188 & $191;
   if ($or_cond296) { label = 57; break; } else { var $197 = $190;label = 59; break; }
  case 57: 
   var $_sum253254=$1 | 2;
   var $193=(($edges+($_sum253254<<2))|0);
   var $194=HEAP32[(($193)>>2)];
   var $195=(($194)|(0))==-1;
   if ($195) { label = 58; break; } else { var $197 = $t_0;label = 59; break; }
  case 58: 
   HEAP32[(($193)>>2)]=-2;
   label = 62; break;
  case 59: 
   var $197;
   var $198=(($197)|(0))==(($s_0)|(0));
   var $199=(($187)|(0))==(($t_0)|(0));
   var $or_cond297=$198 & $199;
   if ($or_cond297) { label = 60; break; } else { label = 62; break; }
  case 60: 
   var $_sum249250=$1 | 3;
   var $201=(($edges+($_sum249250<<2))|0);
   var $202=HEAP32[(($201)>>2)];
   var $203=(($202)|(0))==-1;
   if ($203) { label = 61; break; } else { label = 62; break; }
  case 61: 
   HEAP32[(($201)>>2)]=-2;
   label = 62; break;
  case 62: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12overlapEdgesPKfPKiiii($pts, $edges, $nedges, $s1, $t1) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=((($s1)*(3))&-1);
   var $2=(($pts+($1<<2))|0);
   var $3=((($t1)*(3))&-1);
   var $4=(($pts+($3<<2))|0);
   var $_sum61=((($3)+(2))|0);
   var $5=(($pts+($_sum61<<2))|0);
   var $_sum62=((($1)+(2))|0);
   var $6=(($pts+($_sum62<<2))|0);
   var $storemerge = 0;label = 2; break;
  case 2: 
   var $storemerge;
   var $8=(($storemerge)|(0)) < (($nedges)|(0));
   if ($8) { label = 3; break; } else { var $storemerge1 = 0;label = 7; break; }
  case 3: 
   var $10=$storemerge << 2;
   var $11=(($edges+($10<<2))|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=$10 | 1;
   var $14=(($edges+($13<<2))|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=(($12)|(0))==(($s1)|(0));
   var $17=(($12)|(0))==(($t1)|(0));
   var $or_cond=$16 | $17;
   var $18=(($15)|(0))==(($s1)|(0));
   var $or_cond64=$or_cond | $18;
   var $19=(($15)|(0))==(($t1)|(0));
   var $or_cond65=$or_cond64 | $19;
   if ($or_cond65) { label = 6; break; } else { label = 4; break; }
  case 4: 
   var $21=((($12)*(3))&-1);
   var $22=(($pts+($21<<2))|0);
   var $23=((($15)*(3))&-1);
   var $24=(($pts+($23<<2))|0);
   var $25=HEAPF32[(($24)>>2)];
   var $26=HEAPF32[(($22)>>2)];
   var $27=($25)-($26);
   var $_sum=((($23)+(2))|0);
   var $28=(($pts+($_sum<<2))|0);
   var $29=HEAPF32[(($28)>>2)];
   var $_sum63=((($21)+(2))|0);
   var $30=(($pts+($_sum63<<2))|0);
   var $31=HEAPF32[(($30)>>2)];
   var $32=($29)-($31);
   var $33=HEAPF32[(($4)>>2)];
   var $34=($33)-($26);
   var $35=HEAPF32[(($5)>>2)];
   var $36=($35)-($31);
   var $37=($27)*($36);
   var $38=($32)*($34);
   var $39=($37)-($38);
   var $40=HEAPF32[(($2)>>2)];
   var $41=($40)-($26);
   var $42=HEAPF32[(($6)>>2)];
   var $43=($42)-($31);
   var $44=($27)*($43);
   var $45=($32)*($41);
   var $46=($44)-($45);
   var $47=($39)*($46);
   var $48=$47 < 0;
   if ($48) { label = 5; break; } else { label = 6; break; }
  case 5: 
   var $50=($33)-($40);
   var $51=($35)-($42);
   var $52=($26)-($40);
   var $53=($31)-($42);
   var $54=($50)*($53);
   var $55=($51)*($52);
   var $56=($54)-($55);
   var $57=($56)+($46);
   var $58=($57)-($39);
   var $59=($56)*($58);
   var $60=$59 < 0;
   if ($60) { var $storemerge1 = 1;label = 7; break; } else { label = 6; break; }
  case 6: 
   var $61=((($storemerge)+(1))|0);
   var $storemerge = $61;label = 2; break;
  case 7: 
   var $storemerge1;
   return $storemerge1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL8clipPolyPKfiPffff($in, $n, $out, $pnx, $pnz, $pd) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 48)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $d=sp;
   var $storemerge = 0;label = 2; break;
  case 2: 
   var $storemerge;
   var $2=(($storemerge)|(0)) < (($n)|(0));
   if ($2) { label = 3; break; } else { label = 4; break; }
  case 3: 
   var $4=((($storemerge)*(3))&-1);
   var $5=(($in+($4<<2))|0);
   var $6=HEAPF32[(($5)>>2)];
   var $7=($6)*($pnx);
   var $8=((($4)+(2))|0);
   var $9=(($in+($8<<2))|0);
   var $10=HEAPF32[(($9)>>2)];
   var $11=($10)*($pnz);
   var $12=($7)+($11);
   var $13=($12)+($pd);
   var $14=(($d+($storemerge<<2))|0);
   HEAPF32[(($14)>>2)]=$13;
   var $15=((($storemerge)+(1))|0);
   var $storemerge = $15;label = 2; break;
  case 4: 
   var $17=((($n)-(1))|0);
   var $m_0 = 0;var $i1_0 = 0;var $j_0 = $17;label = 5; break;
  case 5: 
   var $j_0;
   var $i1_0;
   var $m_0;
   var $19=(($i1_0)|(0)) < (($n)|(0));
   if ($19) { label = 6; break; } else { label = 11; break; }
  case 6: 
   var $21=(($d+($j_0<<2))|0);
   var $22=HEAPF32[(($21)>>2)];
   var $23=$22 >= 0;
   var $24=(($d+($i1_0<<2))|0);
   var $25=HEAPF32[(($24)>>2)];
   var $26=$25 >= 0;
   var $tmp=$23 ^ $26;
   if ($tmp) { label = 7; break; } else { var $m_1 = $m_0;label = 8; break; }
  case 7: 
   var $28=($22)-($25);
   var $29=($22)/($28);
   var $30=((($j_0)*(3))&-1);
   var $31=(($in+($30<<2))|0);
   var $32=HEAPF32[(($31)>>2)];
   var $33=((($i1_0)*(3))&-1);
   var $34=(($in+($33<<2))|0);
   var $35=HEAPF32[(($34)>>2)];
   var $36=($35)-($32);
   var $37=($36)*($29);
   var $38=($32)+($37);
   var $39=((($m_0)*(3))&-1);
   var $40=(($out+($39<<2))|0);
   HEAPF32[(($40)>>2)]=$38;
   var $41=((($30)+(1))|0);
   var $42=(($in+($41<<2))|0);
   var $43=HEAPF32[(($42)>>2)];
   var $44=((($33)+(1))|0);
   var $45=(($in+($44<<2))|0);
   var $46=HEAPF32[(($45)>>2)];
   var $47=($46)-($43);
   var $48=($47)*($29);
   var $49=($43)+($48);
   var $50=((($39)+(1))|0);
   var $51=(($out+($50<<2))|0);
   HEAPF32[(($51)>>2)]=$49;
   var $52=((($30)+(2))|0);
   var $53=(($in+($52<<2))|0);
   var $54=HEAPF32[(($53)>>2)];
   var $55=((($33)+(2))|0);
   var $56=(($in+($55<<2))|0);
   var $57=HEAPF32[(($56)>>2)];
   var $58=($57)-($54);
   var $59=($58)*($29);
   var $60=($54)+($59);
   var $61=((($39)+(2))|0);
   var $62=(($out+($61<<2))|0);
   HEAPF32[(($62)>>2)]=$60;
   var $63=((($m_0)+(1))|0);
   var $m_1 = $63;label = 8; break;
  case 8: 
   var $m_1;
   if ($26) { label = 9; break; } else { var $m_2 = $m_1;label = 10; break; }
  case 9: 
   var $66=((($i1_0)*(3))&-1);
   var $67=(($in+($66<<2))|0);
   var $68=HEAPF32[(($67)>>2)];
   var $69=((($m_1)*(3))&-1);
   var $70=(($out+($69<<2))|0);
   HEAPF32[(($70)>>2)]=$68;
   var $71=((($66)+(1))|0);
   var $72=(($in+($71<<2))|0);
   var $73=HEAPF32[(($72)>>2)];
   var $74=((($69)+(1))|0);
   var $75=(($out+($74<<2))|0);
   HEAPF32[(($75)>>2)]=$73;
   var $76=((($66)+(2))|0);
   var $77=(($in+($76<<2))|0);
   var $78=HEAPF32[(($77)>>2)];
   var $79=((($69)+(2))|0);
   var $80=(($out+($79<<2))|0);
   HEAPF32[(($80)>>2)]=$78;
   var $81=((($m_1)+(1))|0);
   var $m_2 = $81;label = 10; break;
  case 10: 
   var $m_2;
   var $83=((($i1_0)+(1))|0);
   var $m_0 = $m_2;var $j_0 = $i1_0;var $i1_0 = $83;label = 5; break;
  case 11: 
   STACKTOP = sp;
   return $m_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12circumCirclePKfS0_S0_PfRf($p1, $p2, $p3, $c, $r) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAPF32[(($p2)>>2)];
   var $2=HEAPF32[(($p1)>>2)];
   var $3=($1)-($2);
   var $4=(($p2+8)|0);
   var $5=HEAPF32[(($4)>>2)];
   var $6=(($p1+8)|0);
   var $7=HEAPF32[(($6)>>2)];
   var $8=($5)-($7);
   var $9=HEAPF32[(($p3)>>2)];
   var $10=($9)-($2);
   var $11=(($p3+8)|0);
   var $12=HEAPF32[(($11)>>2)];
   var $13=($12)-($7);
   var $14=($3)*($13);
   var $15=($8)*($10);
   var $16=($14)-($15);
   var $17=Math.abs($16);
   var $18=$17 > 9.999999974752427e-7;
   if ($18) { label = 2; break; } else { label = 3; break; }
  case 2: 
   var $20=($2)*($2);
   var $21=($7)*($7);
   var $22=($20)+($21);
   var $23=($1)*($1);
   var $24=($5)*($5);
   var $25=($23)+($24);
   var $26=($9)*($9);
   var $27=($12)*($12);
   var $28=($26)+($27);
   var $29=($5)-($12);
   var $30=($22)*($29);
   var $31=($25)*($13);
   var $32=($30)+($31);
   var $33=($7)-($5);
   var $34=($28)*($33);
   var $35=($32)+($34);
   var $36=($16)*(2);
   var $37=($35)/($36);
   HEAPF32[(($c)>>2)]=$37;
   var $38=HEAPF32[(($p3)>>2)];
   var $39=HEAPF32[(($p2)>>2)];
   var $40=($38)-($39);
   var $41=($22)*($40);
   var $42=HEAPF32[(($p1)>>2)];
   var $43=($42)-($38);
   var $44=($25)*($43);
   var $45=($41)+($44);
   var $46=($39)-($42);
   var $47=($28)*($46);
   var $48=($45)+($47);
   var $49=($48)/($36);
   var $50=(($c+8)|0);
   HEAPF32[(($50)>>2)]=$49;
   var $51=HEAPF32[(($p1)>>2)];
   var $52=($51)-($37);
   var $53=HEAPF32[(($6)>>2)];
   var $54=($53)-($49);
   var $55=($52)*($52);
   var $56=($54)*($54);
   var $57=($55)+($56);
   var $58=Math.sqrt($57);
   var $storemerge = $58;label = 4; break;
  case 3: 
   HEAPF32[(($c)>>2)]=$2;
   var $60=HEAPF32[(($6)>>2)];
   var $61=(($c+8)|0);
   HEAPF32[(($61)>>2)]=$60;
   var $storemerge = 0;label = 4; break;
  case 4: 
   var $storemerge;
   HEAPF32[(($r)>>2)]=$storemerge;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z20rcRasterizeTrianglesP9rcContextPKfiPKiPKhiR13rcHeightfieldi($ctx, $verts, $0, $tris, $areas, $nt, $solid, $flagMergeThr) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 264)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $in_i=sp;
   var $out_i=(sp)+(88);
   var $inrow_i=(sp)+(176);
   var $2=(($ctx+5)|0);
   var $3=HEAP8[($2)];
   var $4=$3 & 1;
   var $5=(($4 << 24) >> 24)==0;
   if ($5) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $7=$ctx;
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8+20)|0);
   var $10=HEAP32[(($9)>>2)];
   FUNCTION_TABLE[$10]($ctx, 2);
   label = 3; break;
  case 3: 
   var $11=(($solid+32)|0);
   var $12=HEAPF32[(($11)>>2)];
   var $13=(1)/($12);
   var $14=(($solid+36)|0);
   var $15=HEAPF32[(($14)>>2)];
   var $16=(1)/($15);
   var $17=(($solid+8)|0);
   var $18=(($solid+20)|0);
   var $19=$in_i;
   var $20=$out_i;
   var $21=$inrow_i;
   var $22=(($solid)|0);
   var $23=(($solid+4)|0);
   var $24=(($solid+24)|0);
   var $25=(($solid+12)|0);
   var $26=(($solid+16)|0);
   var $27=(($in_i)|0);
   var $28=(($in_i+4)|0);
   var $29=(($in_i+8)|0);
   var $30=(($in_i+12)|0);
   var $31=(($in_i+16)|0);
   var $32=(($in_i+20)|0);
   var $33=(($in_i+24)|0);
   var $34=(($in_i+28)|0);
   var $35=(($in_i+32)|0);
   var $36=(($out_i)|0);
   var $37=(($inrow_i)|0);
   var $38=(($in_i+4)|0);
   var $39=(($solid+48)|0);
   var $40=(($solid+44)|0);
   var $41=(($solid+40)|0);
   var $42=(($solid+28)|0);
   var $storemerge = 0;label = 4; break;
  case 4: 
   var $storemerge;
   var $44=(($storemerge)|(0)) < (($nt)|(0));
   if ($44) { label = 5; break; } else { label = 64; break; }
  case 5: 
   var $46=((($storemerge)*(3))&-1);
   var $47=(($tris+($46<<2))|0);
   var $48=HEAP32[(($47)>>2)];
   var $49=((($48)*(3))&-1);
   var $50=(($verts+($49<<2))|0);
   var $51=((($46)+(1))|0);
   var $52=(($tris+($51<<2))|0);
   var $53=HEAP32[(($52)>>2)];
   var $54=((($53)*(3))&-1);
   var $55=(($verts+($54<<2))|0);
   var $56=((($46)+(2))|0);
   var $57=(($tris+($56<<2))|0);
   var $58=HEAP32[(($57)>>2)];
   var $59=((($58)*(3))&-1);
   var $60=(($verts+($59<<2))|0);
   var $61=(($areas+$storemerge)|0);
   var $62=HEAP8[($61)];
   var $63=HEAPF32[(($11)>>2)];
   var $64=HEAP32[(($22)>>2)];
   var $65=HEAP32[(($23)>>2)];
   var $66=HEAPF32[(($24)>>2)];
   var $67=HEAPF32[(($25)>>2)];
   var $68=($66)-($67);
   var $69=HEAPF32[(($50)>>2)];
   var $_sum=((($49)+(1))|0);
   var $70=(($verts+($_sum<<2))|0);
   var $71=HEAPF32[(($70)>>2)];
   var $_sum396=((($49)+(2))|0);
   var $72=(($verts+($_sum396<<2))|0);
   var $73=HEAPF32[(($72)>>2)];
   var $74=HEAPF32[(($55)>>2)];
   var $75=$69 < $74;
   var $76=$75 ? $69 : $74;
   var $_sum397=((($54)+(1))|0);
   var $77=(($verts+($_sum397<<2))|0);
   var $78=HEAPF32[(($77)>>2)];
   var $79=$71 < $78;
   var $80=$79 ? $71 : $78;
   var $_sum398=((($54)+(2))|0);
   var $81=(($verts+($_sum398<<2))|0);
   var $82=HEAPF32[(($81)>>2)];
   var $83=$73 < $82;
   var $84=$83 ? $73 : $82;
   var $85=HEAPF32[(($60)>>2)];
   var $86=$76 < $85;
   var $87=$86 ? $76 : $85;
   var $_sum399=((($59)+(1))|0);
   var $88=(($verts+($_sum399<<2))|0);
   var $89=HEAPF32[(($88)>>2)];
   var $90=$80 < $89;
   var $91=$90 ? $80 : $89;
   var $_sum400=((($59)+(2))|0);
   var $92=(($verts+($_sum400<<2))|0);
   var $93=HEAPF32[(($92)>>2)];
   var $94=$84 < $93;
   var $95=$94 ? $84 : $93;
   var $96=$69 > $74;
   var $97=$96 ? $69 : $74;
   var $98=$71 > $78;
   var $99=$98 ? $71 : $78;
   var $100=$73 > $82;
   var $101=$100 ? $73 : $82;
   var $102=$97 > $85;
   var $103=$102 ? $97 : $85;
   var $104=$99 > $89;
   var $105=$104 ? $99 : $89;
   var $106=$101 > $93;
   var $107=$106 ? $101 : $93;
   var $108=HEAPF32[(($17)>>2)];
   var $109=$108 > $103;
   if ($109) { var $114 = 0;label = 8; break; } else { label = 6; break; }
  case 6: 
   var $111=HEAPF32[(($18)>>2)];
   var $112=$111 < $87;
   if ($112) { var $114 = 0;label = 8; break; } else { label = 7; break; }
  case 7: 
   var $114 = 1;label = 8; break;
  case 8: 
   var $114;
   var $115=$67 > $105;
   var $116=$66 < $91;
   var $or_cond=$115 | $116;
   var $117=$or_cond ? 0 : $114;
   var $118=HEAPF32[(($26)>>2)];
   var $119=$118 > $107;
   if ($119) { label = 63; break; } else { label = 9; break; }
  case 9: 
   var $121=HEAPF32[(($42)>>2)];
   var $122=$121 < $95;
   if ($122) { label = 63; break; } else { label = 10; break; }
  case 10: 
   var $123=$117 & 1;
   var $phitmp=(($123 << 24) >> 24)==0;
   if ($phitmp) { label = 63; break; } else { label = 11; break; }
  case 11: 
   var $125=($87)-($108);
   var $126=($125)*($13);
   var $127=(($126)&-1);
   var $128=($95)-($118);
   var $129=($128)*($13);
   var $130=(($129)&-1);
   var $131=($103)-($108);
   var $132=($131)*($13);
   var $133=(($132)&-1);
   var $134=($107)-($118);
   var $135=($134)*($13);
   var $136=(($135)&-1);
   var $137=((($64)-(1))|0);
   var $138=(($127)|(0)) < 0;
   if ($138) { var $142 = 0;label = 13; break; } else { label = 12; break; }
  case 12: 
   var $140=(($127)|(0)) > (($137)|(0));
   var $141=$140 ? $137 : $127;
   var $142 = $141;label = 13; break;
  case 13: 
   var $142;
   var $143=((($65)-(1))|0);
   var $144=(($130)|(0)) < 0;
   if ($144) { var $148 = 0;label = 15; break; } else { label = 14; break; }
  case 14: 
   var $146=(($130)|(0)) > (($143)|(0));
   var $147=$146 ? $143 : $130;
   var $148 = $147;label = 15; break;
  case 15: 
   var $148;
   var $149=(($133)|(0)) < 0;
   if ($149) { var $153 = 0;label = 17; break; } else { label = 16; break; }
  case 16: 
   var $151=(($133)|(0)) > (($137)|(0));
   var $152=$151 ? $137 : $133;
   var $153 = $152;label = 17; break;
  case 17: 
   var $153;
   var $154=(($136)|(0)) < 0;
   if ($154) { var $158 = 0;label = 19; break; } else { label = 18; break; }
  case 18: 
   var $156=(($136)|(0)) > (($143)|(0));
   var $157=$156 ? $143 : $136;
   var $158 = $157;label = 19; break;
  case 19: 
   var $158;
   var $159=(($62)&(255));
   var $160=$159 << 26;
   var $storemerge_i = $148;label = 20; break;
  case 20: 
   var $storemerge_i;
   var $162=(($storemerge_i)|(0)) > (($158)|(0));
   if ($162) { label = 63; break; } else { label = 21; break; }
  case 21: 
   var $164=HEAPF32[(($50)>>2)];
   HEAPF32[(($27)>>2)]=$164;
   var $165=HEAPF32[(($70)>>2)];
   HEAPF32[(($28)>>2)]=$165;
   var $166=HEAPF32[(($72)>>2)];
   HEAPF32[(($29)>>2)]=$166;
   var $167=HEAPF32[(($55)>>2)];
   HEAPF32[(($30)>>2)]=$167;
   var $168=HEAPF32[(($77)>>2)];
   HEAPF32[(($31)>>2)]=$168;
   var $169=HEAPF32[(($81)>>2)];
   HEAPF32[(($32)>>2)]=$169;
   var $170=HEAPF32[(($60)>>2)];
   HEAPF32[(($33)>>2)]=$170;
   var $171=HEAPF32[(($88)>>2)];
   HEAPF32[(($34)>>2)]=$171;
   var $172=HEAPF32[(($92)>>2)];
   HEAPF32[(($35)>>2)]=$172;
   var $173=HEAPF32[(($26)>>2)];
   var $174=(($storemerge_i)|(0));
   var $175=($174)*($63);
   var $176=($173)+($175);
   var $177=(-$176);
   var $178=__ZL8clipPolyPKfiPffff($27, 3, $36, 0, 1, $177);
   var $179=(($178)|(0)) < 3;
   if ($179) { label = 62; break; } else { label = 22; break; }
  case 22: 
   var $181=($176)+($63);
   var $182=__ZL8clipPolyPKfiPffff($36, $178, $37, 0, -1, $181);
   var $183=(($182)|(0)) < 3;
   if ($183) { label = 62; break; } else { var $storemerge1_i = $142;label = 23; break; }
  case 23: 
   var $storemerge1_i;
   var $185=(($storemerge1_i)|(0)) > (($153)|(0));
   if ($185) { label = 62; break; } else { label = 24; break; }
  case 24: 
   var $187=HEAPF32[(($17)>>2)];
   var $188=(($storemerge1_i)|(0));
   var $189=($188)*($63);
   var $190=($187)+($189);
   var $191=(-$190);
   var $192=__ZL8clipPolyPKfiPffff($37, $182, $36, 1, 0, $191);
   var $193=(($192)|(0)) < 3;
   if ($193) { label = 61; break; } else { label = 25; break; }
  case 25: 
   var $195=($190)+($63);
   var $196=__ZL8clipPolyPKfiPffff($36, $192, $27, -1, 0, $195);
   var $197=(($196)|(0)) < 3;
   if ($197) { label = 61; break; } else { label = 26; break; }
  case 26: 
   var $199=HEAPF32[(($38)>>2)];
   var $storemerge2_i = 1;var $smin_i_0 = $199;var $smax_i_0 = $199;label = 27; break;
  case 27: 
   var $smax_i_0;
   var $smin_i_0;
   var $storemerge2_i;
   var $201=(($storemerge2_i)|(0)) < (($196)|(0));
   if ($201) { label = 28; break; } else { label = 29; break; }
  case 28: 
   var $203=((($storemerge2_i)*(3))&-1);
   var $204=((($203)+(1))|0);
   var $205=(($in_i+($204<<2))|0);
   var $206=HEAPF32[(($205)>>2)];
   var $207=$smin_i_0 < $206;
   var $208=$207 ? $smin_i_0 : $206;
   var $209=$smax_i_0 > $206;
   var $210=$209 ? $smax_i_0 : $206;
   var $211=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $211;var $smin_i_0 = $208;var $smax_i_0 = $210;label = 27; break;
  case 29: 
   var $213=HEAPF32[(($25)>>2)];
   var $214=($smin_i_0)-($213);
   var $215=($smax_i_0)-($213);
   var $216=$215 < 0;
   var $217=$214 > $68;
   var $or_cond402=$216 | $217;
   if ($or_cond402) { label = 61; break; } else { label = 30; break; }
  case 30: 
   var $219=$214 < 0;
   var $smin_i_1=$219 ? 0 : $214;
   var $220=$215 > $68;
   var $smax_i_1=$220 ? $68 : $215;
   var $221=($smin_i_1)*($16);
   var $222=Math.floor($221);
   var $223=(($222)&-1);
   var $224=(($223)|(0)) < 0;
   if ($224) { var $227 = 0;label = 32; break; } else { label = 31; break; }
  case 31: 
   var $226=(($223)|(0)) > 8191;
   var $_op=$223 & 65535;
   var $phitmp401=$226 ? 8191 : $_op;
   var $227 = $phitmp401;label = 32; break;
  case 32: 
   var $227;
   var $228=($smax_i_1)*($16);
   var $229=Math.ceil($228);
   var $230=(($229)&-1);
   var $231=((($227)+(1))|0);
   var $232=(($230)|(0)) < (($231)|(0));
   if ($232) { label = 33; break; } else { label = 34; break; }
  case 33: 
   var $extract_t=(($231) & 65535);
   var $_off0 = $extract_t;label = 35; break;
  case 34: 
   var $235=(($230)|(0)) > 8191;
   var $236=(($230) & 65535);
   var $extract_t1=$235 ? 8191 : $236;
   var $_off0 = $extract_t1;label = 35; break;
  case 35: 
   var $_off0;
   var $237=HEAP32[(($22)>>2)];
   var $238=(Math.imul($237,$storemerge_i)|0);
   var $239=((($238)+($storemerge1_i))|0);
   var $240=HEAP32[(($39)>>2)];
   var $241=(($240)|(0))==0;
   if ($241) { label = 37; break; } else { label = 36; break; }
  case 36: 
   var $243=(($240+4)|0);
   var $244=HEAP32[(($243)>>2)];
   var $245=(($244)|(0))==0;
   if ($245) { label = 37; break; } else { var $266 = $240;var $265 = $244;label = 41; break; }
  case 37: 
   var $247=_malloc(16388);
   var $248=(($247)|(0))==0;
   if ($248) { var $storemerge_i_i_i = 0;label = 42; break; } else { label = 38; break; }
  case 38: 
   var $250=$247;
   var $251=$247;
   HEAP32[(($251)>>2)]=0;
   var $252=HEAP32[(($40)>>2)];
   HEAP32[(($251)>>2)]=$252;
   HEAP32[(($40)>>2)]=$250;
   var $253=HEAP32[(($39)>>2)];
   var $254=(($247+4)|0);
   var $255=$254;
   var $256=(($247+16388)|0);
   var $257=$256;
   var $freelist_i_i_i_0 = $253;var $it_i_i_i_0 = $257;label = 39; break;
  case 39: 
   var $it_i_i_i_0;
   var $freelist_i_i_i_0;
   var $259=((($it_i_i_i_0)-(8))|0);
   var $260=((($it_i_i_i_0)-(8)+4)|0);
   HEAP32[(($260)>>2)]=$freelist_i_i_i_0;
   var $261=(($259)|(0))==(($255)|(0));
   if ($261) { label = 40; break; } else { var $freelist_i_i_i_0 = $259;var $it_i_i_i_0 = $259;label = 39; break; }
  case 40: 
   HEAP32[(($39)>>2)]=$255;
   var $_phi_trans_insert=(($247+8)|0);
   var $263=$_phi_trans_insert;
   var $_pre394=HEAP32[(($263)>>2)];
   var $266 = $255;var $265 = $_pre394;label = 41; break;
  case 41: 
   var $265;
   var $266;
   HEAP32[(($39)>>2)]=$265;
   var $storemerge_i_i_i = $266;label = 42; break;
  case 42: 
   var $storemerge_i_i_i;
   var $267=$storemerge_i_i_i;
   var $268=$227 & 8191;
   var $269=(($_off0)&(65535));
   var $270=$269 << 13;
   var $271=$270 & 67100672;
   var $272=$268 | $271;
   var $273=$272 | $160;
   HEAP32[(($267)>>2)]=$273;
   var $274=(($storemerge_i_i_i+4)|0);
   HEAP32[(($274)>>2)]=0;
   var $275=HEAP32[(($41)>>2)];
   var $276=(($275+($239<<2))|0);
   var $277=HEAP32[(($276)>>2)];
   var $278=(($277)|(0))==0;
   if ($278) { label = 43; break; } else { var $storemerge2_in_sroa_speculated_ph = $277;var $prev_i_i_0_ph = 0;label = 44; break; }
  case 43: 
   HEAP32[(($276)>>2)]=$storemerge_i_i_i;
   label = 61; break;
  case 44: 
   var $prev_i_i_0_ph;
   var $storemerge2_in_sroa_speculated_ph;
   var $280=(($prev_i_i_0_ph)|(0))==0;
   var $281=(($prev_i_i_0_ph+4)|0);
   var $storemerge2_in_sroa_speculated = $storemerge2_in_sroa_speculated_ph;label = 45; break;
  case 45: 
   var $storemerge2_in_sroa_speculated;
   var $282=(($storemerge2_in_sroa_speculated)|(0))==0;
   if ($282) { label = 58; break; } else { label = 46; break; }
  case 46: 
   var $284=$storemerge2_in_sroa_speculated;
   var $285=HEAP32[(($284)>>2)];
   var $286=$285 & 8191;
   var $287=HEAP32[(($267)>>2)];
   var $288=$287 >>> 13;
   var $289=$288 & 8191;
   var $290=(($286)>>>(0)) > (($289)>>>(0));
   if ($290) { label = 58; break; } else { label = 47; break; }
  case 47: 
   var $292=$285 >>> 13;
   var $293=$292 & 8191;
   var $294=$287 & 8191;
   var $295=(($293)>>>(0)) < (($294)>>>(0));
   if ($295) { label = 48; break; } else { label = 49; break; }
  case 48: 
   var $297=(($storemerge2_in_sroa_speculated+4)|0);
   var $storemerge2_in_sroa_speculate_load_125=HEAP32[(($297)>>2)];
   var $storemerge2_in_sroa_speculated_ph = $storemerge2_in_sroa_speculate_load_125;var $prev_i_i_0_ph = $storemerge2_in_sroa_speculated;label = 44; break;
  case 49: 
   var $299=(($286)>>>(0)) < (($294)>>>(0));
   if ($299) { label = 50; break; } else { var $305 = $285;var $304 = $287;label = 51; break; }
  case 50: 
   var $301=$287 & -8192;
   var $302=$301 | $286;
   HEAP32[(($267)>>2)]=$302;
   var $_pre=HEAP32[(($284)>>2)];
   var $305 = $_pre;var $304 = $302;label = 51; break;
  case 51: 
   var $304;
   var $305;
   var $306=$305 >>> 13;
   var $307=$306 & 8191;
   var $308=$304 >>> 13;
   var $309=$308 & 8191;
   var $310=(($307)>>>(0)) > (($309)>>>(0));
   if ($310) { label = 52; break; } else { var $316 = $304;var $315 = $305;label = 53; break; }
  case 52: 
   var $312=$305 & 67100672;
   var $313=$304 & -67100673;
   var $314=$313 | $312;
   HEAP32[(($267)>>2)]=$314;
   var $_pre393=HEAP32[(($284)>>2)];
   var $316 = $314;var $315 = $_pre393;label = 53; break;
  case 53: 
   var $315;
   var $316;
   var $317=$316 >>> 13;
   var $318=$317 & 8191;
   var $319=$315 >>> 13;
   var $320=$319 & 8191;
   var $321=((($318)-($320))|0);
   var $322=(($321)|(0)) < 0;
   var $323=(((-$321))|0);
   var $324=$322 ? $323 : $321;
   var $325=(($324)|(0)) > (($flagMergeThr)|(0));
   if ($325) { label = 55; break; } else { label = 54; break; }
  case 54: 
   var $327=$316 >>> 26;
   var $328=$315 >>> 26;
   var $329=(($327)>>>(0)) > (($328)>>>(0));
   var $330=$329 ? $327 : $328;
   var $331=$330 << 26;
   var $332=$316 & 67108863;
   var $333=$332 | $331;
   HEAP32[(($267)>>2)]=$333;
   label = 55; break;
  case 55: 
   var $334=(($storemerge2_in_sroa_speculated+4)|0);
   var $335=HEAP32[(($334)>>2)];
   var $336=HEAP32[(($39)>>2)];
   HEAP32[(($334)>>2)]=$336;
   HEAP32[(($39)>>2)]=$storemerge2_in_sroa_speculated;
   if ($280) { label = 57; break; } else { label = 56; break; }
  case 56: 
   HEAP32[(($281)>>2)]=$335;
   var $storemerge2_in_sroa_speculated = $335;label = 45; break;
  case 57: 
   var $339=HEAP32[(($41)>>2)];
   var $340=(($339+($239<<2))|0);
   HEAP32[(($340)>>2)]=$335;
   var $storemerge2_in_sroa_speculated = $335;label = 45; break;
  case 58: 
   if ($280) { label = 60; break; } else { label = 59; break; }
  case 59: 
   var $343=HEAP32[(($281)>>2)];
   HEAP32[(($274)>>2)]=$343;
   HEAP32[(($281)>>2)]=$storemerge_i_i_i;
   label = 61; break;
  case 60: 
   var $345=HEAP32[(($41)>>2)];
   var $346=(($345+($239<<2))|0);
   var $347=HEAP32[(($346)>>2)];
   HEAP32[(($274)>>2)]=$347;
   var $348=HEAP32[(($41)>>2)];
   var $349=(($348+($239<<2))|0);
   HEAP32[(($349)>>2)]=$storemerge_i_i_i;
   label = 61; break;
  case 61: 
   var $350=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $350;label = 23; break;
  case 62: 
   var $351=((($storemerge_i)+(1))|0);
   var $storemerge_i = $351;label = 20; break;
  case 63: 
   var $352=((($storemerge)+(1))|0);
   var $storemerge = $352;label = 4; break;
  case 64: 
   var $354=HEAP8[($2)];
   var $355=$354 & 1;
   var $356=(($355 << 24) >> 24)==0;
   if ($356) { label = 66; break; } else { label = 65; break; }
  case 65: 
   var $358=$ctx;
   var $359=HEAP32[(($358)>>2)];
   var $360=(($359+24)|0);
   var $361=HEAP32[(($360)>>2)];
   FUNCTION_TABLE[$361]($ctx, 2);
   label = 66; break;
  case 66: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL15paintRectRegioniiiitR20rcCompactHeightfieldPt($minx, $maxx, $miny, $maxy, $regId, $chf, $srcReg) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($chf)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($chf+60)|0);
   var $4=(($chf+72)|0);
   var $storemerge = $miny;label = 2; break;
  case 2: 
   var $storemerge;
   var $6=(($storemerge)|(0)) < (($maxy)|(0));
   if ($6) { label = 3; break; } else { label = 12; break; }
  case 3: 
   var $8=(Math.imul($storemerge,$2)|0);
   var $storemerge1 = $minx;label = 4; break;
  case 4: 
   var $storemerge1;
   var $10=(($storemerge1)|(0)) < (($maxx)|(0));
   if ($10) { label = 5; break; } else { label = 11; break; }
  case 5: 
   var $12=((($storemerge1)+($8))|0);
   var $13=HEAP32[(($3)>>2)];
   var $14=(($13+($12<<2))|0);
   var $15=$14;
   var $16=HEAP32[(($15)>>2)];
   var $17=$16 & 16777215;
   var $18=$16 >>> 24;
   var $19=((($17)+($18))|0);
   var $i_0 = $17;label = 6; break;
  case 6: 
   var $i_0;
   var $21=(($i_0)|(0)) < (($19)|(0));
   if ($21) { label = 7; break; } else { label = 10; break; }
  case 7: 
   var $23=HEAP32[(($4)>>2)];
   var $24=(($23+$i_0)|0);
   var $25=HEAP8[($24)];
   var $26=(($25 << 24) >> 24)==0;
   if ($26) { label = 9; break; } else { label = 8; break; }
  case 8: 
   var $28=(($srcReg+($i_0<<1))|0);
   HEAP16[(($28)>>1)]=$regId;
   label = 9; break;
  case 9: 
   var $30=((($i_0)+(1))|0);
   var $i_0 = $30;label = 6; break;
  case 10: 
   var $32=((($storemerge1)+(1))|0);
   var $storemerge1 = $32;label = 4; break;
  case 11: 
   var $34=((($storemerge)+(1))|0);
   var $storemerge = $34;label = 2; break;
  case 12: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z20rcBuildDistanceFieldP9rcContextR20rcCompactHeightfield($ctx, $chf) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 17);
   label = 3; break;
  case 3: 
   var $10=(($chf+68)|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($11)|(0))==0;
   if ($12) { label = 5; break; } else { label = 4; break; }
  case 4: 
   var $13=$11;
   _free($13);
   HEAP32[(($10)>>2)]=0;
   label = 5; break;
  case 5: 
   var $15=(($chf+8)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=$16 << 1;
   var $18=_malloc($17);
   var $19=$18;
   var $20=(($18)|(0))==0;
   var $21=HEAP32[(($15)>>2)];
   if ($20) { label = 6; break; } else { label = 7; break; }
  case 6: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((3680)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$21,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 101; break;
  case 7: 
   var $24=$21 << 1;
   var $25=_malloc($24);
   var $26=$25;
   var $27=(($25)|(0))==0;
   if ($27) { label = 8; break; } else { label = 9; break; }
  case 8: 
   var $28=HEAP32[(($15)>>2)];
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((5736)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$28,tempVarArgs)); STACKTOP=tempVarArgs;
   var $29=(($18)|(0))==0;
   _free($18);
   var $_0 = 0;label = 101; break;
  case 9: 
   var $31=HEAP8[($1)];
   var $32=$31 & 1;
   var $33=(($32 << 24) >> 24)==0;
   if ($33) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $35=$ctx;
   var $36=HEAP32[(($35)>>2)];
   var $37=(($36+20)|0);
   var $38=HEAP32[(($37)>>2)];
   FUNCTION_TABLE[$38]($ctx, 18);
   label = 11; break;
  case 11: 
   var $39=(($chf)|0);
   var $40=HEAP32[(($39)>>2)];
   var $41=(($chf+4)|0);
   var $42=HEAP32[(($41)>>2)];
   var $storemerge_i = 0;label = 12; break;
  case 12: 
   var $storemerge_i;
   var $44=HEAP32[(($15)>>2)];
   var $45=(($storemerge_i)|(0)) < (($44)|(0));
   if ($45) { label = 14; break; } else { label = 13; break; }
  case 13: 
   var $46=(($chf+60)|0);
   var $47=(($chf+64)|0);
   var $48=(($chf+72)|0);
   var $storemerge1_i = 0;label = 15; break;
  case 14: 
   var $50=(($19+($storemerge_i<<1))|0);
   HEAP16[(($50)>>1)]=-1;
   var $51=((($storemerge_i)+(1))|0);
   var $storemerge_i = $51;label = 12; break;
  case 15: 
   var $storemerge1_i;
   var $53=(($storemerge1_i)|(0)) < (($42)|(0));
   if ($53) { label = 16; break; } else { var $storemerge2_i = 0;label = 30; break; }
  case 16: 
   var $54=(Math.imul($storemerge1_i,$40)|0);
   var $storemerge7_i = 0;label = 17; break;
  case 17: 
   var $storemerge7_i;
   var $56=(($storemerge7_i)|(0)) < (($40)|(0));
   if ($56) { label = 18; break; } else { label = 29; break; }
  case 18: 
   var $58=((($storemerge7_i)+($54))|0);
   var $59=HEAP32[(($46)>>2)];
   var $60=(($59+($58<<2))|0);
   var $61=$60;
   var $62=HEAP32[(($61)>>2)];
   var $63=$62 & 16777215;
   var $64=$62 >>> 24;
   var $65=((($63)+($64))|0);
   var $i1_i_0 = $63;label = 19; break;
  case 19: 
   var $i1_i_0;
   var $67=(($i1_i_0)|(0)) < (($65)|(0));
   if ($67) { label = 20; break; } else { label = 28; break; }
  case 20: 
   var $69=HEAP32[(($47)>>2)];
   var $70=HEAP32[(($48)>>2)];
   var $71=(($70+$i1_i_0)|0);
   var $72=HEAP8[($71)];
   var $73=(($69+($i1_i_0<<3)+4)|0);
   var $74=$73;
   var $storemerge8_i = 0;var $nc_i_0 = 0;label = 21; break;
  case 21: 
   var $nc_i_0;
   var $storemerge8_i;
   var $76=(($storemerge8_i)|(0)) < 4;
   if ($76) { label = 22; break; } else { label = 25; break; }
  case 22: 
   var $78=((($storemerge8_i)*(6))&-1);
   var $79=HEAP32[(($74)>>2)];
   var $80=$79 & 16777215;
   var $81=$80 >>> (($78)>>>(0));
   var $82=$81 & 63;
   var $83=(($82)|(0))==63;
   if ($83) { var $nc_i_1 = $nc_i_0;label = 24; break; } else { label = 23; break; }
  case 23: 
   var $85=$storemerge8_i & 3;
   var $86=((6640+($85<<2))|0);
   var $87=HEAP32[(($86)>>2)];
   var $88=((($storemerge7_i)+($87))|0);
   var $89=((6624+($85<<2))|0);
   var $90=HEAP32[(($89)>>2)];
   var $91=((($storemerge1_i)+($90))|0);
   var $92=(Math.imul($91,$40)|0);
   var $93=((($88)+($92))|0);
   var $94=HEAP32[(($46)>>2)];
   var $95=(($94+($93<<2))|0);
   var $96=$95;
   var $97=HEAP32[(($96)>>2)];
   var $98=$97 & 16777215;
   var $99=((($98)+($82))|0);
   var $100=(($70+$99)|0);
   var $101=HEAP8[($100)];
   var $102=(($72 << 24) >> 24)==(($101 << 24) >> 24);
   var $103=((($nc_i_0)+(1))|0);
   var $_nc_i_0=$102 ? $103 : $nc_i_0;
   var $nc_i_1 = $_nc_i_0;label = 24; break;
  case 24: 
   var $nc_i_1;
   var $105=((($storemerge8_i)+(1))|0);
   var $storemerge8_i = $105;var $nc_i_0 = $nc_i_1;label = 21; break;
  case 25: 
   var $107=(($nc_i_0)|(0))==4;
   if ($107) { label = 27; break; } else { label = 26; break; }
  case 26: 
   var $109=(($19+($i1_i_0<<1))|0);
   HEAP16[(($109)>>1)]=0;
   label = 27; break;
  case 27: 
   var $111=((($i1_i_0)+(1))|0);
   var $i1_i_0 = $111;label = 19; break;
  case 28: 
   var $113=((($storemerge7_i)+(1))|0);
   var $storemerge7_i = $113;label = 17; break;
  case 29: 
   var $115=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $115;label = 15; break;
  case 30: 
   var $storemerge2_i;
   var $116=(($storemerge2_i)|(0)) < (($42)|(0));
   if ($116) { label = 31; break; } else { var $storemerge3_in_i_in_sroa_speculated = $42;label = 50; break; }
  case 31: 
   var $117=(Math.imul($storemerge2_i,$40)|0);
   var $118=((($storemerge2_i)-(1))|0);
   var $119=(Math.imul($118,$40)|0);
   var $storemerge6_i = 0;label = 32; break;
  case 32: 
   var $storemerge6_i;
   var $121=(($storemerge6_i)|(0)) < (($40)|(0));
   if ($121) { label = 33; break; } else { label = 49; break; }
  case 33: 
   var $123=((($storemerge6_i)+($117))|0);
   var $124=HEAP32[(($46)>>2)];
   var $125=(($124+($123<<2))|0);
   var $126=$125;
   var $127=HEAP32[(($126)>>2)];
   var $128=$127 & 16777215;
   var $129=$127 >>> 24;
   var $130=((($128)+($129))|0);
   var $131=((($storemerge6_i)+($119))|0);
   var $132=((($storemerge6_i)+(1))|0);
   var $133=((($132)+($119))|0);
   var $134=((($storemerge6_i)-(1))|0);
   var $135=((($134)+($117))|0);
   var $136=((($134)+($119))|0);
   var $i5_i_0 = $128;label = 34; break;
  case 34: 
   var $i5_i_0;
   var $138=(($i5_i_0)|(0)) < (($130)|(0));
   if ($138) { label = 35; break; } else { var $storemerge6_i = $132;label = 32; break; }
  case 35: 
   var $140=HEAP32[(($47)>>2)];
   var $141=(($140+($i5_i_0<<3)+4)|0);
   var $142=$141;
   var $143=HEAP32[(($142)>>2)];
   var $144=$143 & 63;
   var $145=(($144)|(0))==63;
   if ($145) { label = 36; break; } else { label = 37; break; }
  case 36: 
   var $_pre322=(($140+($i5_i_0<<3)+4)|0);
   var $_pre324=$_pre322;
   var $_pre_phi325 = $_pre324;label = 42; break;
  case 37: 
   var $147=HEAP32[(($46)>>2)];
   var $148=(($147+($135<<2))|0);
   var $149=$148;
   var $150=HEAP32[(($149)>>2)];
   var $151=$150 & 16777215;
   var $152=(($140+($i5_i_0<<3)+4)|0);
   var $153=$152;
   var $154=((($151)+($144))|0);
   var $155=(($19+($154<<1))|0);
   var $156=HEAP16[(($155)>>1)];
   var $157=(($156)&(65535));
   var $158=((($157)+(2))|0);
   var $159=(($19+($i5_i_0<<1))|0);
   var $160=HEAP16[(($159)>>1)];
   var $161=(($160)&(65535));
   var $162=(($158)>>>(0)) < (($161)>>>(0));
   if ($162) { label = 38; break; } else { var $166 = $160;label = 39; break; }
  case 38: 
   var $164=((($156)+(2))&65535);
   HEAP16[(($159)>>1)]=$164;
   var $166 = $164;label = 39; break;
  case 39: 
   var $166;
   var $167=(($140+($154<<3)+4)|0);
   var $168=$167;
   var $169=HEAP32[(($168)>>2)];
   var $170=$169 & 16515072;
   var $171=(($170)|(0))==16515072;
   if ($171) { var $_pre_phi325 = $153;label = 42; break; } else { label = 40; break; }
  case 40: 
   var $173=HEAP32[(($46)>>2)];
   var $174=(($173+($136<<2))|0);
   var $175=$174;
   var $176=HEAP32[(($175)>>2)];
   var $177=$176 & 16777215;
   var $178=$169 >>> 18;
   var $179=$178 & 63;
   var $180=((($177)+($179))|0);
   var $181=(($19+($180<<1))|0);
   var $182=HEAP16[(($181)>>1)];
   var $183=(($182)&(65535));
   var $184=((($183)+(3))|0);
   var $185=(($166)&(65535));
   var $186=(($184)>>>(0)) < (($185)>>>(0));
   if ($186) { label = 41; break; } else { var $_pre_phi325 = $153;label = 42; break; }
  case 41: 
   var $188=((($182)+(3))&65535);
   HEAP16[(($159)>>1)]=$188;
   var $_pre_phi325 = $153;label = 42; break;
  case 42: 
   var $_pre_phi325;
   var $189=HEAP32[(($_pre_phi325)>>2)];
   var $190=$189 & 16515072;
   var $191=(($190)|(0))==16515072;
   if ($191) { label = 48; break; } else { label = 43; break; }
  case 43: 
   var $193=HEAP32[(($46)>>2)];
   var $194=(($193+($131<<2))|0);
   var $195=$194;
   var $196=HEAP32[(($195)>>2)];
   var $197=$196 & 16777215;
   var $198=$189 >>> 18;
   var $199=$198 & 63;
   var $200=((($197)+($199))|0);
   var $201=HEAP32[(($47)>>2)];
   var $202=(($19+($200<<1))|0);
   var $203=HEAP16[(($202)>>1)];
   var $204=(($203)&(65535));
   var $205=((($204)+(2))|0);
   var $206=(($19+($i5_i_0<<1))|0);
   var $207=HEAP16[(($206)>>1)];
   var $208=(($207)&(65535));
   var $209=(($205)>>>(0)) < (($208)>>>(0));
   if ($209) { label = 44; break; } else { var $213 = $207;label = 45; break; }
  case 44: 
   var $211=((($203)+(2))&65535);
   HEAP16[(($206)>>1)]=$211;
   var $213 = $211;label = 45; break;
  case 45: 
   var $213;
   var $214=(($201+($200<<3)+4)|0);
   var $215=$214;
   var $216=HEAP32[(($215)>>2)];
   var $217=$216 & 258048;
   var $218=(($217)|(0))==258048;
   if ($218) { label = 48; break; } else { label = 46; break; }
  case 46: 
   var $220=HEAP32[(($46)>>2)];
   var $221=(($220+($133<<2))|0);
   var $222=$221;
   var $223=HEAP32[(($222)>>2)];
   var $224=$223 & 16777215;
   var $225=$216 >>> 12;
   var $226=$225 & 63;
   var $227=((($224)+($226))|0);
   var $228=(($19+($227<<1))|0);
   var $229=HEAP16[(($228)>>1)];
   var $230=(($229)&(65535));
   var $231=((($230)+(3))|0);
   var $232=(($213)&(65535));
   var $233=(($231)>>>(0)) < (($232)>>>(0));
   if ($233) { label = 47; break; } else { label = 48; break; }
  case 47: 
   var $235=((($229)+(3))&65535);
   HEAP16[(($206)>>1)]=$235;
   label = 48; break;
  case 48: 
   var $237=((($i5_i_0)+(1))|0);
   var $i5_i_0 = $237;label = 34; break;
  case 49: 
   var $239=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $239;label = 30; break;
  case 50: 
   var $storemerge3_in_i_in_sroa_speculated;
   var $storemerge3_i=((($storemerge3_in_i_in_sroa_speculated)-(1))|0);
   var $240=(($storemerge3_in_i_in_sroa_speculated)|(0)) > 0;
   if ($240) { label = 51; break; } else { label = 69; break; }
  case 51: 
   var $241=(Math.imul($storemerge3_i,$40)|0);
   var $242=(Math.imul($storemerge3_in_i_in_sroa_speculated,$40)|0);
   var $storemerge5_in_i_in_sroa_speculated = $40;label = 52; break;
  case 52: 
   var $storemerge5_in_i_in_sroa_speculated;
   var $storemerge5_i=((($storemerge5_in_i_in_sroa_speculated)-(1))|0);
   var $243=(($storemerge5_in_i_in_sroa_speculated)|(0)) > 0;
   if ($243) { label = 53; break; } else { var $storemerge3_in_i_in_sroa_speculated = $storemerge3_i;label = 50; break; }
  case 53: 
   var $245=((($storemerge5_i)+($241))|0);
   var $246=HEAP32[(($46)>>2)];
   var $247=(($246+($245<<2))|0);
   var $248=$247;
   var $249=HEAP32[(($248)>>2)];
   var $250=$249 & 16777215;
   var $251=$249 >>> 24;
   var $252=((($250)+($251))|0);
   var $253=((($storemerge5_i)+($242))|0);
   var $254=((($storemerge5_in_i_in_sroa_speculated)-(2))|0);
   var $255=((($254)+($242))|0);
   var $256=((($storemerge5_in_i_in_sroa_speculated)+($241))|0);
   var $257=((($storemerge5_in_i_in_sroa_speculated)+($242))|0);
   var $i21_i_0 = $250;label = 54; break;
  case 54: 
   var $i21_i_0;
   var $259=(($i21_i_0)|(0)) < (($252)|(0));
   if ($259) { label = 55; break; } else { var $storemerge5_in_i_in_sroa_speculated = $storemerge5_i;label = 52; break; }
  case 55: 
   var $261=HEAP32[(($47)>>2)];
   var $262=(($261+($i21_i_0<<3)+4)|0);
   var $263=$262;
   var $264=HEAP32[(($263)>>2)];
   var $265=$264 & 258048;
   var $266=(($265)|(0))==258048;
   if ($266) { label = 56; break; } else { label = 57; break; }
  case 56: 
   var $_pre326=(($261+($i21_i_0<<3)+4)|0);
   var $_pre328=$_pre326;
   var $_pre_phi329 = $_pre328;label = 62; break;
  case 57: 
   var $268=HEAP32[(($46)>>2)];
   var $269=(($268+($256<<2))|0);
   var $270=$269;
   var $271=HEAP32[(($270)>>2)];
   var $272=$271 & 16777215;
   var $273=(($261+($i21_i_0<<3)+4)|0);
   var $274=$273;
   var $275=$264 >>> 12;
   var $276=$275 & 63;
   var $277=((($272)+($276))|0);
   var $278=(($19+($277<<1))|0);
   var $279=HEAP16[(($278)>>1)];
   var $280=(($279)&(65535));
   var $281=((($280)+(2))|0);
   var $282=(($19+($i21_i_0<<1))|0);
   var $283=HEAP16[(($282)>>1)];
   var $284=(($283)&(65535));
   var $285=(($281)>>>(0)) < (($284)>>>(0));
   if ($285) { label = 58; break; } else { var $289 = $283;label = 59; break; }
  case 58: 
   var $287=((($279)+(2))&65535);
   HEAP16[(($282)>>1)]=$287;
   var $289 = $287;label = 59; break;
  case 59: 
   var $289;
   var $290=(($261+($277<<3)+4)|0);
   var $291=$290;
   var $292=HEAP32[(($291)>>2)];
   var $293=$292 & 4032;
   var $294=(($293)|(0))==4032;
   if ($294) { var $_pre_phi329 = $274;label = 62; break; } else { label = 60; break; }
  case 60: 
   var $296=HEAP32[(($46)>>2)];
   var $297=(($296+($257<<2))|0);
   var $298=$297;
   var $299=HEAP32[(($298)>>2)];
   var $300=$299 & 16777215;
   var $301=$292 >>> 6;
   var $302=$301 & 63;
   var $303=((($300)+($302))|0);
   var $304=(($19+($303<<1))|0);
   var $305=HEAP16[(($304)>>1)];
   var $306=(($305)&(65535));
   var $307=((($306)+(3))|0);
   var $308=(($289)&(65535));
   var $309=(($307)>>>(0)) < (($308)>>>(0));
   if ($309) { label = 61; break; } else { var $_pre_phi329 = $274;label = 62; break; }
  case 61: 
   var $311=((($305)+(3))&65535);
   HEAP16[(($282)>>1)]=$311;
   var $_pre_phi329 = $274;label = 62; break;
  case 62: 
   var $_pre_phi329;
   var $312=HEAP32[(($_pre_phi329)>>2)];
   var $313=$312 & 4032;
   var $314=(($313)|(0))==4032;
   if ($314) { label = 68; break; } else { label = 63; break; }
  case 63: 
   var $316=HEAP32[(($46)>>2)];
   var $317=(($316+($253<<2))|0);
   var $318=$317;
   var $319=HEAP32[(($318)>>2)];
   var $320=$319 & 16777215;
   var $321=$312 >>> 6;
   var $322=$321 & 63;
   var $323=((($320)+($322))|0);
   var $324=HEAP32[(($47)>>2)];
   var $325=(($19+($323<<1))|0);
   var $326=HEAP16[(($325)>>1)];
   var $327=(($326)&(65535));
   var $328=((($327)+(2))|0);
   var $329=(($19+($i21_i_0<<1))|0);
   var $330=HEAP16[(($329)>>1)];
   var $331=(($330)&(65535));
   var $332=(($328)>>>(0)) < (($331)>>>(0));
   if ($332) { label = 64; break; } else { var $336 = $330;label = 65; break; }
  case 64: 
   var $334=((($326)+(2))&65535);
   HEAP16[(($329)>>1)]=$334;
   var $336 = $334;label = 65; break;
  case 65: 
   var $336;
   var $337=(($324+($323<<3)+4)|0);
   var $338=$337;
   var $339=HEAP32[(($338)>>2)];
   var $340=$339 & 63;
   var $341=(($340)|(0))==63;
   if ($341) { label = 68; break; } else { label = 66; break; }
  case 66: 
   var $343=HEAP32[(($46)>>2)];
   var $344=(($343+($255<<2))|0);
   var $345=$344;
   var $346=HEAP32[(($345)>>2)];
   var $347=$346 & 16777215;
   var $348=((($347)+($340))|0);
   var $349=(($19+($348<<1))|0);
   var $350=HEAP16[(($349)>>1)];
   var $351=(($350)&(65535));
   var $352=((($351)+(3))|0);
   var $353=(($336)&(65535));
   var $354=(($352)>>>(0)) < (($353)>>>(0));
   if ($354) { label = 67; break; } else { label = 68; break; }
  case 67: 
   var $356=((($350)+(3))&65535);
   HEAP16[(($329)>>1)]=$356;
   label = 68; break;
  case 68: 
   var $358=((($i21_i_0)+(1))|0);
   var $i21_i_0 = $358;label = 54; break;
  case 69: 
   var $360=HEAP32[(($15)>>2)];
   var $storemerge4_i = 0;var $maxDist_0 = 0;label = 70; break;
  case 70: 
   var $maxDist_0;
   var $storemerge4_i;
   var $362=(($storemerge4_i)|(0)) < (($360)|(0));
   if ($362) { label = 71; break; } else { label = 72; break; }
  case 71: 
   var $364=(($19+($storemerge4_i<<1))|0);
   var $365=HEAP16[(($364)>>1)];
   var $366=(($365)&(65535)) > (($maxDist_0)&(65535));
   var $367=$366 ? $365 : $maxDist_0;
   var $368=((($storemerge4_i)+(1))|0);
   var $storemerge4_i = $368;var $maxDist_0 = $367;label = 70; break;
  case 72: 
   var $369=(($chf+24)|0);
   HEAP16[(($369)>>1)]=$maxDist_0;
   var $370=HEAP8[($1)];
   var $371=$370 & 1;
   var $372=(($371 << 24) >> 24)==0;
   if ($372) { var $378 = $370;label = 74; break; } else { label = 73; break; }
  case 73: 
   var $374=$ctx;
   var $375=HEAP32[(($374)>>2)];
   var $376=(($375+24)|0);
   var $377=HEAP32[(($376)>>2)];
   FUNCTION_TABLE[$377]($ctx, 18);
   var $_pre=HEAP8[($1)];
   var $378 = $_pre;label = 74; break;
  case 74: 
   var $378;
   var $379=$378 & 1;
   var $380=(($379 << 24) >> 24)==0;
   if ($380) { label = 76; break; } else { label = 75; break; }
  case 75: 
   var $382=$ctx;
   var $383=HEAP32[(($382)>>2)];
   var $384=(($383+20)|0);
   var $385=HEAP32[(($384)>>2)];
   FUNCTION_TABLE[$385]($ctx, 19);
   label = 76; break;
  case 76: 
   var $386=HEAP32[(($39)>>2)];
   var $387=HEAP32[(($41)>>2)];
   var $storemerge_i16 = 0;label = 77; break;
  case 77: 
   var $storemerge_i16;
   var $389=(($storemerge_i16)|(0)) < (($387)|(0));
   if ($389) { label = 78; break; } else { label = 95; break; }
  case 78: 
   var $390=(Math.imul($storemerge_i16,$386)|0);
   var $storemerge1_i17 = 0;label = 79; break;
  case 79: 
   var $storemerge1_i17;
   var $392=(($storemerge1_i17)|(0)) < (($386)|(0));
   if ($392) { label = 80; break; } else { label = 94; break; }
  case 80: 
   var $394=((($storemerge1_i17)+($390))|0);
   var $395=HEAP32[(($46)>>2)];
   var $396=(($395+($394<<2))|0);
   var $397=$396;
   var $398=HEAP32[(($397)>>2)];
   var $399=$398 & 16777215;
   var $400=$398 >>> 24;
   var $401=((($399)+($400))|0);
   var $i_i10_0 = $399;label = 81; break;
  case 81: 
   var $i_i10_0;
   var $403=(($i_i10_0)|(0)) < (($401)|(0));
   if ($403) { label = 82; break; } else { label = 93; break; }
  case 82: 
   var $405=HEAP32[(($47)>>2)];
   var $406=(($19+($i_i10_0<<1))|0);
   var $407=HEAP16[(($406)>>1)];
   var $408=(($407)&(65535));
   var $409=(($407)&(65535)) > 2;
   if ($409) { label = 84; break; } else { label = 83; break; }
  case 83: 
   var $411=(($26+($i_i10_0<<1))|0);
   HEAP16[(($411)>>1)]=$407;
   label = 92; break;
  case 84: 
   var $413=(($405+($i_i10_0<<3)+4)|0);
   var $414=$413;
   var $415=$408 << 1;
   var $storemerge2_i18 = 0;var $d_i_0 = $408;label = 85; break;
  case 85: 
   var $d_i_0;
   var $storemerge2_i18;
   var $417=(($storemerge2_i18)|(0)) < 4;
   if ($417) { label = 86; break; } else { label = 91; break; }
  case 86: 
   var $419=((($storemerge2_i18)*(6))&-1);
   var $420=HEAP32[(($414)>>2)];
   var $421=$420 & 16777215;
   var $422=$421 >>> (($419)>>>(0));
   var $423=$422 & 63;
   var $424=(($423)|(0))==63;
   if ($424) { label = 90; break; } else { label = 87; break; }
  case 87: 
   var $426=$storemerge2_i18 & 3;
   var $427=((6640+($426<<2))|0);
   var $428=HEAP32[(($427)>>2)];
   var $429=((($storemerge1_i17)+($428))|0);
   var $430=((6624+($426<<2))|0);
   var $431=HEAP32[(($430)>>2)];
   var $432=((($storemerge_i16)+($431))|0);
   var $433=(Math.imul($432,$386)|0);
   var $434=((($429)+($433))|0);
   var $435=HEAP32[(($46)>>2)];
   var $436=(($435+($434<<2))|0);
   var $437=$436;
   var $438=HEAP32[(($437)>>2)];
   var $439=$438 & 16777215;
   var $440=((($439)+($423))|0);
   var $441=(($19+($440<<1))|0);
   var $442=HEAP16[(($441)>>1)];
   var $443=(($442)&(65535));
   var $444=((($d_i_0)+($443))|0);
   var $445=((($storemerge2_i18)+(1))|0);
   var $446=$445 & 3;
   var $447=((($446)*(6))&-1);
   var $448=(($405+($440<<3)+4)|0);
   var $449=$448;
   var $450=HEAP32[(($449)>>2)];
   var $451=$450 & 16777215;
   var $452=$451 >>> (($447)>>>(0));
   var $453=$452 & 63;
   var $454=(($453)|(0))==63;
   if ($454) { label = 89; break; } else { label = 88; break; }
  case 88: 
   var $456=((6640+($446<<2))|0);
   var $457=HEAP32[(($456)>>2)];
   var $458=((($429)+($457))|0);
   var $459=((6624+($446<<2))|0);
   var $460=HEAP32[(($459)>>2)];
   var $461=((($432)+($460))|0);
   var $462=(Math.imul($461,$386)|0);
   var $463=((($458)+($462))|0);
   var $464=(($435+($463<<2))|0);
   var $465=$464;
   var $466=HEAP32[(($465)>>2)];
   var $467=$466 & 16777215;
   var $468=((($467)+($453))|0);
   var $469=(($19+($468<<1))|0);
   var $470=HEAP16[(($469)>>1)];
   var $471=(($470)&(65535));
   var $472=((($444)+($471))|0);
   var $storemerge2_i18 = $445;var $d_i_0 = $472;label = 85; break;
  case 89: 
   var $474=((($444)+($408))|0);
   var $storemerge2_i18 = $445;var $d_i_0 = $474;label = 85; break;
  case 90: 
   var $476=((($d_i_0)+($415))|0);
   var $_pre319=((($storemerge2_i18)+(1))|0);
   var $storemerge2_i18 = $_pre319;var $d_i_0 = $476;label = 85; break;
  case 91: 
   var $478=((($d_i_0)+(5))|0);
   var $479=((((($478)|(0)))/(9))&-1);
   var $480=(($479) & 65535);
   var $481=(($26+($i_i10_0<<1))|0);
   HEAP16[(($481)>>1)]=$480;
   label = 92; break;
  case 92: 
   var $483=((($i_i10_0)+(1))|0);
   var $i_i10_0 = $483;label = 81; break;
  case 93: 
   var $485=((($storemerge1_i17)+(1))|0);
   var $storemerge1_i17 = $485;label = 79; break;
  case 94: 
   var $487=((($storemerge_i16)+(1))|0);
   var $storemerge_i16 = $487;label = 77; break;
  case 95: 
   var $488=(($25)|(0))==(($18)|(0));
   var $_=$488 ? $19 : $26;
   HEAP32[(($10)>>2)]=$_;
   var $489=HEAP8[($1)];
   var $490=$489 & 1;
   var $491=(($490 << 24) >> 24)==0;
   if ($491) { var $497 = $489;label = 97; break; } else { label = 96; break; }
  case 96: 
   var $493=$ctx;
   var $494=HEAP32[(($493)>>2)];
   var $495=(($494+24)|0);
   var $496=HEAP32[(($495)>>2)];
   FUNCTION_TABLE[$496]($ctx, 19);
   var $_pre315=HEAP8[($1)];
   var $497 = $_pre315;label = 97; break;
  case 97: 
   var $497;
   var $498=$497 & 1;
   var $499=(($498 << 24) >> 24)==0;
   if ($499) { label = 99; break; } else { label = 98; break; }
  case 98: 
   var $501=$ctx;
   var $502=HEAP32[(($501)>>2)];
   var $503=(($502+24)|0);
   var $504=HEAP32[(($503)>>2)];
   FUNCTION_TABLE[$504]($ctx, 17);
   label = 99; break;
  case 99: 
   var $505=(($18)|(0))==0;
   if ($505) { var $_0 = 1;label = 101; break; } else { label = 100; break; }
  case 100: 
   _free($18);
   var $_0 = 1;label = 101; break;
  case 101: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL18filterSmallRegionsP9rcContextiiRtR20rcCompactHeightfieldPt($ctx, $minRegionArea, $mergeRegionSize, $maxRegionId, $chf, $srcReg) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 48)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $acon_i=sp;
   var $stack=(sp)+(16);
   var $trace=(sp)+(32);
   var $1=(($chf)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($chf+4)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=HEAP16[(($maxRegionId)>>1)];
   var $6=(($5)&(65535));
   var $7=((($6)+(1))|0);
   var $8=((($7)*(36))&-1);
   var $9=_malloc($8);
   var $10=$9;
   var $11=(($9)|(0))==0;
   if ($11) { label = 2; break; } else { var $storemerge = 0;label = 3; break; }
  case 2: 
   __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((1760)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$7,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0429 = 0;label = 177; break;
  case 3: 
   var $storemerge;
   var $13=(($storemerge)|(0)) < (($7)|(0));
   if ($13) { label = 5; break; } else { label = 4; break; }
  case 4: 
   var $14=(($chf+60)|0);
   var $15=(($chf+72)|0);
   var $16=(($chf+64)|0);
   var $storemerge1 = 0;label = 8; break;
  case 5: 
   var $18=(($10+((($storemerge)*(36))&-1))|0);
   var $19=(($18)|(0))==0;
   if ($19) { label = 7; break; } else { label = 6; break; }
  case 6: 
   var $21=(($storemerge) & 65535);
   var $22=(($18)|0);
   HEAP32[(($22)>>2)]=0;
   var $23=(($10+((($storemerge)*(36))&-1)+4)|0);
   HEAP16[(($23)>>1)]=$21;
   var $24=(($10+((($storemerge)*(36))&-1)+6)|0);
   HEAP8[($24)]=0;
   var $25=(($10+((($storemerge)*(36))&-1)+7)|0);
   HEAP8[($25)]=0;
   var $26=(($10+((($storemerge)*(36))&-1)+8)|0);
   HEAP8[($26)]=0;
   var $27=(($10+((($storemerge)*(36))&-1)+12)|0);
   var $28=$27;
   HEAP32[(($28)>>2)]=0; HEAP32[((($28)+(4))>>2)]=0; HEAP32[((($28)+(8))>>2)]=0; HEAP32[((($28)+(12))>>2)]=0; HEAP32[((($28)+(16))>>2)]=0; HEAP32[((($28)+(20))>>2)]=0;
   label = 7; break;
  case 7: 
   var $30=((($storemerge)+(1))|0);
   var $storemerge = $30;label = 3; break;
  case 8: 
   var $storemerge1;
   var $32=(($storemerge1)|(0)) < (($4)|(0));
   if ($32) { label = 9; break; } else { label = 58; break; }
  case 9: 
   var $33=(Math.imul($storemerge1,$2)|0);
   var $storemerge13 = 0;label = 10; break;
  case 10: 
   var $storemerge13;
   var $35=(($storemerge13)|(0)) < (($2)|(0));
   if ($35) { label = 11; break; } else { label = 57; break; }
  case 11: 
   var $37=((($storemerge13)+($33))|0);
   var $38=HEAP32[(($14)>>2)];
   var $39=(($38+($37<<2))|0);
   var $40=$39;
   var $41=HEAP32[(($40)>>2)];
   var $42=$41 & 16777215;
   var $43=$41 >>> 24;
   var $44=((($42)+($43))|0);
   var $i1_0 = $42;label = 12; break;
  case 12: 
   var $i1_0;
   var $46=(($i1_0)|(0)) < (($44)|(0));
   if ($46) { label = 13; break; } else { label = 56; break; }
  case 13: 
   var $48=(($srcReg+($i1_0<<1))|0);
   var $49=HEAP16[(($48)>>1)];
   var $50=(($49 << 16) >> 16)==0;
   if ($50) { label = 55; break; } else { label = 14; break; }
  case 14: 
   var $52=(($49)&(65535));
   var $53=(($52)>>>(0)) < (($7)>>>(0));
   if ($53) { label = 15; break; } else { label = 55; break; }
  case 15: 
   var $55=(($10+((($52)*(36))&-1))|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=((($56)+(1))|0);
   HEAP32[(($55)>>2)]=$57;
   var $58=HEAP32[(($40)>>2)];
   var $59=$58 & 16777215;
   var $60=(($10+((($52)*(36))&-1)+28)|0);
   var $61=(($10+((($52)*(36))&-1)+24)|0);
   var $62=(($10+((($52)*(36))&-1)+24)|0);
   var $63=(($62)|0);
   var $storemerge14 = $59;label = 16; break;
  case 16: 
   var $storemerge14;
   var $65=(($storemerge14)|(0)) < (($44)|(0));
   if ($65) { label = 17; break; } else { label = 26; break; }
  case 17: 
   var $67=(($i1_0)|(0))==(($storemerge14)|(0));
   if ($67) { label = 25; break; } else { label = 18; break; }
  case 18: 
   var $69=(($srcReg+($storemerge14<<1))|0);
   var $70=HEAP16[(($69)>>1)];
   var $71=(($70 << 16) >> 16)==0;
   if ($71) { label = 25; break; } else { label = 19; break; }
  case 19: 
   var $73=(($70)&(65535));
   var $74=(($73)>>>(0)) < (($7)>>>(0));
   if ($74) { label = 20; break; } else { label = 25; break; }
  case 20: 
   var $76=HEAP32[(($60)>>2)];
   var $storemerge_i = 0;label = 21; break;
  case 21: 
   var $storemerge_i;
   var $78=(($storemerge_i)|(0)) < (($76)|(0));
   if ($78) { label = 22; break; } else { label = 24; break; }
  case 22: 
   var $80=HEAP32[(($61)>>2)];
   var $81=(($80+($storemerge_i<<2))|0);
   var $82=HEAP32[(($81)>>2)];
   var $83=(($82)|(0))==(($73)|(0));
   if ($83) { label = 25; break; } else { label = 23; break; }
  case 23: 
   var $85=((($storemerge_i)+(1))|0);
   var $storemerge_i = $85;label = 21; break;
  case 24: 
   var $87=((($76)+(1))|0);
   __ZN10rcIntArray6resizeEi($62, $87);
   var $88=HEAP32[(($60)>>2)];
   var $89=((($88)-(1))|0);
   var $90=HEAP32[(($63)>>2)];
   var $91=(($90+($89<<2))|0);
   HEAP32[(($91)>>2)]=$73;
   label = 25; break;
  case 25: 
   var $92=((($storemerge14)+(1))|0);
   var $storemerge14 = $92;label = 16; break;
  case 26: 
   var $94=(($10+((($52)*(36))&-1)+16)|0);
   var $95=HEAP32[(($94)>>2)];
   var $96=(($95)|(0)) > 0;
   if ($96) { label = 55; break; } else { label = 27; break; }
  case 27: 
   var $98=HEAP32[(($15)>>2)];
   var $99=(($98+$i1_0)|0);
   var $100=HEAP8[($99)];
   var $101=(($10+((($52)*(36))&-1)+6)|0);
   HEAP8[($101)]=$100;
   var $storemerge15 = 0;label = 28; break;
  case 28: 
   var $storemerge15;
   var $103=(($storemerge15)|(0)) < 4;
   if ($103) { label = 29; break; } else { label = 55; break; }
  case 29: 
   var $105=__ZL11isSolidEdgeR20rcCompactHeightfieldPtiiii($chf, $srcReg, $storemerge13, $storemerge1, $i1_0, $storemerge15);
   if ($105) { var $ndir_0 = $storemerge15;label = 31; break; } else { label = 30; break; }
  case 30: 
   var $107=((($storemerge15)+(1))|0);
   var $storemerge15 = $107;label = 28; break;
  case 31: 
   var $ndir_0;
   var $108=(($ndir_0)|(0))==-1;
   if ($108) { label = 55; break; } else { label = 32; break; }
  case 32: 
   var $110=(($10+((($52)*(36))&-1)+12)|0);
   var $111=HEAP32[(($16)>>2)];
   var $112=((($ndir_0)*(6))&-1);
   var $113=(($111+($i1_0<<3)+4)|0);
   var $114=$113;
   var $115=HEAP32[(($114)>>2)];
   var $116=$115 & 16777215;
   var $117=$116 >>> (($112)>>>(0));
   var $118=$117 & 63;
   var $119=(($118)|(0))==63;
   if ($119) { var $curReg_i_0 = 0;label = 34; break; } else { label = 33; break; }
  case 33: 
   var $121=$ndir_0 & 3;
   var $122=((6640+($121<<2))|0);
   var $123=HEAP32[(($122)>>2)];
   var $124=((($storemerge13)+($123))|0);
   var $125=((6624+($121<<2))|0);
   var $126=HEAP32[(($125)>>2)];
   var $127=((($storemerge1)+($126))|0);
   var $128=HEAP32[(($1)>>2)];
   var $129=(Math.imul($127,$128)|0);
   var $130=((($124)+($129))|0);
   var $131=HEAP32[(($14)>>2)];
   var $132=(($131+($130<<2))|0);
   var $133=$132;
   var $134=HEAP32[(($133)>>2)];
   var $135=$134 & 16777215;
   var $136=((($135)+($118))|0);
   var $137=(($srcReg+($136<<1))|0);
   var $138=HEAP16[(($137)>>1)];
   var $curReg_i_0 = $138;label = 34; break;
  case 34: 
   var $curReg_i_0;
   var $140=(($curReg_i_0)&(65535));
   var $141=(($10+((($52)*(36))&-1)+16)|0);
   var $142=((($95)+(1))|0);
   __ZN10rcIntArray6resizeEi($110, $142);
   var $143=HEAP32[(($141)>>2)];
   var $144=((($143)-(1))|0);
   var $145=(($110)|0);
   var $146=HEAP32[(($145)>>2)];
   var $147=(($146+($144<<2))|0);
   HEAP32[(($147)>>2)]=$140;
   var $_0423 = $storemerge13;var $_0424 = $storemerge1;var $_0426 = $i1_0;var $_0428 = $ndir_0;var $curReg_i_1 = $curReg_i_0;var $iter_i_0 = 1;label = 35; break;
  case 35: 
   var $iter_i_0;
   var $curReg_i_1;
   var $_0428;
   var $_0426;
   var $_0424;
   var $_0423;
   var $149=(($iter_i_0)|(0)) < 40000;
   if ($149) { label = 36; break; } else { label = 47; break; }
  case 36: 
   var $151=HEAP32[(($16)>>2)];
   var $152=__ZL11isSolidEdgeR20rcCompactHeightfieldPtiiii($chf, $srcReg, $_0423, $_0424, $_0426, $_0428);
   if ($152) { label = 37; break; } else { label = 42; break; }
  case 37: 
   var $154=((($_0428)*(6))&-1);
   var $155=(($151+($_0426<<3)+4)|0);
   var $156=$155;
   var $157=HEAP32[(($156)>>2)];
   var $158=$157 & 16777215;
   var $159=$158 >>> (($154)>>>(0));
   var $160=$159 & 63;
   var $161=(($160)|(0))==63;
   if ($161) { var $r_i_0 = 0;label = 39; break; } else { label = 38; break; }
  case 38: 
   var $163=$_0428 & 3;
   var $164=((6640+($163<<2))|0);
   var $165=HEAP32[(($164)>>2)];
   var $166=((($_0423)+($165))|0);
   var $167=((6624+($163<<2))|0);
   var $168=HEAP32[(($167)>>2)];
   var $169=((($_0424)+($168))|0);
   var $170=HEAP32[(($1)>>2)];
   var $171=(Math.imul($169,$170)|0);
   var $172=((($166)+($171))|0);
   var $173=HEAP32[(($14)>>2)];
   var $174=(($173+($172<<2))|0);
   var $175=$174;
   var $176=HEAP32[(($175)>>2)];
   var $177=$176 & 16777215;
   var $178=((($177)+($160))|0);
   var $179=(($srcReg+($178<<1))|0);
   var $180=HEAP16[(($179)>>1)];
   var $r_i_0 = $180;label = 39; break;
  case 39: 
   var $r_i_0;
   var $182=(($r_i_0 << 16) >> 16)==(($curReg_i_1 << 16) >> 16);
   if ($182) { var $curReg_i_2 = $curReg_i_1;label = 41; break; } else { label = 40; break; }
  case 40: 
   var $184=(($r_i_0)&(65535));
   var $185=HEAP32[(($141)>>2)];
   var $186=((($185)+(1))|0);
   __ZN10rcIntArray6resizeEi($110, $186);
   var $187=HEAP32[(($141)>>2)];
   var $188=((($187)-(1))|0);
   var $189=HEAP32[(($145)>>2)];
   var $190=(($189+($188<<2))|0);
   HEAP32[(($190)>>2)]=$184;
   var $curReg_i_2 = $r_i_0;label = 41; break;
  case 41: 
   var $curReg_i_2;
   var $192=((($_0428)+(1))|0);
   var $storemerge1_in_i = $192;var $_1 = $_0423;var $_1425 = $_0424;var $_1427 = $_0426;var $curReg_i_3 = $curReg_i_2;label = 45; break;
  case 42: 
   var $194=$_0428 & 3;
   var $195=((6640+($194<<2))|0);
   var $196=HEAP32[(($195)>>2)];
   var $197=((($_0423)+($196))|0);
   var $198=((6624+($194<<2))|0);
   var $199=HEAP32[(($198)>>2)];
   var $200=((($_0424)+($199))|0);
   var $201=((($_0428)*(6))&-1);
   var $202=(($151+($_0426<<3)+4)|0);
   var $203=$202;
   var $204=HEAP32[(($203)>>2)];
   var $205=$204 & 16777215;
   var $206=$205 >>> (($201)>>>(0));
   var $207=$206 & 63;
   var $208=(($207)|(0))==63;
   if ($208) { label = 55; break; } else { label = 43; break; }
  case 43: 
   var $209=HEAP32[(($1)>>2)];
   var $210=(Math.imul($200,$209)|0);
   var $211=((($197)+($210))|0);
   var $212=HEAP32[(($14)>>2)];
   var $213=(($212+($211<<2))|0);
   var $214=$213;
   var $215=HEAP32[(($214)>>2)];
   var $216=$215 & 16777215;
   var $217=((($216)+($207))|0);
   var $phitmp444=(($217)|(0))==-1;
   if ($phitmp444) { label = 55; break; } else { label = 44; break; }
  case 44: 
   var $219=((($_0428)+(3))|0);
   var $storemerge1_in_i = $219;var $_1 = $197;var $_1425 = $200;var $_1427 = $217;var $curReg_i_3 = $curReg_i_1;label = 45; break;
  case 45: 
   var $curReg_i_3;
   var $_1427;
   var $_1425;
   var $_1;
   var $storemerge1_in_i;
   var $storemerge1_i=$storemerge1_in_i & 3;
   var $221=(($i1_0)|(0))==(($_1427)|(0));
   var $222=(($ndir_0)|(0))==(($storemerge1_i)|(0));
   var $or_cond=$221 & $222;
   if ($or_cond) { label = 47; break; } else { label = 46; break; }
  case 46: 
   var $phitmp=((($iter_i_0)+(1))|0);
   var $_0423 = $_1;var $_0424 = $_1425;var $_0426 = $_1427;var $_0428 = $storemerge1_i;var $curReg_i_1 = $curReg_i_3;var $iter_i_0 = $phitmp;label = 35; break;
  case 47: 
   var $224=HEAP32[(($141)>>2)];
   var $225=(($224)|(0)) > 1;
   if ($225) { var $j_i_0_ph = 0;var $226 = $224;label = 48; break; } else { label = 55; break; }
  case 48: 
   var $226;
   var $j_i_0_ph;
   var $227=((($j_i_0_ph)+(1))|0);
   var $228 = $226;label = 49; break;
  case 49: 
   var $228;
   var $229=(($j_i_0_ph)|(0)) < (($228)|(0));
   if ($229) { label = 50; break; } else { label = 55; break; }
  case 50: 
   var $231=((((($227)|(0)))%((($228)|(0))))&-1);
   var $232=HEAP32[(($145)>>2)];
   var $233=(($232+($j_i_0_ph<<2))|0);
   var $234=HEAP32[(($233)>>2)];
   var $235=(($232+($231<<2))|0);
   var $236=HEAP32[(($235)>>2)];
   var $237=(($234)|(0))==(($236)|(0));
   if ($237) { var $storemerge_i17 = $j_i_0_ph;var $239 = $228;label = 51; break; } else { var $j_i_0_ph = $227;var $226 = $228;label = 48; break; }
  case 51: 
   var $239;
   var $storemerge_i17;
   var $240=((($239)-(1))|0);
   var $241=(($storemerge_i17)|(0)) < (($240)|(0));
   if ($241) { label = 52; break; } else { label = 53; break; }
  case 52: 
   var $243=((($storemerge_i17)+(1))|0);
   var $244=HEAP32[(($145)>>2)];
   var $245=(($244+($243<<2))|0);
   var $246=HEAP32[(($245)>>2)];
   var $247=(($244+($storemerge_i17<<2))|0);
   HEAP32[(($247)>>2)]=$246;
   var $_pre=HEAP32[(($141)>>2)];
   var $storemerge_i17 = $243;var $239 = $_pre;label = 51; break;
  case 53: 
   var $249=(($239)|(0)) > 0;
   if ($249) { label = 54; break; } else { var $228 = $239;label = 49; break; }
  case 54: 
   HEAP32[(($141)>>2)]=$240;
   var $228 = $240;label = 49; break;
  case 55: 
   var $251=((($i1_0)+(1))|0);
   var $i1_0 = $251;label = 12; break;
  case 56: 
   var $253=((($storemerge13)+(1))|0);
   var $storemerge13 = $253;label = 10; break;
  case 57: 
   var $255=((($storemerge1)+(1))|0);
   var $storemerge1 = $255;label = 8; break;
  case 58: 
   var $257=(($stack)|0);
   HEAP32[(($257)>>2)]=0;
   var $258=(($stack+4)|0);
   HEAP32[(($258)>>2)]=0;
   var $259=(($stack+8)|0);
   HEAP32[(($259)>>2)]=0;
   __ZN10rcIntArray6resizeEi($stack, 32);
   var $260=(($trace)|0);
   HEAP32[(($260)>>2)]=0;
   var $261=(($trace+4)|0);
   HEAP32[(($261)>>2)]=0;
   var $262=(($trace+8)|0);
   HEAP32[(($262)>>2)]=0;
   __ZN10rcIntArray6resizeEi($trace, 32);
   var $storemerge2 = 0;label = 59; break;
  case 59: 
   var $storemerge2;
   var $264=(($storemerge2)|(0)) < (($7)|(0));
   if ($264) { label = 60; break; } else { label = 80; break; }
  case 60: 
   var $266=(($10+((($storemerge2)*(36))&-1)+4)|0);
   var $267=HEAP16[(($266)>>1)];
   var $268=(($267 << 16) >> 16)==0;
   var $269=(($267 << 16) >> 16) < 0;
   var $or_cond445=$268 | $269;
   if ($or_cond445) { label = 79; break; } else { label = 61; break; }
  case 61: 
   var $271=(($10+((($storemerge2)*(36))&-1))|0);
   var $272=HEAP32[(($271)>>2)];
   var $273=(($272)|(0))==0;
   if ($273) { label = 79; break; } else { label = 62; break; }
  case 62: 
   var $275=(($10+((($storemerge2)*(36))&-1)+8)|0);
   var $276=HEAP8[($275)];
   var $277=$276 & 1;
   var $278=(($277 << 24) >> 24)==0;
   if ($278) { label = 63; break; } else { label = 79; break; }
  case 63: 
   __ZN10rcIntArray6resizeEi($stack, 0);
   __ZN10rcIntArray6resizeEi($trace, 0);
   HEAP8[($275)]=1;
   var $280=HEAP32[(($258)>>2)];
   var $281=((($280)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $281);
   var $282=HEAP32[(($258)>>2)];
   var $283=((($282)-(1))|0);
   var $284=HEAP32[(($257)>>2)];
   var $285=(($284+($283<<2))|0);
   HEAP32[(($285)>>2)]=$storemerge2;
   var $spanCount_0 = 0;var $connectsToBorder_0 = 0;var $287 = $282;var $286 = $284;label = 64; break;
  case 64: 
   var $286;
   var $287;
   var $connectsToBorder_0;
   var $spanCount_0;
   var $288=(($287)|(0))==0;
   if ($288) { label = 74; break; } else { label = 65; break; }
  case 65: 
   var $290=(($287)|(0)) > 0;
   if ($290) { label = 66; break; } else { var $293 = $287;label = 67; break; }
  case 66: 
   var $292=((($287)-(1))|0);
   HEAP32[(($258)>>2)]=$292;
   var $293 = $292;label = 67; break;
  case 67: 
   var $293;
   var $294=(($286+($293<<2))|0);
   var $295=HEAP32[(($294)>>2)];
   var $296=(($10+((($295)*(36))&-1))|0);
   var $297=HEAP32[(($296)>>2)];
   var $298=((($spanCount_0)+($297))|0);
   var $299=HEAP32[(($261)>>2)];
   var $300=((($299)+(1))|0);
   __ZN10rcIntArray6resizeEi($trace, $300);
   var $301=HEAP32[(($261)>>2)];
   var $302=((($301)-(1))|0);
   var $303=HEAP32[(($260)>>2)];
   var $304=(($303+($302<<2))|0);
   HEAP32[(($304)>>2)]=$295;
   var $305=(($10+((($295)*(36))&-1)+16)|0);
   var $306=(($10+((($295)*(36))&-1)+12)|0);
   var $storemerge12 = 0;var $connectsToBorder_1 = $connectsToBorder_0;var $309 = $293;var $308 = $286;label = 68; break;
  case 68: 
   var $308;
   var $309;
   var $connectsToBorder_1;
   var $storemerge12;
   var $310=HEAP32[(($305)>>2)];
   var $311=(($storemerge12)|(0)) < (($310)|(0));
   if ($311) { label = 69; break; } else { var $spanCount_0 = $298;var $connectsToBorder_0 = $connectsToBorder_1;var $287 = $309;var $286 = $308;label = 64; break; }
  case 69: 
   var $313=HEAP32[(($306)>>2)];
   var $314=(($313+($storemerge12<<2))|0);
   var $315=HEAP32[(($314)>>2)];
   var $316=$315 & 32768;
   var $317=(($316)|(0))==0;
   if ($317) { label = 70; break; } else { var $connectsToBorder_2 = 1;var $338 = $309;var $337 = $308;label = 73; break; }
  case 70: 
   var $319=(($10+((($315)*(36))&-1)+8)|0);
   var $320=HEAP8[($319)];
   var $321=$320 & 1;
   var $322=(($321 << 24) >> 24)==0;
   if ($322) { label = 71; break; } else { var $connectsToBorder_2 = $connectsToBorder_1;var $338 = $309;var $337 = $308;label = 73; break; }
  case 71: 
   var $324=(($10+((($315)*(36))&-1)+4)|0);
   var $325=HEAP16[(($324)>>1)];
   var $326=(($325 << 16) >> 16)==0;
   var $327=(($325 << 16) >> 16) < 0;
   var $or_cond446=$326 | $327;
   if ($or_cond446) { var $connectsToBorder_2 = $connectsToBorder_1;var $338 = $309;var $337 = $308;label = 73; break; } else { label = 72; break; }
  case 72: 
   var $329=(($325)&(65535));
   var $330=((($309)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $330);
   var $331=HEAP32[(($258)>>2)];
   var $332=((($331)-(1))|0);
   var $333=HEAP32[(($257)>>2)];
   var $334=(($333+($332<<2))|0);
   HEAP32[(($334)>>2)]=$329;
   var $335=(($10+((($315)*(36))&-1)+8)|0);
   HEAP8[($335)]=1;
   var $connectsToBorder_2 = $connectsToBorder_1;var $338 = $331;var $337 = $333;label = 73; break;
  case 73: 
   var $337;
   var $338;
   var $connectsToBorder_2;
   var $339=((($storemerge12)+(1))|0);
   var $storemerge12 = $339;var $connectsToBorder_1 = $connectsToBorder_2;var $309 = $338;var $308 = $337;label = 68; break;
  case 74: 
   var $341=(($spanCount_0)|(0)) < (($minRegionArea)|(0));
   if ($341) { label = 75; break; } else { label = 79; break; }
  case 75: 
   var $343=$connectsToBorder_0 & 1;
   var $344=(($343 << 24) >> 24)==0;
   if ($344) { label = 76; break; } else { label = 79; break; }
  case 76: 
   var $345=HEAP32[(($261)>>2)];
   var $346=HEAP32[(($260)>>2)];
   var $storemerge11 = 0;label = 77; break;
  case 77: 
   var $storemerge11;
   var $348=(($storemerge11)|(0)) < (($345)|(0));
   if ($348) { label = 78; break; } else { label = 79; break; }
  case 78: 
   var $350=(($346+($storemerge11<<2))|0);
   var $351=HEAP32[(($350)>>2)];
   var $352=(($10+((($351)*(36))&-1))|0);
   HEAP32[(($352)>>2)]=0;
   var $353=HEAP32[(($350)>>2)];
   var $354=(($10+((($353)*(36))&-1)+4)|0);
   HEAP16[(($354)>>1)]=0;
   var $355=((($storemerge11)+(1))|0);
   var $storemerge11 = $355;label = 77; break;
  case 79: 
   var $356=((($storemerge2)+(1))|0);
   var $storemerge2 = $356;label = 59; break;
  case 80: 
   var $358=$acon_i;
   var $359=(($acon_i)|0);
   var $360=(($acon_i+4)|0);
   var $361=(($acon_i+8)|0);
   var $storemerge3 = 0;var $mergeCount_0 = 0;label = 81; break;
  case 81: 
   var $mergeCount_0;
   var $storemerge3;
   var $363=(($storemerge3)|(0)) < (($7)|(0));
   if ($363) { label = 82; break; } else { label = 147; break; }
  case 82: 
   var $365=(($10+((($storemerge3)*(36))&-1))|0);
   var $366=(($10+((($storemerge3)*(36))&-1)+4)|0);
   var $367=HEAP16[(($366)>>1)];
   var $368=(($367 << 16) >> 16)==0;
   var $369=(($367 << 16) >> 16) < 0;
   var $or_cond447=$368 | $369;
   if ($or_cond447) { var $mergeCount_1 = $mergeCount_0;label = 146; break; } else { label = 83; break; }
  case 83: 
   var $371=(($365)|0);
   var $372=HEAP32[(($371)>>2)];
   var $373=(($372)|(0))==0;
   if ($373) { var $mergeCount_1 = $mergeCount_0;label = 146; break; } else { label = 84; break; }
  case 84: 
   var $375=(($372)|(0)) > (($mergeRegionSize)|(0));
   var $376=(($10+((($storemerge3)*(36))&-1)+16)|0);
   var $377=HEAP32[(($376)>>2)];
   var $378=(($10+((($storemerge3)*(36))&-1)+12)|0);
   if ($375) { var $storemerge_i30 = 0;label = 85; break; } else { var $388 = $377;var $_pre_phi = $378;label = 88; break; }
  case 85: 
   var $storemerge_i30;
   var $380=(($storemerge_i30)|(0)) < (($377)|(0));
   if ($380) { label = 86; break; } else { var $388 = $377;var $_pre_phi = $378;label = 88; break; }
  case 86: 
   var $382=HEAP32[(($378)>>2)];
   var $383=(($382+($storemerge_i30<<2))|0);
   var $384=HEAP32[(($383)>>2)];
   var $385=(($384)|(0))==0;
   if ($385) { var $mergeCount_1 = $mergeCount_0;label = 146; break; } else { label = 87; break; }
  case 87: 
   var $387=((($storemerge_i30)+(1))|0);
   var $storemerge_i30 = $387;label = 85; break;
  case 88: 
   var $_pre_phi;
   var $388;
   var $storemerge9 = 0;var $mergeId_0 = $367;var $smallest_0 = 268435455;label = 89; break;
  case 89: 
   var $smallest_0;
   var $mergeId_0;
   var $storemerge9;
   var $390=(($storemerge9)|(0)) < (($388)|(0));
   if ($390) { label = 90; break; } else { label = 96; break; }
  case 90: 
   var $392=HEAP32[(($_pre_phi)>>2)];
   var $393=(($392+($storemerge9<<2))|0);
   var $394=HEAP32[(($393)>>2)];
   var $395=$394 & 32768;
   var $396=(($395)|(0))==0;
   if ($396) { label = 91; break; } else { var $mergeId_1 = $mergeId_0;var $smallest_1 = $smallest_0;label = 95; break; }
  case 91: 
   var $398=(($10+((($394)*(36))&-1))|0);
   var $399=(($10+((($394)*(36))&-1)+4)|0);
   var $400=HEAP16[(($399)>>1)];
   var $401=(($400 << 16) >> 16)==0;
   var $402=(($400 << 16) >> 16) < 0;
   var $or_cond448=$401 | $402;
   if ($or_cond448) { var $mergeId_1 = $mergeId_0;var $smallest_1 = $smallest_0;label = 95; break; } else { label = 92; break; }
  case 92: 
   var $404=(($398)|0);
   var $405=HEAP32[(($404)>>2)];
   var $406=(($405)|(0)) < (($smallest_0)|(0));
   if ($406) { label = 93; break; } else { var $mergeId_1 = $mergeId_0;var $smallest_1 = $smallest_0;label = 95; break; }
  case 93: 
   var $408=__ZL18canMergeWithRegionRK8rcRegionS1_($365, $398);
   if ($408) { label = 94; break; } else { var $mergeId_1 = $mergeId_0;var $smallest_1 = $smallest_0;label = 95; break; }
  case 94: 
   var $410=__ZL18canMergeWithRegionRK8rcRegionS1_($398, $365);
   var $_smallest_0=$410 ? $405 : $smallest_0;
   var $_mergeId_0=$410 ? $400 : $mergeId_0;
   var $mergeId_1 = $_mergeId_0;var $smallest_1 = $_smallest_0;label = 95; break;
  case 95: 
   var $smallest_1;
   var $mergeId_1;
   var $412=((($storemerge9)+(1))|0);
   var $storemerge9 = $412;var $mergeId_0 = $mergeId_1;var $smallest_0 = $smallest_1;label = 89; break;
  case 96: 
   var $414=(($mergeId_0 << 16) >> 16)==(($367 << 16) >> 16);
   if ($414) { var $mergeCount_1 = $mergeCount_0;label = 146; break; } else { label = 97; break; }
  case 97: 
   var $416=(($mergeId_0)&(65535));
   var $417=(($10+((($416)*(36))&-1))|0);
   var $418=(($10+((($416)*(36))&-1)+4)|0);
   var $419=HEAP16[(($418)>>1)];
   HEAP32[(($359)>>2)]=0;
   HEAP32[(($360)>>2)]=0;
   HEAP32[(($361)>>2)]=0;
   var $420=(($10+((($416)*(36))&-1)+16)|0);
   var $421=HEAP32[(($420)>>2)];
   __ZN10rcIntArray6resizeEi($acon_i, $421);
   var $422=(($10+((($416)*(36))&-1)+12)|0);
   var $423=HEAP32[(($359)>>2)];
   var $storemerge_i27 = 0;label = 98; break;
  case 98: 
   var $storemerge_i27;
   var $425=HEAP32[(($420)>>2)];
   var $426=(($storemerge_i27)|(0)) < (($425)|(0));
   if ($426) { label = 99; break; } else { label = 100; break; }
  case 99: 
   var $428=HEAP32[(($422)>>2)];
   var $429=(($428+($storemerge_i27<<2))|0);
   var $430=HEAP32[(($429)>>2)];
   var $431=(($423+($storemerge_i27<<2))|0);
   HEAP32[(($431)>>2)]=$430;
   var $432=((($storemerge_i27)+(1))|0);
   var $storemerge_i27 = $432;label = 98; break;
  case 100: 
   var $434=(($10+((($storemerge3)*(36))&-1)+12)|0);
   var $435=HEAP32[(($360)>>2)];
   var $436=(($367)&(65535));
   var $storemerge1_i28 = 0;label = 101; break;
  case 101: 
   var $storemerge1_i28;
   var $438=(($storemerge1_i28)|(0)) < (($435)|(0));
   if ($438) { label = 102; break; } else { var $_0 = 0;label = 125; break; }
  case 102: 
   var $440=(($423+($storemerge1_i28<<2))|0);
   var $441=HEAP32[(($440)>>2)];
   var $442=(($441)|(0))==(($436)|(0));
   if ($442) { var $insa_i_0 = $storemerge1_i28;label = 104; break; } else { label = 103; break; }
  case 103: 
   var $444=((($storemerge1_i28)+(1))|0);
   var $storemerge1_i28 = $444;label = 101; break;
  case 104: 
   var $insa_i_0;
   var $445=(($insa_i_0)|(0))==-1;
   if ($445) { var $_0 = 0;label = 125; break; } else { label = 105; break; }
  case 105: 
   var $447=(($10+((($storemerge3)*(36))&-1)+16)|0);
   var $448=HEAP32[(($447)>>2)];
   var $449=(($434)|0);
   var $450=(($419)&(65535));
   var $storemerge2_i = 0;label = 106; break;
  case 106: 
   var $storemerge2_i;
   var $452=(($storemerge2_i)|(0)) < (($448)|(0));
   if ($452) { label = 107; break; } else { var $_0 = 0;label = 125; break; }
  case 107: 
   var $454=HEAP32[(($449)>>2)];
   var $455=(($454+($storemerge2_i<<2))|0);
   var $456=HEAP32[(($455)>>2)];
   var $457=(($456)|(0))==(($450)|(0));
   if ($457) { var $insb_i_0 = $storemerge2_i;label = 109; break; } else { label = 108; break; }
  case 108: 
   var $459=((($storemerge2_i)+(1))|0);
   var $storemerge2_i = $459;label = 106; break;
  case 109: 
   var $insb_i_0;
   var $460=(($insb_i_0)|(0))==-1;
   if ($460) { var $_0 = 0;label = 125; break; } else { label = 110; break; }
  case 110: 
   var $462=(($10+((($416)*(36))&-1)+12)|0);
   __ZN10rcIntArray6resizeEi($462, 0);
   var $463=((($435)-(1))|0);
   var $464=((($insa_i_0)+(1))|0);
   var $465=(($462)|0);
   var $i3_i_0 = 0;label = 111; break;
  case 111: 
   var $i3_i_0;
   var $467=(($i3_i_0)|(0)) < (($463)|(0));
   if ($467) { label = 112; break; } else { label = 113; break; }
  case 112: 
   var $469=((($464)+($i3_i_0))|0);
   var $470=((((($469)|(0)))%((($435)|(0))))&-1);
   var $471=(($423+($470<<2))|0);
   var $472=HEAP32[(($471)>>2)];
   var $473=HEAP32[(($420)>>2)];
   var $474=((($473)+(1))|0);
   __ZN10rcIntArray6resizeEi($462, $474);
   var $475=HEAP32[(($420)>>2)];
   var $476=((($475)-(1))|0);
   var $477=HEAP32[(($465)>>2)];
   var $478=(($477+($476<<2))|0);
   HEAP32[(($478)>>2)]=$472;
   var $479=((($i3_i_0)+(1))|0);
   var $i3_i_0 = $479;label = 111; break;
  case 113: 
   var $481=HEAP32[(($447)>>2)];
   var $482=((($481)-(1))|0);
   var $483=((($insb_i_0)+(1))|0);
   var $i4_i_0 = 0;label = 114; break;
  case 114: 
   var $i4_i_0;
   var $485=(($i4_i_0)|(0)) < (($482)|(0));
   if ($485) { label = 115; break; } else { label = 116; break; }
  case 115: 
   var $487=((($483)+($i4_i_0))|0);
   var $488=((((($487)|(0)))%((($481)|(0))))&-1);
   var $489=HEAP32[(($449)>>2)];
   var $490=(($489+($488<<2))|0);
   var $491=HEAP32[(($490)>>2)];
   var $492=HEAP32[(($420)>>2)];
   var $493=((($492)+(1))|0);
   __ZN10rcIntArray6resizeEi($462, $493);
   var $494=HEAP32[(($420)>>2)];
   var $495=((($494)-(1))|0);
   var $496=HEAP32[(($465)>>2)];
   var $497=(($496+($495<<2))|0);
   HEAP32[(($497)>>2)]=$491;
   var $498=((($i4_i_0)+(1))|0);
   var $i4_i_0 = $498;label = 114; break;
  case 116: 
   __ZL24removeAdjacentNeighboursR8rcRegion($417);
   var $500=(($10+((($storemerge3)*(36))&-1)+28)|0);
   var $501=(($10+((($storemerge3)*(36))&-1)+24)|0);
   var $502=(($10+((($416)*(36))&-1)+28)|0);
   var $503=(($10+((($416)*(36))&-1)+24)|0);
   var $504=(($10+((($416)*(36))&-1)+24)|0);
   var $505=(($504)|0);
   var $storemerge3_i = 0;label = 117; break;
  case 117: 
   var $storemerge3_i;
   var $507=HEAP32[(($500)>>2)];
   var $508=(($storemerge3_i)|(0)) < (($507)|(0));
   if ($508) { label = 118; break; } else { label = 124; break; }
  case 118: 
   var $510=HEAP32[(($501)>>2)];
   var $511=(($510+($storemerge3_i<<2))|0);
   var $512=HEAP32[(($511)>>2)];
   var $513=HEAP32[(($502)>>2)];
   var $storemerge_i_i = 0;label = 119; break;
  case 119: 
   var $storemerge_i_i;
   var $515=(($storemerge_i_i)|(0)) < (($513)|(0));
   if ($515) { label = 120; break; } else { label = 122; break; }
  case 120: 
   var $517=HEAP32[(($503)>>2)];
   var $518=(($517+($storemerge_i_i<<2))|0);
   var $519=HEAP32[(($518)>>2)];
   var $520=(($519)|(0))==(($512)|(0));
   if ($520) { label = 123; break; } else { label = 121; break; }
  case 121: 
   var $522=((($storemerge_i_i)+(1))|0);
   var $storemerge_i_i = $522;label = 119; break;
  case 122: 
   var $524=((($513)+(1))|0);
   __ZN10rcIntArray6resizeEi($504, $524);
   var $525=HEAP32[(($502)>>2)];
   var $526=((($525)-(1))|0);
   var $527=HEAP32[(($505)>>2)];
   var $528=(($527+($526<<2))|0);
   HEAP32[(($528)>>2)]=$512;
   label = 123; break;
  case 123: 
   var $529=((($storemerge3_i)+(1))|0);
   var $storemerge3_i = $529;label = 117; break;
  case 124: 
   var $531=HEAP32[(($371)>>2)];
   var $532=(($417)|0);
   var $533=HEAP32[(($532)>>2)];
   var $534=((($533)+($531))|0);
   HEAP32[(($532)>>2)]=$534;
   HEAP32[(($371)>>2)]=0;
   __ZN10rcIntArray6resizeEi($434, 0);
   var $_0 = 1;label = 125; break;
  case 125: 
   var $_0;
   var $535=(($423)|(0))==0;
   if ($535) { label = 127; break; } else { label = 126; break; }
  case 126: 
   var $537=$423;
   _free($537);
   label = 127; break;
  case 127: 
   if ($_0) { var $storemerge10 = 0;label = 128; break; } else { var $mergeCount_1 = $mergeCount_0;label = 146; break; }
  case 128: 
   var $storemerge10;
   var $539=(($storemerge10)|(0)) < (($7)|(0));
   if ($539) { label = 129; break; } else { label = 145; break; }
  case 129: 
   var $541=(($10+((($storemerge10)*(36))&-1)+4)|0);
   var $542=HEAP16[(($541)>>1)];
   var $543=(($542 << 16) >> 16)==0;
   var $544=(($542 << 16) >> 16) < 0;
   var $or_cond449=$543 | $544;
   if ($or_cond449) { label = 144; break; } else { label = 130; break; }
  case 130: 
   var $546=(($542 << 16) >> 16)==(($367 << 16) >> 16);
   if ($546) { label = 131; break; } else { label = 132; break; }
  case 131: 
   HEAP16[(($541)>>1)]=$mergeId_0;
   label = 132; break;
  case 132: 
   var $549=(($10+((($storemerge10)*(36))&-1))|0);
   var $550=(($10+((($storemerge10)*(36))&-1)+16)|0);
   var $551=(($10+((($storemerge10)*(36))&-1)+12)|0);
   var $storemerge_i21 = 0;var $neiChanged_i_0 = 0;label = 133; break;
  case 133: 
   var $neiChanged_i_0;
   var $storemerge_i21;
   var $553=HEAP32[(($550)>>2)];
   var $554=(($storemerge_i21)|(0)) < (($553)|(0));
   if ($554) { label = 134; break; } else { label = 137; break; }
  case 134: 
   var $556=HEAP32[(($551)>>2)];
   var $557=(($556+($storemerge_i21<<2))|0);
   var $558=HEAP32[(($557)>>2)];
   var $559=(($558)|(0))==(($436)|(0));
   if ($559) { label = 135; break; } else { var $neiChanged_i_1 = $neiChanged_i_0;label = 136; break; }
  case 135: 
   HEAP32[(($557)>>2)]=$416;
   var $neiChanged_i_1 = 1;label = 136; break;
  case 136: 
   var $neiChanged_i_1;
   var $562=((($storemerge_i21)+(1))|0);
   var $storemerge_i21 = $562;var $neiChanged_i_0 = $neiChanged_i_1;label = 133; break;
  case 137: 
   var $563=(($10+((($storemerge10)*(36))&-1)+28)|0);
   var $564=(($10+((($storemerge10)*(36))&-1)+24)|0);
   var $storemerge1_i22 = 0;label = 138; break;
  case 138: 
   var $storemerge1_i22;
   var $566=HEAP32[(($563)>>2)];
   var $567=(($storemerge1_i22)|(0)) < (($566)|(0));
   if ($567) { label = 139; break; } else { label = 142; break; }
  case 139: 
   var $569=HEAP32[(($564)>>2)];
   var $570=(($569+($storemerge1_i22<<2))|0);
   var $571=HEAP32[(($570)>>2)];
   var $572=(($571)|(0))==(($436)|(0));
   if ($572) { label = 140; break; } else { label = 141; break; }
  case 140: 
   HEAP32[(($570)>>2)]=$416;
   label = 141; break;
  case 141: 
   var $575=((($storemerge1_i22)+(1))|0);
   var $storemerge1_i22 = $575;label = 138; break;
  case 142: 
   var $577=$neiChanged_i_0 & 1;
   var $578=(($577 << 24) >> 24)==0;
   if ($578) { label = 144; break; } else { label = 143; break; }
  case 143: 
   __ZL24removeAdjacentNeighboursR8rcRegion($549);
   label = 144; break;
  case 144: 
   var $581=((($storemerge10)+(1))|0);
   var $storemerge10 = $581;label = 128; break;
  case 145: 
   var $583=((($mergeCount_0)+(1))|0);
   var $mergeCount_1 = $583;label = 146; break;
  case 146: 
   var $mergeCount_1;
   var $585=((($storemerge3)+(1))|0);
   var $storemerge3 = $585;var $mergeCount_0 = $mergeCount_1;label = 81; break;
  case 147: 
   var $587=(($mergeCount_0)|(0)) > 0;
   if ($587) { var $storemerge3 = 0;var $mergeCount_0 = 0;label = 81; break; } else { var $storemerge4 = 0;label = 148; break; }
  case 148: 
   var $storemerge4;
   var $588=(($storemerge4)|(0)) < (($7)|(0));
   if ($588) { label = 149; break; } else { var $storemerge5 = 0;var $regIdGen_0 = 0;label = 152; break; }
  case 149: 
   var $590=(($10+((($storemerge4)*(36))&-1)+7)|0);
   HEAP8[($590)]=0;
   var $591=(($10+((($storemerge4)*(36))&-1)+4)|0);
   var $592=HEAP16[(($591)>>1)];
   var $593=(($592 << 16) >> 16)==0;
   var $594=(($592 << 16) >> 16) < 0;
   var $or_cond450=$593 | $594;
   if ($or_cond450) { label = 151; break; } else { label = 150; break; }
  case 150: 
   HEAP8[($590)]=1;
   label = 151; break;
  case 151: 
   var $597=((($storemerge4)+(1))|0);
   var $storemerge4 = $597;label = 148; break;
  case 152: 
   var $regIdGen_0;
   var $storemerge5;
   var $599=(($storemerge5)|(0)) < (($7)|(0));
   if ($599) { label = 153; break; } else { label = 160; break; }
  case 153: 
   var $601=(($10+((($storemerge5)*(36))&-1)+7)|0);
   var $602=HEAP8[($601)];
   var $603=$602 & 1;
   var $604=(($603 << 24) >> 24)==0;
   if ($604) { var $regIdGen_1 = $regIdGen_0;label = 159; break; } else { label = 154; break; }
  case 154: 
   var $606=(($10+((($storemerge5)*(36))&-1)+4)|0);
   var $607=HEAP16[(($606)>>1)];
   var $608=((($regIdGen_0)+(1))&65535);
   var $storemerge8 = $storemerge5;label = 155; break;
  case 155: 
   var $storemerge8;
   var $610=(($storemerge8)|(0)) < (($7)|(0));
   if ($610) { label = 156; break; } else { var $regIdGen_1 = $608;label = 159; break; }
  case 156: 
   var $612=(($10+((($storemerge8)*(36))&-1)+4)|0);
   var $613=HEAP16[(($612)>>1)];
   var $614=(($613 << 16) >> 16)==(($607 << 16) >> 16);
   if ($614) { label = 157; break; } else { label = 158; break; }
  case 157: 
   HEAP16[(($612)>>1)]=$608;
   var $616=(($10+((($storemerge8)*(36))&-1)+7)|0);
   HEAP8[($616)]=0;
   label = 158; break;
  case 158: 
   var $618=((($storemerge8)+(1))|0);
   var $storemerge8 = $618;label = 155; break;
  case 159: 
   var $regIdGen_1;
   var $619=((($storemerge5)+(1))|0);
   var $storemerge5 = $619;var $regIdGen_0 = $regIdGen_1;label = 152; break;
  case 160: 
   HEAP16[(($maxRegionId)>>1)]=$regIdGen_0;
   var $621=(($chf+8)|0);
   var $storemerge6 = 0;label = 161; break;
  case 161: 
   var $storemerge6;
   var $623=HEAP32[(($621)>>2)];
   var $624=(($storemerge6)|(0)) < (($623)|(0));
   if ($624) { label = 162; break; } else { var $storemerge7 = 0;label = 165; break; }
  case 162: 
   var $626=(($srcReg+($storemerge6<<1))|0);
   var $627=HEAP16[(($626)>>1)];
   var $628=(($627 << 16) >> 16) > -1;
   if ($628) { label = 163; break; } else { label = 164; break; }
  case 163: 
   var $630=(($627)&(65535));
   var $631=(($10+((($630)*(36))&-1)+4)|0);
   var $632=HEAP16[(($631)>>1)];
   HEAP16[(($626)>>1)]=$632;
   label = 164; break;
  case 164: 
   var $634=((($storemerge6)+(1))|0);
   var $storemerge6 = $634;label = 161; break;
  case 165: 
   var $storemerge7;
   var $635=(($storemerge7)|(0)) < (($7)|(0));
   if ($635) { label = 166; break; } else { label = 171; break; }
  case 166: 
   var $637=(($10+((($storemerge7)*(36))&-1)+24)|0);
   var $638=HEAP32[(($637)>>2)];
   var $639=(($638)|(0))==0;
   if ($639) { label = 168; break; } else { label = 167; break; }
  case 167: 
   var $641=$638;
   _free($641);
   label = 168; break;
  case 168: 
   var $642=(($10+((($storemerge7)*(36))&-1)+12)|0);
   var $643=HEAP32[(($642)>>2)];
   var $644=(($643)|(0))==0;
   if ($644) { label = 170; break; } else { label = 169; break; }
  case 169: 
   var $646=$643;
   _free($646);
   label = 170; break;
  case 170: 
   var $648=((($storemerge7)+(1))|0);
   var $storemerge7 = $648;label = 165; break;
  case 171: 
   var $650=(($9)|(0))==0;
   if ($650) { label = 173; break; } else { label = 172; break; }
  case 172: 
   _free($9);
   label = 173; break;
  case 173: 
   var $652=HEAP32[(($260)>>2)];
   var $653=(($652)|(0))==0;
   if ($653) { label = 175; break; } else { label = 174; break; }
  case 174: 
   var $655=$652;
   _free($655);
   label = 175; break;
  case 175: 
   var $656=HEAP32[(($257)>>2)];
   var $657=(($656)|(0))==0;
   if ($657) { var $_0429 = 1;label = 177; break; } else { label = 176; break; }
  case 176: 
   var $659=$656;
   _free($659);
   var $_0429 = 1;label = 177; break;
  case 177: 
   var $_0429;
   STACKTOP = sp;
   return $_0429;
  default: assert(0, "bad label: " + label);
 }
}
function __Z14rcBuildRegionsP9rcContextR20rcCompactHeightfieldiii($ctx, $chf, $borderSize, $minRegionArea, $mergeRegionArea) {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 32)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $stack=sp;
   var $visited=(sp)+(16);
   var $1=(($ctx+5)|0);
   var $2=HEAP8[($1)];
   var $3=$2 & 1;
   var $4=(($3 << 24) >> 24)==0;
   if ($4) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $6=$ctx;
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7+20)|0);
   var $9=HEAP32[(($8)>>2)];
   FUNCTION_TABLE[$9]($ctx, 20);
   label = 3; break;
  case 3: 
   var $11=(($chf)|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=(($chf+4)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($chf+8)|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=$16 << 3;
   var $18=_malloc($17);
   var $19=$18;
   var $20=(($18)|(0))==0;
   if ($20) { label = 4; break; } else { label = 6; break; }
  case 4: 
   var $22=HEAP32[(($15)>>2)];
   var $23=$22 << 2;
   (function() { try { __THREW__ = 0; return __ZN9rcContext3logE13rcLogCategoryPKcz($ctx, 3, ((2504)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$23,tempVarArgs)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })(); STACKTOP=tempVarArgs;if (!__THREW__) { var $_0330 = 0;label = 82; break; } else { label = 5; break; }
  case 5: 
   var $25$0 = ___cxa_find_matching_catch(-1, -1); $25$1 = tempRet0;
   var $26=$25$0;
   var $27=$25$1;
   var $_0318 = $26;var $_0319 = $27;label = 83; break;
  case 6: 
   var $29=HEAP8[($1)];
   var $30=$29 & 1;
   var $31=(($30 << 24) >> 24)==0;
   if ($31) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $33=$ctx;
   var $34=HEAP32[(($33)>>2)];
   var $35=(($34+20)|0);
   var $36=HEAP32[(($35)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$36]($ctx, 21) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 8; break; } else { label = 5; break; }
  case 8: 
   var $38=(($stack)|0);
   HEAP32[(($38)>>2)]=0;
   var $39=(($stack+4)|0);
   HEAP32[(($39)>>2)]=0;
   var $40=(($stack+8)|0);
   HEAP32[(($40)>>2)]=0;
   __ZN10rcIntArray6resizeEi($stack, 1024);
   var $41=(($visited)|0);
   HEAP32[(($41)>>2)]=0;
   var $42=(($visited+4)|0);
   HEAP32[(($42)>>2)]=0;
   var $43=(($visited+8)|0);
   HEAP32[(($43)>>2)]=0;
   __ZN10rcIntArray6resizeEi($visited, 1024);
   var $44=HEAP32[(($15)>>2)];
   var $45=(($19+($44<<1))|0);
   var $46=$44 << 1;
   var $47=(($19+($46<<1))|0);
   var $48=((($44)*(3))&-1);
   var $49=(($19+($48<<1))|0);
   _memset($18, 0, $46);
   var $50=$45;
   var $51=HEAP32[(($15)>>2)];
   var $52=$51 << 1;
   _memset($50, 0, $52);
   var $53=(($chf+24)|0);
   var $54=HEAP16[(($53)>>1)];
   var $55=((($54)+(1))&65535);
   var $56=$55 & -2;
   var $57=(($borderSize)|(0)) > 0;
   if ($57) { label = 9; break; } else { var $srcReg_1 = $19;var $srcDist_1 = $45;var $level_1 = $56;var $regionId_1 = 1;var $dstDist_1 = $49;var $dstReg_1 = $47;label = 12; break; }
  case 9: 
   var $59=(($12)|(0)) < (($borderSize)|(0));
   var $60=$59 ? $12 : $borderSize;
   var $61=(($14)|(0)) < (($borderSize)|(0));
   var $62=$61 ? $14 : $borderSize;
   __ZL15paintRectRegioniiiitR20rcCompactHeightfieldPt(0, $60, 0, $14, -32767, $chf, $19);
   var $63=((($12)-($60))|0);
   __ZL15paintRectRegioniiiitR20rcCompactHeightfieldPt($63, $12, 0, $14, -32766, $chf, $19);
   __ZL15paintRectRegioniiiitR20rcCompactHeightfieldPt(0, $12, 0, $62, -32765, $chf, $19);
   var $64=((($14)-($62))|0);
   __ZL15paintRectRegioniiiitR20rcCompactHeightfieldPt(0, $12, $64, $14, -32764, $chf, $19);
   var $65=(($chf+20)|0);
   HEAP32[(($65)>>2)]=$borderSize;
   var $srcReg_1 = $19;var $srcDist_1 = $45;var $level_1 = $56;var $regionId_1 = 5;var $dstDist_1 = $49;var $dstReg_1 = $47;label = 12; break;
  case 10: 
   var $67$0 = ___cxa_find_matching_catch(-1, -1); $67$1 = tempRet0;
   var $68=$67$0;
   var $69=$67$1;
   var $70=HEAP32[(($41)>>2)];
   var $71=(($70)|(0))==0;
   if ($71) { label = 78; break; } else { label = 11; break; }
  case 11: 
   var $73=$70;
   _free($73);
   label = 78; break;
  case 12: 
   var $dstReg_1;
   var $dstDist_1;
   var $regionId_1;
   var $level_1;
   var $srcDist_1;
   var $srcReg_1;
   var $74=(($level_1 << 16) >> 16)==0;
   if ($74) { label = 60; break; } else { label = 13; break; }
  case 13: 
   var $75=(($level_1)&(65535)) > 1;
   var $76=((($level_1)-(2))&65535);
   var $_=$75 ? $76 : 0;
   var $77=HEAP8[($1)];
   var $78=$77 & 1;
   var $79=(($78 << 24) >> 24)==0;
   if ($79) { label = 15; break; } else { label = 14; break; }
  case 14: 
   var $81=$ctx;
   var $82=HEAP32[(($81)>>2)];
   var $83=(($82+20)|0);
   var $84=HEAP32[(($83)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$84]($ctx, 22) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 15; break; } else { label = 10; break; }
  case 15: 
   var $86=__ZL13expandRegionsitR20rcCompactHeightfieldPtS1_S1_S1_R10rcIntArray(8, $_, $chf, $srcReg_1, $srcDist_1, $dstReg_1, $dstDist_1, $stack);
   var $87=(($86)|(0))==(($srcReg_1)|(0));
   var $dstReg_1_srcReg_1=$87 ? $dstReg_1 : $srcReg_1;
   var $dstDist_1_srcDist_1=$87 ? $dstDist_1 : $srcDist_1;
   var $srcDist_1_dstDist_1=$87 ? $srcDist_1 : $dstDist_1;
   var $srcReg_1_dstReg_1=$87 ? $srcReg_1 : $dstReg_1;
   var $88=HEAP8[($1)];
   var $89=$88 & 1;
   var $90=(($89 << 24) >> 24)==0;
   if ($90) { var $97 = $88;label = 18; break; } else { label = 16; break; }
  case 16: 
   var $92=$ctx;
   var $93=HEAP32[(($92)>>2)];
   var $94=(($93+24)|0);
   var $95=HEAP32[(($94)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$95]($ctx, 22) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 17; break; } else { label = 10; break; }
  case 17: 
   var $_pre325=HEAP8[($1)];
   var $97 = $_pre325;label = 18; break;
  case 18: 
   var $97;
   var $98=$97 & 1;
   var $99=(($98 << 24) >> 24)==0;
   if ($99) { label = 20; break; } else { label = 19; break; }
  case 19: 
   var $101=$ctx;
   var $102=HEAP32[(($101)>>2)];
   var $103=(($102+20)|0);
   var $104=HEAP32[(($103)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$104]($ctx, 23) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 20; break; } else { label = 10; break; }
  case 20: 
   var $106=(($chf+60)|0);
   var $107=(($chf+68)|0);
   var $108=(($chf+72)|0);
   var $109=(($_)&(65535)) > 1;
   var $110=((($_)-(2))&65535);
   var $111=(($chf+64)|0);
   var $storemerge2 = 0;var $regionId_2 = $regionId_1;label = 21; break;
  case 21: 
   var $regionId_2;
   var $storemerge2;
   var $113=(($storemerge2)|(0)) < (($14)|(0));
   if ($113) { label = 22; break; } else { label = 58; break; }
  case 22: 
   var $114=(Math.imul($storemerge2,$12)|0);
   var $storemerge3 = 0;var $regionId_3 = $regionId_2;label = 23; break;
  case 23: 
   var $regionId_3;
   var $storemerge3;
   var $116=(($storemerge3)|(0)) < (($12)|(0));
   if ($116) { label = 24; break; } else { label = 57; break; }
  case 24: 
   var $118=((($storemerge3)+($114))|0);
   var $119=HEAP32[(($106)>>2)];
   var $120=(($119+($118<<2))|0);
   var $121=$120;
   var $122=HEAP32[(($121)>>2)];
   var $123=$122 & 16777215;
   var $124=$122 >>> 24;
   var $125=((($123)+($124))|0);
   var $i_0 = $123;var $regionId_4 = $regionId_3;label = 25; break;
  case 25: 
   var $regionId_4;
   var $i_0;
   var $127=(($i_0)|(0)) < (($125)|(0));
   if ($127) { label = 26; break; } else { label = 56; break; }
  case 26: 
   var $129=HEAP32[(($107)>>2)];
   var $130=(($129+($i_0<<1))|0);
   var $131=HEAP16[(($130)>>1)];
   var $132=(($131)&(65535)) < (($_)&(65535));
   if ($132) { var $regionId_5 = $regionId_4;label = 55; break; } else { label = 27; break; }
  case 27: 
   var $134=(($srcReg_1_dstReg_1+($i_0<<1))|0);
   var $135=HEAP16[(($134)>>1)];
   var $136=(($135 << 16) >> 16)==0;
   if ($136) { label = 28; break; } else { var $regionId_5 = $regionId_4;label = 55; break; }
  case 28: 
   var $138=HEAP32[(($108)>>2)];
   var $139=(($138+$i_0)|0);
   var $140=HEAP8[($139)];
   var $141=(($140 << 24) >> 24)==0;
   if ($141) { var $regionId_5 = $regionId_4;label = 55; break; } else { label = 29; break; }
  case 29: 
   var $143=HEAP32[(($11)>>2)];
   __ZN10rcIntArray6resizeEi($stack, 0);
   var $144=HEAP32[(($39)>>2)];
   var $145=((($144)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $145);
   var $146=HEAP32[(($39)>>2)];
   var $147=((($146)-(1))|0);
   var $148=HEAP32[(($38)>>2)];
   var $149=(($148+($147<<2))|0);
   HEAP32[(($149)>>2)]=$storemerge3;
   var $150=((($146)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $150);
   var $151=HEAP32[(($39)>>2)];
   var $152=((($151)-(1))|0);
   var $153=HEAP32[(($38)>>2)];
   var $154=(($153+($152<<2))|0);
   HEAP32[(($154)>>2)]=$storemerge2;
   var $155=((($151)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $155);
   var $156=HEAP32[(($39)>>2)];
   var $157=((($156)-(1))|0);
   var $158=HEAP32[(($38)>>2)];
   var $159=(($158+($157<<2))|0);
   HEAP32[(($159)>>2)]=$i_0;
   HEAP16[(($134)>>1)]=$regionId_4;
   var $160=(($srcDist_1_dstDist_1+($i_0<<1))|0);
   HEAP16[(($160)>>1)]=0;
   var $_331=$109 ? $110 : 0;
   var $count_i_0_ph = 0;label = 30; break;
  case 30: 
   var $count_i_0_ph;
   label = 31; break;
  case 31: 
   var $162=HEAP32[(($39)>>2)];
   var $163=(($162)|(0)) > 0;
   if ($163) { label = 32; break; } else { label = 54; break; }
  case 32: 
   var $164=((($162)-(1))|0);
   HEAP32[(($39)>>2)]=$164;
   var $165=HEAP32[(($38)>>2)];
   var $166=(($165+($164<<2))|0);
   var $167=HEAP32[(($166)>>2)];
   var $168=(($164)|(0)) > 0;
   if ($168) { label = 33; break; } else { var $174 = $167;var $173 = $167;label = 35; break; }
  case 33: 
   var $169=((($164)-(1))|0);
   HEAP32[(($39)>>2)]=$169;
   var $_phi_trans_insert=(($165+($169<<2))|0);
   var $_pre=HEAP32[(($_phi_trans_insert)>>2)];
   var $170=(($169)|(0)) > 0;
   if ($170) { label = 34; break; } else { var $174 = $_pre;var $173 = $_pre;label = 35; break; }
  case 34: 
   var $172=((($169)-(1))|0);
   HEAP32[(($39)>>2)]=$172;
   var $_phi_trans_insert320=(($165+($172<<2))|0);
   var $_pre321=HEAP32[(($_phi_trans_insert320)>>2)];
   var $174 = $_pre321;var $173 = $_pre;label = 35; break;
  case 35: 
   var $173;
   var $174;
   var $175=HEAP32[(($111)>>2)];
   var $176=(($175+($167<<3)+4)|0);
   var $177=$176;
   var $storemerge_i = 0;var $ar_i_0 = 0;label = 36; break;
  case 36: 
   var $ar_i_0;
   var $storemerge_i;
   var $179=(($storemerge_i)|(0)) < 4;
   if ($179) { label = 37; break; } else { label = 44; break; }
  case 37: 
   var $181=((($storemerge_i)*(6))&-1);
   var $182=HEAP32[(($177)>>2)];
   var $183=$182 & 16777215;
   var $184=$183 >>> (($181)>>>(0));
   var $185=$184 & 63;
   var $186=(($185)|(0))==63;
   if ($186) { var $ar_i_2 = $ar_i_0;label = 43; break; } else { label = 38; break; }
  case 38: 
   var $188=$storemerge_i & 3;
   var $189=((6640+($188<<2))|0);
   var $190=HEAP32[(($189)>>2)];
   var $191=((($174)+($190))|0);
   var $192=((6624+($188<<2))|0);
   var $193=HEAP32[(($192)>>2)];
   var $194=((($173)+($193))|0);
   var $195=(Math.imul($194,$143)|0);
   var $196=((($191)+($195))|0);
   var $197=HEAP32[(($106)>>2)];
   var $198=(($197+($196<<2))|0);
   var $199=$198;
   var $200=HEAP32[(($199)>>2)];
   var $201=$200 & 16777215;
   var $202=((($201)+($185))|0);
   var $203=HEAP32[(($108)>>2)];
   var $204=(($203+$202)|0);
   var $205=HEAP8[($204)];
   var $206=(($205 << 24) >> 24)==(($140 << 24) >> 24);
   if ($206) { label = 39; break; } else { var $ar_i_2 = $ar_i_0;label = 43; break; }
  case 39: 
   var $208=(($srcReg_1_dstReg_1+($202<<1))|0);
   var $209=HEAP16[(($208)>>1)];
   var $210=(($209 << 16) >> 16) < 0;
   if ($210) { var $ar_i_2 = $ar_i_0;label = 43; break; } else { label = 40; break; }
  case 40: 
   var $212=(($209 << 16) >> 16)==0;
   var $213=(($209 << 16) >> 16)==(($regionId_4 << 16) >> 16);
   var $or_cond=$212 | $213;
   var $ar_i_1=$or_cond ? $ar_i_0 : $209;
   var $214=((($storemerge_i)+(1))|0);
   var $215=$214 & 3;
   var $216=((($215)*(6))&-1);
   var $217=(($175+($202<<3)+4)|0);
   var $218=$217;
   var $219=HEAP32[(($218)>>2)];
   var $220=$219 & 16777215;
   var $221=$220 >>> (($216)>>>(0));
   var $222=$221 & 63;
   var $223=(($222)|(0))==63;
   if ($223) { var $ar_i_2 = $ar_i_1;label = 43; break; } else { label = 41; break; }
  case 41: 
   var $225=((6640+($215<<2))|0);
   var $226=HEAP32[(($225)>>2)];
   var $227=((($191)+($226))|0);
   var $228=((6624+($215<<2))|0);
   var $229=HEAP32[(($228)>>2)];
   var $230=((($194)+($229))|0);
   var $231=(Math.imul($230,$143)|0);
   var $232=((($227)+($231))|0);
   var $233=(($197+($232<<2))|0);
   var $234=$233;
   var $235=HEAP32[(($234)>>2)];
   var $236=$235 & 16777215;
   var $237=((($236)+($222))|0);
   var $238=(($203+$237)|0);
   var $239=HEAP8[($238)];
   var $240=(($239 << 24) >> 24)==(($140 << 24) >> 24);
   if ($240) { label = 42; break; } else { var $ar_i_2 = $ar_i_1;label = 43; break; }
  case 42: 
   var $242=(($srcReg_1_dstReg_1+($237<<1))|0);
   var $243=HEAP16[(($242)>>1)];
   var $244=(($243 << 16) >> 16)==0;
   var $245=(($243 << 16) >> 16)==(($regionId_4 << 16) >> 16);
   var $or_cond332=$244 | $245;
   var $ar_i_1_=$or_cond332 ? $ar_i_1 : $243;
   var $ar_i_2 = $ar_i_1_;label = 43; break;
  case 43: 
   var $ar_i_2;
   var $247=((($storemerge_i)+(1))|0);
   var $storemerge_i = $247;var $ar_i_0 = $ar_i_2;label = 36; break;
  case 44: 
   var $249=(($ar_i_0 << 16) >> 16)==0;
   if ($249) { label = 46; break; } else { label = 45; break; }
  case 45: 
   var $251=(($srcReg_1_dstReg_1+($167<<1))|0);
   HEAP16[(($251)>>1)]=0;
   label = 31; break;
  case 46: 
   var $253=((($count_i_0_ph)+(1))|0);
   var $storemerge1_i = 0;label = 47; break;
  case 47: 
   var $storemerge1_i;
   var $255=(($storemerge1_i)|(0)) < 4;
   if ($255) { label = 48; break; } else { var $count_i_0_ph = $253;label = 30; break; }
  case 48: 
   var $257=((($storemerge1_i)*(6))&-1);
   var $258=HEAP32[(($177)>>2)];
   var $259=$258 & 16777215;
   var $260=$259 >>> (($257)>>>(0));
   var $261=$260 & 63;
   var $262=(($261)|(0))==63;
   if ($262) { label = 53; break; } else { label = 49; break; }
  case 49: 
   var $264=$storemerge1_i & 3;
   var $265=((6640+($264<<2))|0);
   var $266=HEAP32[(($265)>>2)];
   var $267=((($174)+($266))|0);
   var $268=((6624+($264<<2))|0);
   var $269=HEAP32[(($268)>>2)];
   var $270=((($173)+($269))|0);
   var $271=(Math.imul($270,$143)|0);
   var $272=((($267)+($271))|0);
   var $273=HEAP32[(($106)>>2)];
   var $274=(($273+($272<<2))|0);
   var $275=$274;
   var $276=HEAP32[(($275)>>2)];
   var $277=$276 & 16777215;
   var $278=((($277)+($261))|0);
   var $279=HEAP32[(($108)>>2)];
   var $280=(($279+$278)|0);
   var $281=HEAP8[($280)];
   var $282=(($281 << 24) >> 24)==(($140 << 24) >> 24);
   if ($282) { label = 50; break; } else { label = 53; break; }
  case 50: 
   var $284=HEAP32[(($107)>>2)];
   var $285=(($284+($278<<1))|0);
   var $286=HEAP16[(($285)>>1)];
   var $287=(($286)&(65535)) < (($_331)&(65535));
   if ($287) { label = 53; break; } else { label = 51; break; }
  case 51: 
   var $289=(($srcReg_1_dstReg_1+($278<<1))|0);
   var $290=HEAP16[(($289)>>1)];
   var $291=(($290 << 16) >> 16)==0;
   if ($291) { label = 52; break; } else { label = 53; break; }
  case 52: 
   HEAP16[(($289)>>1)]=$regionId_4;
   var $293=(($srcDist_1_dstDist_1+($278<<1))|0);
   HEAP16[(($293)>>1)]=0;
   var $294=HEAP32[(($39)>>2)];
   var $295=((($294)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $295);
   var $296=HEAP32[(($39)>>2)];
   var $297=((($296)-(1))|0);
   var $298=HEAP32[(($38)>>2)];
   var $299=(($298+($297<<2))|0);
   HEAP32[(($299)>>2)]=$267;
   var $300=((($296)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $300);
   var $301=HEAP32[(($39)>>2)];
   var $302=((($301)-(1))|0);
   var $303=HEAP32[(($38)>>2)];
   var $304=(($303+($302<<2))|0);
   HEAP32[(($304)>>2)]=$270;
   var $305=((($301)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $305);
   var $306=HEAP32[(($39)>>2)];
   var $307=((($306)-(1))|0);
   var $308=HEAP32[(($38)>>2)];
   var $309=(($308+($307<<2))|0);
   HEAP32[(($309)>>2)]=$278;
   label = 53; break;
  case 53: 
   var $311=((($storemerge1_i)+(1))|0);
   var $storemerge1_i = $311;label = 47; break;
  case 54: 
   var $313=(($count_i_0_ph)|(0)) > 0;
   var $314=((($regionId_4)+(1))&65535);
   var $_regionId_4=$313 ? $314 : $regionId_4;
   var $regionId_5 = $_regionId_4;label = 55; break;
  case 55: 
   var $regionId_5;
   var $316=((($i_0)+(1))|0);
   var $i_0 = $316;var $regionId_4 = $regionId_5;label = 25; break;
  case 56: 
   var $318=((($storemerge3)+(1))|0);
   var $storemerge3 = $318;var $regionId_3 = $regionId_4;label = 23; break;
  case 57: 
   var $320=((($storemerge2)+(1))|0);
   var $storemerge2 = $320;var $regionId_2 = $regionId_3;label = 21; break;
  case 58: 
   var $322=HEAP8[($1)];
   var $323=$322 & 1;
   var $324=(($323 << 24) >> 24)==0;
   if ($324) { var $srcReg_1 = $srcReg_1_dstReg_1;var $srcDist_1 = $srcDist_1_dstDist_1;var $level_1 = $_;var $regionId_1 = $regionId_2;var $dstDist_1 = $dstDist_1_srcDist_1;var $dstReg_1 = $dstReg_1_srcReg_1;label = 12; break; } else { label = 59; break; }
  case 59: 
   var $326=$ctx;
   var $327=HEAP32[(($326)>>2)];
   var $328=(($327+24)|0);
   var $329=HEAP32[(($328)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$329]($ctx, 23) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $srcReg_1 = $srcReg_1_dstReg_1;var $srcDist_1 = $srcDist_1_dstDist_1;var $level_1 = $_;var $regionId_1 = $regionId_2;var $dstDist_1 = $dstDist_1_srcDist_1;var $dstReg_1 = $dstReg_1_srcReg_1;label = 12; break; } else { label = 10; break; }
  case 60: 
   var $331=__ZL13expandRegionsitR20rcCompactHeightfieldPtS1_S1_S1_R10rcIntArray(64, 0, $chf, $srcReg_1, $srcDist_1, $dstReg_1, $dstDist_1, $stack);
   var $332=(($331)|(0))==(($srcReg_1)|(0));
   var $srcReg_1_dstReg_1333=$332 ? $srcReg_1 : $dstReg_1;
   var $333=HEAP8[($1)];
   var $334=$333 & 1;
   var $335=(($334 << 24) >> 24)==0;
   if ($335) { var $342 = $333;label = 63; break; } else { label = 61; break; }
  case 61: 
   var $337=$ctx;
   var $338=HEAP32[(($337)>>2)];
   var $339=(($338+24)|0);
   var $340=HEAP32[(($339)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$340]($ctx, 21) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 62; break; } else { label = 10; break; }
  case 62: 
   var $_pre324=HEAP8[($1)];
   var $342 = $_pre324;label = 63; break;
  case 63: 
   var $342;
   var $343=$342 & 1;
   var $344=(($343 << 24) >> 24)==0;
   if ($344) { label = 65; break; } else { label = 64; break; }
  case 64: 
   var $346=$ctx;
   var $347=HEAP32[(($346)>>2)];
   var $348=(($347+20)|0);
   var $349=HEAP32[(($348)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$349]($ctx, 24) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 65; break; } else { label = 10; break; }
  case 65: 
   var $351=(($chf+26)|0);
   HEAP16[(($351)>>1)]=$regionId_1;
   var $352 = (function() { try { __THREW__ = 0; return __ZL18filterSmallRegionsP9rcContextiiRtR20rcCompactHeightfieldPt($ctx, $minRegionArea, $mergeRegionArea, $351, $chf, $srcReg_1_dstReg_1333) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 66; break; } else { label = 10; break; }
  case 66: 
   if ($352) { label = 67; break; } else { var $storemerge1 = 0;label = 74; break; }
  case 67: 
   var $355=HEAP8[($1)];
   var $356=$355 & 1;
   var $357=(($356 << 24) >> 24)==0;
   if ($357) { label = 69; break; } else { label = 68; break; }
  case 68: 
   var $359=$ctx;
   var $360=HEAP32[(($359)>>2)];
   var $361=(($360+24)|0);
   var $362=HEAP32[(($361)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$362]($ctx, 24) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 69; break; } else { label = 10; break; }
  case 69: 
   var $364=(($chf+64)|0);
   var $storemerge = 0;label = 70; break;
  case 70: 
   var $storemerge;
   var $366=HEAP32[(($15)>>2)];
   var $367=(($storemerge)|(0)) < (($366)|(0));
   if ($367) { label = 71; break; } else { label = 72; break; }
  case 71: 
   var $369=(($srcReg_1_dstReg_1333+($storemerge<<1))|0);
   var $370=HEAP16[(($369)>>1)];
   var $371=HEAP32[(($364)>>2)];
   var $372=(($371+($storemerge<<3)+2)|0);
   HEAP16[(($372)>>1)]=$370;
   var $373=((($storemerge)+(1))|0);
   var $storemerge = $373;label = 70; break;
  case 72: 
   var $375=HEAP8[($1)];
   var $376=$375 & 1;
   var $377=(($376 << 24) >> 24)==0;
   if ($377) { var $storemerge1 = 1;label = 74; break; } else { label = 73; break; }
  case 73: 
   var $379=$ctx;
   var $380=HEAP32[(($379)>>2)];
   var $381=(($380+24)|0);
   var $382=HEAP32[(($381)>>2)];
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$382]($ctx, 20) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { var $storemerge1 = 1;label = 74; break; } else { label = 10; break; }
  case 74: 
   var $storemerge1;
   var $384=HEAP32[(($41)>>2)];
   var $385=(($384)|(0))==0;
   if ($385) { label = 76; break; } else { label = 75; break; }
  case 75: 
   var $387=$384;
   _free($387);
   label = 76; break;
  case 76: 
   var $388=HEAP32[(($38)>>2)];
   var $389=(($388)|(0))==0;
   if ($389) { label = 80; break; } else { label = 77; break; }
  case 77: 
   var $391=$388;
   _free($391);
   label = 80; break;
  case 78: 
   var $392=HEAP32[(($38)>>2)];
   var $393=(($392)|(0))==0;
   if ($393) { var $_0318 = $68;var $_0319 = $69;label = 83; break; } else { label = 79; break; }
  case 79: 
   var $395=$392;
   _free($395);
   var $_0318 = $68;var $_0319 = $69;label = 83; break;
  case 80: 
   if ($20) { var $_0330 = $storemerge1;label = 82; break; } else { label = 81; break; }
  case 81: 
   _free($18);
   var $_0330 = $storemerge1;label = 82; break;
  case 82: 
   var $_0330;
   STACKTOP = sp;
   return $_0330;
  case 83: 
   var $_0319;
   var $_0318;
   if ($20) { label = 85; break; } else { label = 84; break; }
  case 84: 
   _free($18);
   label = 85; break;
  case 85: 
   var $399$0=$_0318;
   var $399$1=0;
   var $400$0=$399$0;
   var $400$1=$_0319;
   ___resumeException($400$0)
  default: assert(0, "bad label: " + label);
 }
}
function __ZL13expandRegionsitR20rcCompactHeightfieldPtS1_S1_S1_R10rcIntArray($maxIter, $level, $chf, $srcReg, $srcDist, $dstReg, $dstDist, $stack) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($chf)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($chf+4)|0);
   var $4=HEAP32[(($3)>>2)];
   __ZN10rcIntArray6resizeEi($stack, 0);
   var $5=(($chf+60)|0);
   var $6=(($chf+68)|0);
   var $7=(($chf+72)|0);
   var $8=(($stack+4)|0);
   var $9=(($stack)|0);
   var $storemerge = 0;label = 2; break;
  case 2: 
   var $storemerge;
   var $11=(($storemerge)|(0)) < (($4)|(0));
   if ($11) { label = 3; break; } else { label = 14; break; }
  case 3: 
   var $12=(Math.imul($storemerge,$2)|0);
   var $storemerge3 = 0;label = 4; break;
  case 4: 
   var $storemerge3;
   var $14=(($storemerge3)|(0)) < (($2)|(0));
   if ($14) { label = 5; break; } else { label = 13; break; }
  case 5: 
   var $16=((($storemerge3)+($12))|0);
   var $17=HEAP32[(($5)>>2)];
   var $18=(($17+($16<<2))|0);
   var $19=$18;
   var $20=HEAP32[(($19)>>2)];
   var $21=$20 & 16777215;
   var $22=$20 >>> 24;
   var $23=((($21)+($22))|0);
   var $i_0 = $21;label = 6; break;
  case 6: 
   var $i_0;
   var $25=(($i_0)|(0)) < (($23)|(0));
   if ($25) { label = 7; break; } else { label = 12; break; }
  case 7: 
   var $27=HEAP32[(($6)>>2)];
   var $28=(($27+($i_0<<1))|0);
   var $29=HEAP16[(($28)>>1)];
   var $30=(($29)&(65535)) < (($level)&(65535));
   if ($30) { label = 11; break; } else { label = 8; break; }
  case 8: 
   var $32=(($srcReg+($i_0<<1))|0);
   var $33=HEAP16[(($32)>>1)];
   var $34=(($33 << 16) >> 16)==0;
   if ($34) { label = 9; break; } else { label = 11; break; }
  case 9: 
   var $36=HEAP32[(($7)>>2)];
   var $37=(($36+$i_0)|0);
   var $38=HEAP8[($37)];
   var $39=(($38 << 24) >> 24)==0;
   if ($39) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $41=HEAP32[(($8)>>2)];
   var $42=((($41)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $42);
   var $43=HEAP32[(($8)>>2)];
   var $44=((($43)-(1))|0);
   var $45=HEAP32[(($9)>>2)];
   var $46=(($45+($44<<2))|0);
   HEAP32[(($46)>>2)]=$storemerge3;
   var $47=HEAP32[(($8)>>2)];
   var $48=((($47)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $48);
   var $49=HEAP32[(($8)>>2)];
   var $50=((($49)-(1))|0);
   var $51=HEAP32[(($9)>>2)];
   var $52=(($51+($50<<2))|0);
   HEAP32[(($52)>>2)]=$storemerge;
   var $53=HEAP32[(($8)>>2)];
   var $54=((($53)+(1))|0);
   __ZN10rcIntArray6resizeEi($stack, $54);
   var $55=HEAP32[(($8)>>2)];
   var $56=((($55)-(1))|0);
   var $57=HEAP32[(($9)>>2)];
   var $58=(($57+($56<<2))|0);
   HEAP32[(($58)>>2)]=$i_0;
   label = 11; break;
  case 11: 
   var $60=((($i_0)+(1))|0);
   var $i_0 = $60;label = 6; break;
  case 12: 
   var $62=((($storemerge3)+(1))|0);
   var $storemerge3 = $62;label = 4; break;
  case 13: 
   var $64=((($storemerge)+(1))|0);
   var $storemerge = $64;label = 2; break;
  case 14: 
   var $66=(($chf+8)|0);
   var $67=(($chf+64)|0);
   var $68=(($level << 16) >> 16)==0;
   var $_pre_pre=HEAP32[(($8)>>2)];
   var $_0_ph = $srcReg;var $_084_ph = $srcDist;var $_085_ph = $dstReg;var $_086_ph = $dstDist;var $iter_0_ph = 0;var $_pre = $_pre_pre;label = 15; break;
  case 15: 
   var $_pre;
   var $iter_0_ph;
   var $_086_ph;
   var $_085_ph;
   var $_084_ph;
   var $_0_ph;
   var $_0 = $_0_ph;var $_084 = $_084_ph;var $_085 = $_085_ph;var $_086 = $_086_ph;var $70 = $_pre;label = 16; break;
  case 16: 
   var $70;
   var $_086;
   var $_085;
   var $_084;
   var $_0;
   var $71=(($70)|(0)) > 0;
   if ($71) { label = 17; break; } else { var $_1 = $_0;label = 35; break; }
  case 17: 
   var $73=$_085;
   var $74=$_0;
   var $75=HEAP32[(($66)>>2)];
   var $76=$75 << 1;
   assert($76 % 1 === 0);(_memcpy($73, $74, $76)|0);
   var $77=$_086;
   var $78=$_084;
   var $79=HEAP32[(($66)>>2)];
   var $80=$79 << 1;
   assert($80 % 1 === 0);(_memcpy($77, $78, $80)|0);
   var $storemerge1 = 0;var $failed_0 = 0;label = 18; break;
  case 18: 
   var $failed_0;
   var $storemerge1;
   var $82=HEAP32[(($8)>>2)];
   var $83=(($storemerge1)|(0)) < (($82)|(0));
   if ($83) { label = 19; break; } else { label = 32; break; }
  case 19: 
   var $85=HEAP32[(($9)>>2)];
   var $86=(($85+($storemerge1<<2))|0);
   var $87=HEAP32[(($86)>>2)];
   var $88=((($storemerge1)+(1))|0);
   var $89=(($85+($88<<2))|0);
   var $90=HEAP32[(($89)>>2)];
   var $91=((($storemerge1)+(2))|0);
   var $92=(($85+($91<<2))|0);
   var $93=HEAP32[(($92)>>2)];
   var $94=(($93)|(0)) < 0;
   if ($94) { label = 20; break; } else { label = 21; break; }
  case 20: 
   var $96=((($failed_0)+(1))|0);
   var $failed_1 = $96;label = 31; break;
  case 21: 
   var $98=(($_0+($93<<1))|0);
   var $99=HEAP16[(($98)>>1)];
   var $100=HEAP32[(($7)>>2)];
   var $101=(($100+$93)|0);
   var $102=HEAP8[($101)];
   var $103=HEAP32[(($67)>>2)];
   var $104=(($103+($93<<3)+4)|0);
   var $105=$104;
   var $storemerge2 = 0;var $d2_0 = -1;var $r_0 = $99;label = 22; break;
  case 22: 
   var $r_0;
   var $d2_0;
   var $storemerge2;
   var $107=(($storemerge2)|(0)) < 4;
   if ($107) { label = 23; break; } else { label = 28; break; }
  case 23: 
   var $109=((($storemerge2)*(6))&-1);
   var $110=HEAP32[(($105)>>2)];
   var $111=$110 & 16777215;
   var $112=$111 >>> (($109)>>>(0));
   var $113=$112 & 63;
   var $114=(($113)|(0))==63;
   if ($114) { var $d2_1 = $d2_0;var $r_1 = $r_0;label = 27; break; } else { label = 24; break; }
  case 24: 
   var $116=$storemerge2 & 3;
   var $117=((6640+($116<<2))|0);
   var $118=HEAP32[(($117)>>2)];
   var $119=((($87)+($118))|0);
   var $120=((6624+($116<<2))|0);
   var $121=HEAP32[(($120)>>2)];
   var $122=((($90)+($121))|0);
   var $123=(Math.imul($122,$2)|0);
   var $124=((($119)+($123))|0);
   var $125=HEAP32[(($5)>>2)];
   var $126=(($125+($124<<2))|0);
   var $127=$126;
   var $128=HEAP32[(($127)>>2)];
   var $129=$128 & 16777215;
   var $130=((($129)+($113))|0);
   var $131=(($100+$130)|0);
   var $132=HEAP8[($131)];
   var $133=(($132 << 24) >> 24)==(($102 << 24) >> 24);
   if ($133) { label = 25; break; } else { var $d2_1 = $d2_0;var $r_1 = $r_0;label = 27; break; }
  case 25: 
   var $135=(($_0+($130<<1))|0);
   var $136=HEAP16[(($135)>>1)];
   var $137=(($136 << 16) >> 16)!=0;
   var $138=(($136 << 16) >> 16) > -1;
   var $or_cond=$137 & $138;
   if ($or_cond) { label = 26; break; } else { var $d2_1 = $d2_0;var $r_1 = $r_0;label = 27; break; }
  case 26: 
   var $140=(($_084+($130<<1))|0);
   var $141=HEAP16[(($140)>>1)];
   var $142=(($141)&(65535));
   var $143=((($142)+(2))|0);
   var $144=(($d2_0)&(65535));
   var $145=(($143)>>>(0)) < (($144)>>>(0));
   var $146=((($141)+(2))&65535);
   var $_r_0=$145 ? $136 : $r_0;
   var $_d2_0=$145 ? $146 : $d2_0;
   var $d2_1 = $_d2_0;var $r_1 = $_r_0;label = 27; break;
  case 27: 
   var $r_1;
   var $d2_1;
   var $148=((($storemerge2)+(1))|0);
   var $storemerge2 = $148;var $d2_0 = $d2_1;var $r_0 = $r_1;label = 22; break;
  case 28: 
   var $150=(($r_0 << 16) >> 16)==0;
   if ($150) { label = 30; break; } else { label = 29; break; }
  case 29: 
   HEAP32[(($92)>>2)]=-1;
   var $152=(($_085+($93<<1))|0);
   HEAP16[(($152)>>1)]=$r_0;
   var $153=(($_086+($93<<1))|0);
   HEAP16[(($153)>>1)]=$d2_0;
   var $failed_1 = $failed_0;label = 31; break;
  case 30: 
   var $155=((($failed_0)+(1))|0);
   var $failed_1 = $155;label = 31; break;
  case 31: 
   var $failed_1;
   var $157=((($storemerge1)+(3))|0);
   var $storemerge1 = $157;var $failed_0 = $failed_1;label = 18; break;
  case 32: 
   var $159=((($failed_0)*(3))&-1);
   var $160=(($159)|(0))==(($82)|(0));
   if ($160) { var $_1 = $_085;label = 35; break; } else { label = 33; break; }
  case 33: 
   if ($68) { var $_086$phi = $_084;var $_085$phi = $_0;var $_0 = $_085;var $_084 = $_086;var $70 = $82;var $_086 = $_086$phi;var $_085 = $_085$phi;label = 16; break; } else { label = 34; break; }
  case 34: 
   var $163=((($iter_0_ph)+(1))|0);
   var $164=(($163)|(0)) < (($maxIter)|(0));
   if ($164) { var $_0_ph = $_085;var $_084_ph = $_086;var $_085_ph = $_0;var $_086_ph = $_084;var $iter_0_ph = $163;var $_pre = $82;label = 15; break; } else { var $_1 = $_085;label = 35; break; }
  case 35: 
   var $_1;
   return $_1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12compareItemXPKvS0_336($va, $vb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=$va;
   var $2=HEAPF32[(($1)>>2)];
   var $3=$vb;
   var $4=HEAPF32[(($3)>>2)];
   var $5=$2 < $4;
   if ($5) { var $_0 = -1;label = 4; break; } else { label = 2; break; }
  case 2: 
   var $7=$2 > $4;
   if ($7) { var $_0 = 1;label = 4; break; } else { label = 3; break; }
  case 3: 
   var $_0 = 0;label = 4; break;
  case 4: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL11isSolidEdgeR20rcCompactHeightfieldPtiiii($chf, $srcReg, $x, $y, $i, $dir) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($chf+64)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=((($dir)*(6))&-1);
   var $4=(($2+($i<<3)+4)|0);
   var $5=$4;
   var $6=HEAP32[(($5)>>2)];
   var $7=$6 & 16777215;
   var $8=$7 >>> (($3)>>>(0));
   var $9=$8 & 63;
   var $10=(($9)|(0))==63;
   if ($10) { var $r_0 = 0;label = 3; break; } else { label = 2; break; }
  case 2: 
   var $12=$dir & 3;
   var $13=((6640+($12<<2))|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=((($14)+($x))|0);
   var $16=((6624+($12<<2))|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=((($17)+($y))|0);
   var $19=(($chf)|0);
   var $20=HEAP32[(($19)>>2)];
   var $21=(Math.imul($18,$20)|0);
   var $22=((($15)+($21))|0);
   var $23=(($chf+60)|0);
   var $24=HEAP32[(($23)>>2)];
   var $25=(($24+($22<<2))|0);
   var $26=$25;
   var $27=HEAP32[(($26)>>2)];
   var $28=$27 & 16777215;
   var $29=((($28)+($9))|0);
   var $30=(($srcReg+($29<<1))|0);
   var $31=HEAP16[(($30)>>1)];
   var $r_0 = $31;label = 3; break;
  case 3: 
   var $r_0;
   var $33=(($srcReg+($i<<1))|0);
   var $34=HEAP16[(($33)>>1)];
   var $35=(($r_0 << 16) >> 16)==(($34 << 16) >> 16);
   var $_=$35 ? 0 : 1;
   return $_;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL18canMergeWithRegionRK8rcRegionS1_($rega, $regb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($rega+6)|0);
   var $2=HEAP8[($1)];
   var $3=(($regb+6)|0);
   var $4=HEAP8[($3)];
   var $5=(($2 << 24) >> 24)==(($4 << 24) >> 24);
   if ($5) { label = 2; break; } else { var $_0 = 0;label = 10; break; }
  case 2: 
   var $7=(($rega+16)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($rega+12)|0);
   var $10=(($regb+4)|0);
   var $storemerge = 0;var $n_0 = 0;label = 3; break;
  case 3: 
   var $n_0;
   var $storemerge;
   var $12=(($storemerge)|(0)) < (($8)|(0));
   if ($12) { label = 4; break; } else { label = 5; break; }
  case 4: 
   var $14=HEAP32[(($9)>>2)];
   var $15=(($14+($storemerge<<2))|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=HEAP16[(($10)>>1)];
   var $18=(($17)&(65535));
   var $19=(($16)|(0))==(($18)|(0));
   var $20=((($n_0)+(1))|0);
   var $_n_0=$19 ? $20 : $n_0;
   var $21=((($storemerge)+(1))|0);
   var $storemerge = $21;var $n_0 = $_n_0;label = 3; break;
  case 5: 
   var $23=(($n_0)|(0)) > 1;
   if ($23) { var $_0 = 0;label = 10; break; } else { label = 6; break; }
  case 6: 
   var $24=(($rega+28)|0);
   var $25=HEAP32[(($24)>>2)];
   var $26=(($rega+24)|0);
   var $storemerge1 = 0;label = 7; break;
  case 7: 
   var $storemerge1;
   var $28=(($storemerge1)|(0)) < (($25)|(0));
   if ($28) { label = 8; break; } else { var $_0 = 1;label = 10; break; }
  case 8: 
   var $30=HEAP32[(($26)>>2)];
   var $31=(($30+($storemerge1<<2))|0);
   var $32=HEAP32[(($31)>>2)];
   var $33=HEAP16[(($10)>>1)];
   var $34=(($33)&(65535));
   var $35=(($32)|(0))==(($34)|(0));
   if ($35) { var $_0 = 0;label = 10; break; } else { label = 9; break; }
  case 9: 
   var $37=((($storemerge1)+(1))|0);
   var $storemerge1 = $37;label = 7; break;
  case 10: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL24removeAdjacentNeighboursR8rcRegion($reg) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($reg+16)|0);
   var $2=(($reg+12)|0);
   var $_pre_pre=HEAP32[(($1)>>2)];
   var $i_0_ph = 0;var $_pre = $_pre_pre;label = 2; break;
  case 2: 
   var $_pre;
   var $i_0_ph;
   var $3=((($i_0_ph)+(1))|0);
   var $4 = $_pre;label = 3; break;
  case 3: 
   var $4;
   var $5=(($i_0_ph)|(0)) < (($4)|(0));
   var $6=(($4)|(0)) > 1;
   var $or_cond=$5 & $6;
   if ($or_cond) { label = 4; break; } else { label = 9; break; }
  case 4: 
   var $8=((((($3)|(0)))%((($4)|(0))))&-1);
   var $9=HEAP32[(($2)>>2)];
   var $10=(($9+($i_0_ph<<2))|0);
   var $11=HEAP32[(($10)>>2)];
   var $12=(($9+($8<<2))|0);
   var $13=HEAP32[(($12)>>2)];
   var $14=(($11)|(0))==(($13)|(0));
   if ($14) { var $storemerge = $i_0_ph;var $16 = $4;label = 5; break; } else { var $i_0_ph = $3;var $_pre = $4;label = 2; break; }
  case 5: 
   var $16;
   var $storemerge;
   var $17=((($16)-(1))|0);
   var $18=(($storemerge)|(0)) < (($17)|(0));
   if ($18) { label = 6; break; } else { label = 7; break; }
  case 6: 
   var $20=((($storemerge)+(1))|0);
   var $21=HEAP32[(($2)>>2)];
   var $22=(($21+($20<<2))|0);
   var $23=HEAP32[(($22)>>2)];
   var $24=(($21+($storemerge<<2))|0);
   HEAP32[(($24)>>2)]=$23;
   var $_pre14=HEAP32[(($1)>>2)];
   var $storemerge = $20;var $16 = $_pre14;label = 5; break;
  case 7: 
   var $26=(($16)|(0)) > 0;
   if ($26) { label = 8; break; } else { var $4 = $16;label = 3; break; }
  case 8: 
   HEAP32[(($1)>>2)]=$17;
   var $4 = $17;label = 3; break;
  case 9: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL11calcExtendsPK10BoundsItemiiiPfS2_($items, $0, $imin, $imax, $bmin, $bmax) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $2=(($items+((($imin)*(20))&-1))|0);
   var $3=HEAPF32[(($2)>>2)];
   HEAPF32[(($bmin)>>2)]=$3;
   var $4=(($items+((($imin)*(20))&-1)+4)|0);
   var $5=HEAPF32[(($4)>>2)];
   var $6=(($bmin+4)|0);
   HEAPF32[(($6)>>2)]=$5;
   var $7=(($items+((($imin)*(20))&-1)+8)|0);
   var $8=HEAPF32[(($7)>>2)];
   HEAPF32[(($bmax)>>2)]=$8;
   var $9=(($items+((($imin)*(20))&-1)+12)|0);
   var $10=HEAPF32[(($9)>>2)];
   var $11=(($bmax+4)|0);
   HEAPF32[(($11)>>2)]=$10;
   var $storemerge_in = $imin;label = 2; break;
  case 2: 
   var $storemerge_in;
   var $storemerge=((($storemerge_in)+(1))|0);
   var $13=(($storemerge)|(0)) < (($imax)|(0));
   if ($13) { label = 3; break; } else { label = 11; break; }
  case 3: 
   var $15=(($items+((($storemerge)*(20))&-1))|0);
   var $16=HEAPF32[(($15)>>2)];
   var $17=HEAPF32[(($bmin)>>2)];
   var $18=$16 < $17;
   if ($18) { label = 4; break; } else { label = 5; break; }
  case 4: 
   HEAPF32[(($bmin)>>2)]=$16;
   label = 5; break;
  case 5: 
   var $20=(($items+((($storemerge)*(20))&-1)+4)|0);
   var $21=HEAPF32[(($20)>>2)];
   var $22=HEAPF32[(($6)>>2)];
   var $23=$21 < $22;
   if ($23) { label = 6; break; } else { label = 7; break; }
  case 6: 
   HEAPF32[(($6)>>2)]=$21;
   label = 7; break;
  case 7: 
   var $25=(($items+((($storemerge)*(20))&-1)+8)|0);
   var $26=HEAPF32[(($25)>>2)];
   var $27=HEAPF32[(($bmax)>>2)];
   var $28=$26 > $27;
   if ($28) { label = 8; break; } else { label = 9; break; }
  case 8: 
   HEAPF32[(($bmax)>>2)]=$26;
   label = 9; break;
  case 9: 
   var $30=(($items+((($storemerge)*(20))&-1)+12)|0);
   var $31=HEAPF32[(($30)>>2)];
   var $32=HEAPF32[(($11)>>2)];
   var $33=$31 > $32;
   if ($33) { label = 10; break; } else { var $storemerge_in = $storemerge;label = 2; break; }
  case 10: 
   HEAPF32[(($11)>>2)]=$31;
   var $storemerge_in = $storemerge;label = 2; break;
  case 11: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL12compareItemYPKvS0_337($va, $vb) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($va+4)|0);
   var $2=$1;
   var $3=HEAPF32[(($2)>>2)];
   var $4=(($vb+4)|0);
   var $5=$4;
   var $6=HEAPF32[(($5)>>2)];
   var $7=$3 < $6;
   if ($7) { var $_0 = -1;label = 4; break; } else { label = 2; break; }
  case 2: 
   var $9=$3 > $6;
   if ($9) { var $_0 = 1;label = 4; break; } else { label = 3; break; }
  case 3: 
   var $_0 = 0;label = 4; break;
  case 4: 
   var $_0;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZL9subdivideP10BoundsItemiiiiRiP19rcChunkyTriMeshNodeiS1_PiPKi($items, $nitems, $imin, $imax, $trisPerChunk, $curNode, $nodes, $maxNodes, $curTri, $outTris, $inTris) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=((($imax)-($imin))|0);
   var $2=HEAP32[(($curNode)>>2)];
   var $3=(($2)|(0)) > (($maxNodes)|(0));
   if ($3) { label = 10; break; } else { label = 2; break; }
  case 2: 
   var $5=((($2)+(1))|0);
   HEAP32[(($curNode)>>2)]=$5;
   var $6=(($nodes+((($2)*(24))&-1))|0);
   var $7=(($1)|(0)) > (($trisPerChunk)|(0));
   var $8=(($6)|0);
   var $9=(($nodes+((($2)*(24))&-1)+8)|0);
   __ZL11calcExtendsPK10BoundsItemiiiPfS2_($items, $nitems, $imin, $imax, $8, $9);
   if ($7) { label = 6; break; } else { label = 3; break; }
  case 3: 
   var $11=HEAP32[(($curTri)>>2)];
   var $12=(($nodes+((($2)*(24))&-1)+16)|0);
   HEAP32[(($12)>>2)]=$11;
   var $13=(($nodes+((($2)*(24))&-1)+20)|0);
   HEAP32[(($13)>>2)]=$1;
   var $storemerge = $imin;label = 4; break;
  case 4: 
   var $storemerge;
   var $15=(($storemerge)|(0)) < (($imax)|(0));
   if ($15) { label = 5; break; } else { label = 10; break; }
  case 5: 
   var $17=(($items+((($storemerge)*(20))&-1)+16)|0);
   var $18=HEAP32[(($17)>>2)];
   var $19=((($18)*(3))&-1);
   var $20=(($inTris+($19<<2))|0);
   var $21=HEAP32[(($curTri)>>2)];
   var $22=((($21)*(3))&-1);
   var $23=(($outTris+($22<<2))|0);
   var $24=((($21)+(1))|0);
   HEAP32[(($curTri)>>2)]=$24;
   var $25=HEAP32[(($20)>>2)];
   HEAP32[(($23)>>2)]=$25;
   var $_sum=((($19)+(1))|0);
   var $26=(($inTris+($_sum<<2))|0);
   var $27=HEAP32[(($26)>>2)];
   var $_sum63=((($22)+(1))|0);
   var $28=(($outTris+($_sum63<<2))|0);
   HEAP32[(($28)>>2)]=$27;
   var $_sum64=((($19)+(2))|0);
   var $29=(($inTris+($_sum64<<2))|0);
   var $30=HEAP32[(($29)>>2)];
   var $_sum65=((($22)+(2))|0);
   var $31=(($outTris+($_sum65<<2))|0);
   HEAP32[(($31)>>2)]=$30;
   var $32=((($storemerge)+(1))|0);
   var $storemerge = $32;label = 4; break;
  case 6: 
   var $34=HEAPF32[(($9)>>2)];
   var $35=HEAPF32[(($8)>>2)];
   var $36=($34)-($35);
   var $37=(($nodes+((($2)*(24))&-1)+12)|0);
   var $38=HEAPF32[(($37)>>2)];
   var $39=(($nodes+((($2)*(24))&-1)+4)|0);
   var $40=HEAPF32[(($39)>>2)];
   var $41=($38)-($40);
   var $42=$41 > $36;
   var $43=(($items+((($imin)*(20))&-1))|0);
   var $44=$43;
   if ($42) { label = 8; break; } else { label = 7; break; }
  case 7: 
   _qsort($44, $1, 20, 40);
   label = 9; break;
  case 8: 
   _qsort($44, $1, 20, 6);
   label = 9; break;
  case 9: 
   var $48=((((($1)|(0)))/(2))&-1);
   var $49=((($48)+($imin))|0);
   __ZL9subdivideP10BoundsItemiiiiRiP19rcChunkyTriMeshNodeiS1_PiPKi($items, $nitems, $imin, $49, $trisPerChunk, $curNode, $nodes, $maxNodes, $curTri, $outTris, $inTris);
   __ZL9subdivideP10BoundsItemiiiiRiP19rcChunkyTriMeshNodeiS1_PiPKi($items, $nitems, $49, $imax, $trisPerChunk, $curNode, $nodes, $maxNodes, $curTri, $outTris, $inTris);
   var $50=HEAP32[(($curNode)>>2)];
   var $51=((($2)-($50))|0);
   var $52=(($nodes+((($2)*(24))&-1)+16)|0);
   HEAP32[(($52)>>2)]=$51;
   label = 10; break;
  case 10: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z21rcCreateChunkyTriMeshPKfPKiiiP15rcChunkyTriMesh($verts, $tris, $ntris, $cm) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 16)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $curTri=sp;
   var $curNode=(sp)+(8);
   var $1=((($ntris)+(255))|0);
   var $2=((((($1)|(0)))/(256))&-1);
   var $3=$2 << 2;
   var $4$0=_llvm_umul_with_overflow_i32($3, 24);
   var $4$1=tempRet0;
   var $5=$4$1;
   var $6=$4$0;
   var $7=$5 ? -1 : $6;
   var $8=(($7)|(0))==0;
   var $_size_i=$8 ? 1 : $7;
   label = 2; break;
  case 2: 
   var $10=_malloc($_size_i);
   var $11=(($10)|(0))==0;
   if ($11) { label = 3; break; } else { label = 16; break; }
  case 3: 
   var $13=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $14=(($13)|(0))==0;
   if ($14) { label = 10; break; } else { label = 4; break; }
  case 4: 
   var $16=$13;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$16]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 2; break; } else { label = 5; break; }
  case 5: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 7; break;
  case 6: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 7; break;
  case 7: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $18=$lpad_phi_i$1;
   var $19=(($18)|(0)) < 0;
   if ($19) { label = 8; break; } else { var $eh_lpad_body$1 = $lpad_phi_i$1;var $eh_lpad_body$0 = $lpad_phi_i$0;label = 13; break; }
  case 8: 
   var $21=$lpad_phi_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($21) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 9; break; } else { label = 12; break; }
  case 9: 
   throw "Reached an unreachable!";
  case 10: 
   var $23=___cxa_allocate_exception(4);
   var $24=$23;
   HEAP32[(($24)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($23, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 11; break; } else { label = 6; break; }
  case 11: 
   throw "Reached an unreachable!";
  case 12: 
   var $27$0 = ___cxa_find_matching_catch(-1, -1); $27$1 = tempRet0;
   var $eh_lpad_body$1 = $27$1;var $eh_lpad_body$0 = $27$0;label = 13; break;
  case 13: 
   var $eh_lpad_body$0;
   var $eh_lpad_body$1;
   var $28=$eh_lpad_body$1;
   var $29=(($28)|(0)) < 0;
   if ($29) { label = 14; break; } else { label = 15; break; }
  case 14: 
   var $31=$eh_lpad_body$0;
   ___cxa_call_unexpected($31);
   throw "Reached an unreachable!";
  case 15: 
   ___resumeException($eh_lpad_body$0)
  case 16: 
   var $34=$10;
   var $35=(($cm)|0);
   HEAP32[(($35)>>2)]=$34;
   var $36=(($10)|(0))==0;
   var $37=((($ntris)*(3))&-1);
   var $38$0=_llvm_umul_with_overflow_i32($37, 4);
   var $38$1=tempRet0;
   var $39=$38$1;
   var $40=$38$0;
   var $41=$39 ? -1 : $40;
   var $42=(($41)|(0))==0;
   var $_size_i5=$42 ? 1 : $41;
   label = 17; break;
  case 17: 
   var $44=_malloc($_size_i5);
   var $45=(($44)|(0))==0;
   if ($45) { label = 18; break; } else { label = 31; break; }
  case 18: 
   var $47=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $48=(($47)|(0))==0;
   if ($48) { label = 25; break; } else { label = 19; break; }
  case 19: 
   var $50=$47;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$50]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 17; break; } else { label = 20; break; }
  case 20: 
   var $lpad_loopexit_i6$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i6$1 = tempRet0;
   var $lpad_phi_i10$1 = $lpad_loopexit_i6$1;var $lpad_phi_i10$0 = $lpad_loopexit_i6$0;label = 22; break;
  case 21: 
   var $lpad_nonloopexit_i8$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i8$1 = tempRet0;
   var $lpad_phi_i10$1 = $lpad_nonloopexit_i8$1;var $lpad_phi_i10$0 = $lpad_nonloopexit_i8$0;label = 22; break;
  case 22: 
   var $lpad_phi_i10$0;
   var $lpad_phi_i10$1;
   var $52=$lpad_phi_i10$1;
   var $53=(($52)|(0)) < 0;
   if ($53) { label = 23; break; } else { var $eh_lpad_body13$1 = $lpad_phi_i10$1;var $eh_lpad_body13$0 = $lpad_phi_i10$0;label = 28; break; }
  case 23: 
   var $55=$lpad_phi_i10$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($55) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 24; break; } else { label = 27; break; }
  case 24: 
   throw "Reached an unreachable!";
  case 25: 
   var $57=___cxa_allocate_exception(4);
   var $58=$57;
   HEAP32[(($58)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($57, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 26; break; } else { label = 21; break; }
  case 26: 
   throw "Reached an unreachable!";
  case 27: 
   var $61$0 = ___cxa_find_matching_catch(-1, -1); $61$1 = tempRet0;
   var $eh_lpad_body13$1 = $61$1;var $eh_lpad_body13$0 = $61$0;label = 28; break;
  case 28: 
   var $eh_lpad_body13$0;
   var $eh_lpad_body13$1;
   var $62=$eh_lpad_body13$1;
   var $63=(($62)|(0)) < 0;
   if ($63) { label = 29; break; } else { label = 30; break; }
  case 29: 
   var $65=$eh_lpad_body13$0;
   ___cxa_call_unexpected($65);
   throw "Reached an unreachable!";
  case 30: 
   ___resumeException($eh_lpad_body13$0)
  case 31: 
   var $68=$44;
   var $69=(($cm+8)|0);
   HEAP32[(($69)>>2)]=$68;
   var $70=(($44)|(0))==0;
   var $71=(($cm+12)|0);
   HEAP32[(($71)>>2)]=$ntris;
   var $72$0=_llvm_umul_with_overflow_i32($ntris, 20);
   var $72$1=tempRet0;
   var $73=$72$1;
   var $74=$72$0;
   var $75=$73 ? -1 : $74;
   var $76=(($75)|(0))==0;
   var $_size_i15=$76 ? 1 : $75;
   label = 32; break;
  case 32: 
   var $78=_malloc($_size_i15);
   var $79=(($78)|(0))==0;
   if ($79) { label = 33; break; } else { label = 46; break; }
  case 33: 
   var $81=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $82=(($81)|(0))==0;
   if ($82) { label = 40; break; } else { label = 34; break; }
  case 34: 
   var $84=$81;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$84]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 32; break; } else { label = 35; break; }
  case 35: 
   var $lpad_loopexit_i16$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i16$1 = tempRet0;
   var $lpad_phi_i20$1 = $lpad_loopexit_i16$1;var $lpad_phi_i20$0 = $lpad_loopexit_i16$0;label = 37; break;
  case 36: 
   var $lpad_nonloopexit_i18$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i18$1 = tempRet0;
   var $lpad_phi_i20$1 = $lpad_nonloopexit_i18$1;var $lpad_phi_i20$0 = $lpad_nonloopexit_i18$0;label = 37; break;
  case 37: 
   var $lpad_phi_i20$0;
   var $lpad_phi_i20$1;
   var $86=$lpad_phi_i20$1;
   var $87=(($86)|(0)) < 0;
   if ($87) { label = 38; break; } else { var $eh_lpad_body23$1 = $lpad_phi_i20$1;var $eh_lpad_body23$0 = $lpad_phi_i20$0;label = 43; break; }
  case 38: 
   var $89=$lpad_phi_i20$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($89) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 39; break; } else { label = 42; break; }
  case 39: 
   throw "Reached an unreachable!";
  case 40: 
   var $91=___cxa_allocate_exception(4);
   var $92=$91;
   HEAP32[(($92)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($91, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 41; break; } else { label = 36; break; }
  case 41: 
   throw "Reached an unreachable!";
  case 42: 
   var $95$0 = ___cxa_find_matching_catch(-1, -1); $95$1 = tempRet0;
   var $eh_lpad_body23$1 = $95$1;var $eh_lpad_body23$0 = $95$0;label = 43; break;
  case 43: 
   var $eh_lpad_body23$0;
   var $eh_lpad_body23$1;
   var $96=$eh_lpad_body23$1;
   var $97=(($96)|(0)) < 0;
   if ($97) { label = 44; break; } else { label = 45; break; }
  case 44: 
   var $99=$eh_lpad_body23$0;
   ___cxa_call_unexpected($99);
   throw "Reached an unreachable!";
  case 45: 
   ___resumeException($eh_lpad_body23$0)
  case 46: 
   var $102=$78;
   var $storemerge = 0;label = 47; break;
  case 47: 
   var $storemerge;
   var $104=(($storemerge)|(0)) < (($ntris)|(0));
   if ($104) { label = 48; break; } else { label = 60; break; }
  case 48: 
   var $106=((($storemerge)*(3))&-1);
   var $107=(($tris+($106<<2))|0);
   var $108=(($102+((($storemerge)*(20))&-1)+16)|0);
   HEAP32[(($108)>>2)]=$storemerge;
   var $109=HEAP32[(($107)>>2)];
   var $110=((($109)*(3))&-1);
   var $111=(($verts+($110<<2))|0);
   var $112=HEAPF32[(($111)>>2)];
   var $113=(($102+((($storemerge)*(20))&-1)+8)|0);
   HEAPF32[(($113)>>2)]=$112;
   var $114=(($102+((($storemerge)*(20))&-1))|0);
   HEAPF32[(($114)>>2)]=$112;
   var $115=HEAP32[(($107)>>2)];
   var $116=((($115)*(3))&-1);
   var $117=((($116)+(2))|0);
   var $118=(($verts+($117<<2))|0);
   var $119=HEAPF32[(($118)>>2)];
   var $120=(($102+((($storemerge)*(20))&-1)+12)|0);
   HEAPF32[(($120)>>2)]=$119;
   var $121=(($102+((($storemerge)*(20))&-1)+4)|0);
   HEAPF32[(($121)>>2)]=$119;
   var $storemerge2 = 1;var $126 = $112;var $125 = $119;var $124 = $112;var $123 = $119;label = 49; break;
  case 49: 
   var $123;
   var $124;
   var $125;
   var $126;
   var $storemerge2;
   var $127=(($storemerge2)|(0)) < 3;
   if ($127) { label = 50; break; } else { label = 59; break; }
  case 50: 
   var $_sum=((($106)+($storemerge2))|0);
   var $129=(($tris+($_sum<<2))|0);
   var $130=HEAP32[(($129)>>2)];
   var $131=((($130)*(3))&-1);
   var $132=(($verts+($131<<2))|0);
   var $133=HEAPF32[(($132)>>2)];
   var $134=$133 < $126;
   if ($134) { label = 51; break; } else { var $137 = $126;label = 52; break; }
  case 51: 
   HEAPF32[(($114)>>2)]=$133;
   var $137 = $133;label = 52; break;
  case 52: 
   var $137;
   var $_sum75=((($131)+(2))|0);
   var $138=(($verts+($_sum75<<2))|0);
   var $139=HEAPF32[(($138)>>2)];
   var $140=$139 < $125;
   if ($140) { label = 53; break; } else { var $142 = $125;label = 54; break; }
  case 53: 
   HEAPF32[(($121)>>2)]=$139;
   var $142 = $139;label = 54; break;
  case 54: 
   var $142;
   var $143=HEAPF32[(($132)>>2)];
   var $144=$143 > $124;
   if ($144) { label = 55; break; } else { var $146 = $124;label = 56; break; }
  case 55: 
   HEAPF32[(($113)>>2)]=$143;
   var $146 = $143;label = 56; break;
  case 56: 
   var $146;
   var $147=HEAPF32[(($138)>>2)];
   var $148=$147 > $123;
   if ($148) { label = 57; break; } else { var $151 = $123;label = 58; break; }
  case 57: 
   HEAPF32[(($120)>>2)]=$147;
   var $151 = $147;label = 58; break;
  case 58: 
   var $151;
   var $152=((($storemerge2)+(1))|0);
   var $storemerge2 = $152;var $126 = $137;var $125 = $142;var $124 = $146;var $123 = $151;label = 49; break;
  case 59: 
   var $154=((($storemerge)+(1))|0);
   var $storemerge = $154;label = 47; break;
  case 60: 
   HEAP32[(($curTri)>>2)]=0;
   HEAP32[(($curNode)>>2)]=0;
   var $156=HEAP32[(($35)>>2)];
   var $157=HEAP32[(($69)>>2)];
   __ZL9subdivideP10BoundsItemiiiiRiP19rcChunkyTriMeshNodeiS1_PiPKi($102, $ntris, 0, $ntris, 256, $curNode, $156, $3, $curTri, $157, $tris);
   var $158=(($78)|(0))==0;
   if ($158) { label = 62; break; } else { label = 61; break; }
  case 61: 
   _free($78);
   label = 62; break;
  case 62: 
   var $160=HEAP32[(($curNode)>>2)];
   var $161=(($cm+4)|0);
   HEAP32[(($161)>>2)]=$160;
   var $162=(($cm+16)|0);
   HEAP32[(($162)>>2)]=0;
   var $storemerge1 = 0;var $164 = 0;label = 63; break;
  case 63: 
   var $164;
   var $storemerge1;
   var $165=(($storemerge1)|(0)) < (($160)|(0));
   if ($165) { label = 64; break; } else { label = 68; break; }
  case 64: 
   var $167=HEAP32[(($35)>>2)];
   var $168=(($167+((($storemerge1)*(24))&-1)+16)|0);
   var $169=HEAP32[(($168)>>2)];
   var $_not=(($169)|(0)) > -1;
   if ($_not) { label = 65; break; } else { var $176 = $164;label = 67; break; }
  case 65: 
   var $171=(($167+((($storemerge1)*(24))&-1)+20)|0);
   var $172=HEAP32[(($171)>>2)];
   var $173=(($172)|(0)) > (($164)|(0));
   if ($173) { label = 66; break; } else { var $176 = $164;label = 67; break; }
  case 66: 
   HEAP32[(($162)>>2)]=$172;
   var $176 = $172;label = 67; break;
  case 67: 
   var $176;
   var $177=((($storemerge1)+(1))|0);
   var $storemerge1 = $177;var $164 = $176;label = 63; break;
  case 68: 
   STACKTOP = sp;
   return 1;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN15rcMeshLoaderObj9addVertexEfffRi($this, $x, $y, $z, $cap) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this+276)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=((($2)+(1))|0);
   var $4=HEAP32[(($cap)>>2)];
   var $5=(($3)|(0)) > (($4)|(0));
   if ($5) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $_phi_trans_insert=(($this+264)|0);
   var $_pre10=HEAP32[(($_phi_trans_insert)>>2)];
   var $48 = $2;var $47 = $_pre10;label = 21; break;
  case 3: 
   var $7=(($4)|(0))==0;
   var $8=$4 << 1;
   var $_=$7 ? 8 : $8;
   HEAP32[(($cap)>>2)]=$_;
   var $9=((($_)*(3))&-1);
   var $10$0=_llvm_umul_with_overflow_i32($9, 4);
   var $10$1=tempRet0;
   var $11=$10$1;
   var $12=$10$0;
   var $13=$11 ? -1 : $12;
   var $14=(($13)|(0))==0;
   var $_size_i=$14 ? 1 : $13;
   label = 4; break;
  case 4: 
   var $16=_malloc($_size_i);
   var $17=(($16)|(0))==0;
   if ($17) { label = 5; break; } else { label = 18; break; }
  case 5: 
   var $19=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $20=(($19)|(0))==0;
   if ($20) { label = 12; break; } else { label = 6; break; }
  case 6: 
   var $22=$19;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$22]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 4; break; } else { label = 7; break; }
  case 7: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 9; break;
  case 8: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 9; break;
  case 9: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $24=$lpad_phi_i$1;
   var $25=(($24)|(0)) < 0;
   if ($25) { label = 10; break; } else { var $eh_lpad_body$1 = $lpad_phi_i$1;var $eh_lpad_body$0 = $lpad_phi_i$0;label = 15; break; }
  case 10: 
   var $27=$lpad_phi_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($27) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 11; break; } else { label = 14; break; }
  case 11: 
   throw "Reached an unreachable!";
  case 12: 
   var $29=___cxa_allocate_exception(4);
   var $30=$29;
   HEAP32[(($30)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($29, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 13; break; } else { label = 8; break; }
  case 13: 
   throw "Reached an unreachable!";
  case 14: 
   var $33$0 = ___cxa_find_matching_catch(-1, -1); $33$1 = tempRet0;
   var $eh_lpad_body$1 = $33$1;var $eh_lpad_body$0 = $33$0;label = 15; break;
  case 15: 
   var $eh_lpad_body$0;
   var $eh_lpad_body$1;
   var $34=$eh_lpad_body$1;
   var $35=(($34)|(0)) < 0;
   if ($35) { label = 16; break; } else { label = 17; break; }
  case 16: 
   var $37=$eh_lpad_body$0;
   ___cxa_call_unexpected($37);
   throw "Reached an unreachable!";
  case 17: 
   ___resumeException($eh_lpad_body$0)
  case 18: 
   var $39=$16;
   var $40=HEAP32[(($1)>>2)];
   var $41=(($40)|(0))==0;
   var $_pre11=(($this+264)|0);
   if ($41) { var $_pre = 0;label = 20; break; } else { label = 19; break; }
  case 19: 
   var $43=HEAP32[(($_pre11)>>2)];
   var $44=$43;
   var $45=((($40)*(12))&-1);
   assert($45 % 1 === 0);(_memcpy($16, $44, $45)|0);
   var $_pre_pre=HEAP32[(($1)>>2)];
   var $_pre = $_pre_pre;label = 20; break;
  case 20: 
   var $_pre;
   HEAP32[(($_pre11)>>2)]=$39;
   var $48 = $_pre;var $47 = $39;label = 21; break;
  case 21: 
   var $47;
   var $48;
   var $49=((($48)*(3))&-1);
   var $50=(($47+($49<<2))|0);
   var $51=(($this+260)|0);
   var $52=HEAPF32[(($51)>>2)];
   var $53=($52)*($x);
   var $_sum=((($49)+(1))|0);
   var $54=(($47+($_sum<<2))|0);
   HEAPF32[(($50)>>2)]=$53;
   var $55=HEAPF32[(($51)>>2)];
   var $56=($55)*($y);
   var $_sum12=((($49)+(2))|0);
   var $57=(($47+($_sum12<<2))|0);
   HEAPF32[(($54)>>2)]=$56;
   var $58=HEAPF32[(($51)>>2)];
   var $59=($58)*($z);
   HEAPF32[(($57)>>2)]=$59;
   var $60=HEAP32[(($1)>>2)];
   var $61=((($60)+(1))|0);
   HEAP32[(($1)>>2)]=$61;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z12set_cellSizef($val) {
 var label = 0;
 HEAPF32[((64)>>2)]=$val;
 return;
}
function __Z14set_cellHeightf($val) {
 var label = 0;
 HEAPF32[((72)>>2)]=$val;
 return;
}
function __Z15set_agentHeightf($val) {
 var label = 0;
 HEAPF32[((104)>>2)]=$val;
 return;
}
function __Z15set_agentRadiusf($val) {
 var label = 0;
 HEAPF32[((80)>>2)]=$val;
 return;
}
function __Z17set_agentMaxClimbf($val) {
 var label = 0;
 HEAPF32[((96)>>2)]=$val;
 return;
}
function __Z17set_agentMaxSlopef($val) {
 var label = 0;
 HEAPF32[((88)>>2)]=$val;
 return;
}
function __Z17set_regionMinSizef($val) {
 var label = 0;
 HEAPF32[((16)>>2)]=$val;
 return;
}
function __Z19set_regionMergeSizef($val) {
 var label = 0;
 HEAPF32[((24)>>2)]=$val;
 return;
}
function __Z14set_edgeMaxLenf($val) {
 var label = 0;
 HEAPF32[((32)>>2)]=$val;
 return;
}
function __Z16set_edgeMaxErrorf($val) {
 var label = 0;
 HEAPF32[((40)>>2)]=$val;
 return;
}
function __Z16set_vertsPerPolyf($val) {
 var label = 0;
 HEAPF32[((8)>>2)]=$val;
 return;
}
function __Z20set_detailSampleDistf($val) {
 var label = 0;
 HEAPF32[((56)>>2)]=$val;
 return;
}
function __Z24set_detailSampleMaxErrorf($val) {
 var label = 0;
 HEAPF32[((48)>>2)]=$val;
 return;
}
function __Z11getMaxTilesv() {
 var label = 0;
 var $1=HEAP32[((7608)>>2)];
 var $2=(($1+48)|0);
 var $3=HEAP32[(($2)>>2)];
 return $3;
}
function __GLOBAL__I_a() {
 var label = 0;
 HEAP32[((((7744)|0))>>2)]=0;
 var $1=_atexit((46), 7744, ___dso_handle);
 return;
}
function __Z17bareGeomAddVertexfffi($x, $y, $z, $cap) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 var $1=sp;
 HEAP32[(($1)>>2)]=$cap;
 var $2=HEAP32[((7576)>>2)];
 __ZN15rcMeshLoaderObj9addVertexEfffRi($2, $x, $y, $z, $1);
 STACKTOP = sp;
 return;
}
function __Z19bareGeomAddTriangleiiii($a, $b, $c, $cap) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 8)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 var $1=sp;
 HEAP32[(($1)>>2)]=$cap;
 var $2=HEAP32[((7576)>>2)];
 __ZN15rcMeshLoaderObj11addTriangleEiiiRi($2, $a, $b, $c, $1);
 STACKTOP = sp;
 return;
}
function __Z16iterateOnNavMeshv() {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 1544)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $buff_i=sp;
   var $buff=(sp)+(1024);
   var $vi=(sp)+(1536);
   var $1=HEAP32[((7600)>>2)];
   var $2=(($1+32)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($1+60)|0);
   var $5=HEAPF32[(($4)>>2)];
   var $6=(($1+64)|0);
   var $7=HEAPF32[(($6)>>2)];
   var $8=(($1+36)|0);
   var $9=(($buff)|0);
   var $10=$5;
   var $11=$7;
   var $12=_sprintf($9, ((5080)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 32)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$3,HEAPF64[(((tempVarArgs)+(8))>>3)]=$10,HEAPF64[(((tempVarArgs)+(16))>>3)]=$11,HEAP32[(((tempVarArgs)+(24))>>2)]=$8,tempVarArgs)); STACKTOP=tempVarArgs;
   var $13=(($buff_i)|0);
   var $14=_sprintf($13, ((5520)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$9,tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($13);
   _emscripten_run_script(((4944)|0));
   _emscripten_run_script(((4920)|0));
   var $15=(($vi)|0);
   var $16=(($vi+2)|0);
   var $17=(($vi+4)|0);
   var $18=(($1+40)|0);
   var $19=(($1+44)|0);
   var $storemerge = 0;var $nIndex_0 = 0;label = 2; break;
  case 2: 
   var $nIndex_0;
   var $storemerge;
   var $21=HEAP32[((7600)>>2)];
   var $22=(($21+24)|0);
   var $23=HEAP32[(($22)>>2)];
   var $24=(($storemerge)|(0)) < (($23)|(0));
   if ($24) { label = 3; break; } else { label = 12; break; }
  case 3: 
   var $26=(($21+16)|0);
   var $27=HEAP32[(($26)>>2)];
   var $28=(($27+$storemerge)|0);
   var $29=HEAP8[($28)];
   var $30=(($29 << 24) >> 24)==0;
   if ($30) { label = 4; break; } else { var $nIndex_3 = $nIndex_0;label = 11; break; }
  case 4: 
   var $32=(Math.imul($storemerge,$3)|0);
   var $33=$32 << 1;
   var $34=(($21+4)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35+($33<<1))|0);
   var $storemerge1 = 2;var $nIndex_1 = $nIndex_0;label = 5; break;
  case 5: 
   var $nIndex_1;
   var $storemerge1;
   var $38=(($storemerge1)|(0)) < (($3)|(0));
   if ($38) { label = 6; break; } else { var $nIndex_3 = $nIndex_1;label = 11; break; }
  case 6: 
   var $_sum=((($33)+($storemerge1))|0);
   var $40=(($35+($_sum<<1))|0);
   var $41=HEAP16[(($40)>>1)];
   var $42=(($41 << 16) >> 16)==-1;
   if ($42) { var $nIndex_3 = $nIndex_1;label = 11; break; } else { label = 7; break; }
  case 7: 
   var $44=HEAP16[(($36)>>1)];
   HEAP16[(($15)>>1)]=$44;
   var $45=((($storemerge1)-(1))|0);
   var $_sum24=((($33)+($45))|0);
   var $46=(($35+($_sum24<<1))|0);
   var $47=HEAP16[(($46)>>1)];
   HEAP16[(($16)>>1)]=$47;
   HEAP16[(($17)>>1)]=$41;
   var $48=(($44)&(65535));
   var $49=(($47)&(65535));
   var $50=(($41)&(65535));
   var $51=_sprintf($9, ((4888)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$48,HEAP32[(((tempVarArgs)+(8))>>2)]=$49,HEAP32[(((tempVarArgs)+(16))>>2)]=$50,tempVarArgs)); STACKTOP=tempVarArgs;
   var $52=_sprintf($13, ((5520)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$9,tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($13);
   var $storemerge2 = 0;var $nIndex_2 = $nIndex_1;label = 8; break;
  case 8: 
   var $nIndex_2;
   var $storemerge2;
   var $54=(($storemerge2)|(0)) < 3;
   if ($54) { label = 9; break; } else { label = 10; break; }
  case 9: 
   var $56=(($vi+($storemerge2<<1))|0);
   var $57=HEAP16[(($56)>>1)];
   var $58=(($57)&(65535));
   var $59=((($58)*(3))&-1);
   var $60=HEAP32[((7600)>>2)];
   var $61=(($60)|0);
   var $62=HEAP32[(($61)>>2)];
   var $63=(($62+($59<<1))|0);
   var $64=HEAPF32[(($8)>>2)];
   var $65=HEAP16[(($63)>>1)];
   var $66=(($65)&(65535));
   var $67=(($66)|(0));
   var $68=($64)+($67);
   var $69=HEAPF32[(($18)>>2)];
   var $_sum25=((($59)+(1))|0);
   var $70=(($62+($_sum25<<1))|0);
   var $71=HEAP16[(($70)>>1)];
   var $72=(($71)&(65535));
   var $73=((($72)+(1))|0);
   var $74=(($73)|(0));
   var $75=($69)+($74);
   var $76=HEAPF32[(($19)>>2)];
   var $_sum26=((($59)+(2))|0);
   var $77=(($62+($_sum26<<1))|0);
   var $78=HEAP16[(($77)>>1)];
   var $79=(($78)&(65535));
   var $80=(($79)|(0));
   var $81=($76)+($80);
   var $82=($81)-(140);
   var $83=$68;
   var $84=$75;
   var $85=$82;
   var $86=_sprintf($9, ((4720)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAPF64[((tempVarArgs)>>3)]=$83,HEAPF64[(((tempVarArgs)+(8))>>3)]=$84,HEAPF64[(((tempVarArgs)+(16))>>3)]=$85,tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($9);
   var $87=((($nIndex_2)+(3))|0);
   var $88=((($storemerge2)+(1))|0);
   var $storemerge2 = $88;var $nIndex_2 = $87;label = 8; break;
  case 10: 
   var $90=((($storemerge1)+(1))|0);
   var $storemerge1 = $90;var $nIndex_1 = $nIndex_2;label = 5; break;
  case 11: 
   var $nIndex_3;
   var $91=((($storemerge)+(1))|0);
   var $storemerge = $91;var $nIndex_0 = $nIndex_3;label = 2; break;
  case 12: 
   var $93=_sprintf($13, ((5424)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=((4512)|0),tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($13);
   _emscripten_run_script(((4320)|0));
   var $94=(1)/($5);
   var $95=$94;
   var $96=(1)/($7);
   var $97=$96;
   var $98=_sprintf($9, ((4208)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 48)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,HEAP32[(((tempVarArgs)+(8))>>2)]=0,HEAP32[(((tempVarArgs)+(16))>>2)]=0,HEAPF64[(((tempVarArgs)+(24))>>3)]=$95,HEAPF64[(((tempVarArgs)+(32))>>3)]=$97,HEAPF64[(((tempVarArgs)+(40))>>3)]=$95,tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($9);
   var $99=_sprintf($13, ((5520)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$9,tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($13);
   _emscripten_run_script(((4168)|0));
   var $100=_sprintf($13, ((5424)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=((4112)|0),tempVarArgs)); STACKTOP=tempVarArgs;
   _emscripten_run_script($13);
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z4initv() {
 var label = 0;
 var $1=_getThreeJSMeshes();
 var $2=(($1)|(0))!=0;
 return $2;
}
function __ZN15rcMeshLoaderObj11addTriangleEiiiRi($this, $a, $b, $c, $cap) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this+280)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=((($2)+(1))|0);
   var $4=HEAP32[(($cap)>>2)];
   var $5=(($3)|(0)) > (($4)|(0));
   if ($5) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $_phi_trans_insert=(($this+268)|0);
   var $_pre10=HEAP32[(($_phi_trans_insert)>>2)];
   var $48 = $2;var $47 = $_pre10;label = 21; break;
  case 3: 
   var $7=(($4)|(0))==0;
   var $8=$4 << 1;
   var $_=$7 ? 8 : $8;
   HEAP32[(($cap)>>2)]=$_;
   var $9=((($_)*(3))&-1);
   var $10$0=_llvm_umul_with_overflow_i32($9, 4);
   var $10$1=tempRet0;
   var $11=$10$1;
   var $12=$10$0;
   var $13=$11 ? -1 : $12;
   var $14=(($13)|(0))==0;
   var $_size_i=$14 ? 1 : $13;
   label = 4; break;
  case 4: 
   var $16=_malloc($_size_i);
   var $17=(($16)|(0))==0;
   if ($17) { label = 5; break; } else { label = 18; break; }
  case 5: 
   var $19=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $20=(($19)|(0))==0;
   if ($20) { label = 12; break; } else { label = 6; break; }
  case 6: 
   var $22=$19;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$22]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 4; break; } else { label = 7; break; }
  case 7: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 9; break;
  case 8: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 9; break;
  case 9: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $24=$lpad_phi_i$1;
   var $25=(($24)|(0)) < 0;
   if ($25) { label = 10; break; } else { var $eh_lpad_body$1 = $lpad_phi_i$1;var $eh_lpad_body$0 = $lpad_phi_i$0;label = 15; break; }
  case 10: 
   var $27=$lpad_phi_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($27) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 11; break; } else { label = 14; break; }
  case 11: 
   throw "Reached an unreachable!";
  case 12: 
   var $29=___cxa_allocate_exception(4);
   var $30=$29;
   HEAP32[(($30)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($29, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 13; break; } else { label = 8; break; }
  case 13: 
   throw "Reached an unreachable!";
  case 14: 
   var $33$0 = ___cxa_find_matching_catch(-1, -1); $33$1 = tempRet0;
   var $eh_lpad_body$1 = $33$1;var $eh_lpad_body$0 = $33$0;label = 15; break;
  case 15: 
   var $eh_lpad_body$0;
   var $eh_lpad_body$1;
   var $34=$eh_lpad_body$1;
   var $35=(($34)|(0)) < 0;
   if ($35) { label = 16; break; } else { label = 17; break; }
  case 16: 
   var $37=$eh_lpad_body$0;
   ___cxa_call_unexpected($37);
   throw "Reached an unreachable!";
  case 17: 
   ___resumeException($eh_lpad_body$0)
  case 18: 
   var $39=$16;
   var $40=HEAP32[(($1)>>2)];
   var $41=(($40)|(0))==0;
   var $_pre11=(($this+268)|0);
   if ($41) { var $_pre = 0;label = 20; break; } else { label = 19; break; }
  case 19: 
   var $43=HEAP32[(($_pre11)>>2)];
   var $44=$43;
   var $45=((($40)*(12))&-1);
   assert($45 % 1 === 0);(_memcpy($16, $44, $45)|0);
   var $_pre_pre=HEAP32[(($1)>>2)];
   var $_pre = $_pre_pre;label = 20; break;
  case 20: 
   var $_pre;
   HEAP32[(($_pre11)>>2)]=$39;
   var $48 = $_pre;var $47 = $39;label = 21; break;
  case 21: 
   var $47;
   var $48;
   var $49=((($48)*(3))&-1);
   var $50=(($47+($49<<2))|0);
   var $_sum=((($49)+(1))|0);
   var $51=(($47+($_sum<<2))|0);
   HEAP32[(($50)>>2)]=$a;
   var $_sum12=((($49)+(2))|0);
   var $52=(($47+($_sum12<<2))|0);
   HEAP32[(($51)>>2)]=$b;
   HEAP32[(($52)>>2)]=$c;
   var $53=HEAP32[(($1)>>2)];
   var $54=((($53)+(1))|0);
   HEAP32[(($1)>>2)]=$54;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN16GLCheckerTextureD1Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0))==0;
   if ($3) { label = 4; break; } else { label = 2; break; }
  case 2: 
   (function() { try { __THREW__ = 0; return _glDeleteTextures(1, $1) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 4; break; } else { label = 3; break; }
  case 3: 
   var $6$0 = ___cxa_find_matching_catch(-1, -1,0); $6$1 = tempRet0;
   __ZSt9terminatev();
   throw "Reached an unreachable!";
  case 4: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z12bareGeomInitv() {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   label = 2; break;
  case 2: 
   var $2=_malloc(50216);
   var $3=(($2)|(0))==0;
   if ($3) { label = 3; break; } else { label = 12; break; }
  case 3: 
   var $5=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $6=(($5)|(0))==0;
   if ($6) { label = 9; break; } else { label = 4; break; }
  case 4: 
   var $8=$5;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$8]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 2; break; } else { label = 5; break; }
  case 5: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 7; break;
  case 6: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 7; break;
  case 7: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $10=$lpad_phi_i$1;
   var $11=(($10)|(0)) < 0;
   if ($11) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $13=$lpad_phi_i$0;
   ___cxa_call_unexpected($13);
   throw "Reached an unreachable!";
  case 9: 
   var $15=___cxa_allocate_exception(4);
   var $16=$15;
   HEAP32[(($16)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($15, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 11; break; } else { label = 6; break; }
  case 10: 
   ___resumeException($lpad_phi_i$0)
  case 11: 
   throw "Reached an unreachable!";
  case 12: 
   var $20=$2;
   HEAP32[(($20)>>2)]=0;
   var $21=(($2+4)|0);
   var $22=$21;
   HEAP32[(($22)>>2)]=0;
   var $23=(($2+9248)|0);
   var $24=$23;
   HEAP32[(($24)>>2)]=0;
   var $25=(($2+50212)|0);
   var $26=$25;
   HEAP32[(($26)>>2)]=0;
   var $27=$2;
   HEAP32[((7616)>>2)]=$27;
   label = 13; break;
  case 13: 
   var $29=_malloc(284);
   var $30=(($29)|(0))==0;
   if ($30) { label = 14; break; } else { label = 23; break; }
  case 14: 
   var $32=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $33=(($32)|(0))==0;
   if ($33) { label = 20; break; } else { label = 15; break; }
  case 15: 
   var $35=$32;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$35]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 13; break; } else { label = 16; break; }
  case 16: 
   var $lpad_loopexit_i1$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i1$1 = tempRet0;
   var $lpad_phi_i5$1 = $lpad_loopexit_i1$1;var $lpad_phi_i5$0 = $lpad_loopexit_i1$0;label = 18; break;
  case 17: 
   var $lpad_nonloopexit_i3$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i3$1 = tempRet0;
   var $lpad_phi_i5$1 = $lpad_nonloopexit_i3$1;var $lpad_phi_i5$0 = $lpad_nonloopexit_i3$0;label = 18; break;
  case 18: 
   var $lpad_phi_i5$0;
   var $lpad_phi_i5$1;
   var $37=$lpad_phi_i5$1;
   var $38=(($37)|(0)) < 0;
   if ($38) { label = 19; break; } else { label = 21; break; }
  case 19: 
   var $40=$lpad_phi_i5$0;
   ___cxa_call_unexpected($40);
   throw "Reached an unreachable!";
  case 20: 
   var $42=___cxa_allocate_exception(4);
   var $43=$42;
   HEAP32[(($43)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($42, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 22; break; } else { label = 17; break; }
  case 21: 
   ___resumeException($lpad_phi_i5$0)
  case 22: 
   throw "Reached an unreachable!";
  case 23: 
   var $47=(($29+260)|0);
   var $48=$47;
   HEAPF32[(($48)>>2)]=1;
   var $49=(($29+264)|0);
   var $50=$29;
   HEAP32[(($49)>>2)]=0; HEAP32[((($49)+(4))>>2)]=0; HEAP32[((($49)+(8))>>2)]=0; HEAP32[((($49)+(12))>>2)]=0; HEAP32[((($49)+(16))>>2)]=0;
   HEAP32[((7576)>>2)]=$50;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z16bareGeomValidatev() {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=HEAP32[((7616)>>2)];
   var $2=HEAP32[((7576)>>2)];
   var $3=(($1+4)|0);
   var $4=HEAP32[(($3)>>2)];
   var $5=(($4)|(0))==0;
   if ($5) { label = 17; break; } else { label = 2; break; }
  case 2: 
   var $7=(($1)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==0;
   if ($9) { label = 8; break; } else { label = 3; break; }
  case 3: 
   var $11=(($8)|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=(($12)|(0))==0;
   if ($13) { label = 5; break; } else { label = 4; break; }
  case 4: 
   var $14=$12;
   _free($14);
   label = 5; break;
  case 5: 
   var $16=(($8+8)|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=(($17)|(0))==0;
   if ($18) { label = 7; break; } else { label = 6; break; }
  case 6: 
   var $19=$17;
   _free($19);
   label = 7; break;
  case 7: 
   var $20=$8;
   _free($20);
   label = 8; break;
  case 8: 
   HEAP32[(($7)>>2)]=0;
   var $21=HEAP32[(($3)>>2)];
   var $22=(($21)|(0))==0;
   if ($22) { label = 16; break; } else { label = 9; break; }
  case 9: 
   var $24=(($21+264)|0);
   var $25=HEAP32[(($24)>>2)];
   var $26=(($25)|(0))==0;
   if ($26) { label = 11; break; } else { label = 10; break; }
  case 10: 
   var $27=$25;
   _free($27);
   label = 11; break;
  case 11: 
   var $29=(($21+272)|0);
   var $30=HEAP32[(($29)>>2)];
   var $31=(($30)|(0))==0;
   if ($31) { label = 13; break; } else { label = 12; break; }
  case 12: 
   var $32=$30;
   _free($32);
   label = 13; break;
  case 13: 
   var $34=(($21+268)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==0;
   if ($36) { label = 15; break; } else { label = 14; break; }
  case 14: 
   var $37=$35;
   _free($37);
   label = 15; break;
  case 15: 
   var $38=(($21)|0);
   _free($38);
   label = 16; break;
  case 16: 
   HEAP32[(($3)>>2)]=0;
   label = 17; break;
  case 17: 
   var $40=(($1+9248)|0);
   HEAP32[(($40)>>2)]=0;
   var $41=(($1+50212)|0);
   HEAP32[(($41)>>2)]=0;
   HEAP32[(($3)>>2)]=$2;
   var $42=(($2)|(0))==0;
   if ($42) { label = 18; break; } else { label = 19; break; }
  case 18: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((5696)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 32; break;
  case 19: 
   var $45=(($2+276)|0);
   var $46=HEAP32[(($45)>>2)];
   var $47=(($2+280)|0);
   var $48=HEAP32[(($47)>>2)];
   var $49=_printf(((5552)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$46,HEAP32[(((tempVarArgs)+(8))>>2)]=$48,tempVarArgs)); STACKTOP=tempVarArgs;
   var $50=HEAP32[(($3)>>2)];
   var $51=(($50+264)|0);
   var $52=HEAP32[(($51)>>2)];
   var $53=(($50+276)|0);
   var $54=HEAP32[(($53)>>2)];
   var $55=(($1+8)|0);
   var $56=(($1+20)|0);
   __Z12rcCalcBoundsPKfiPfS1_($52, $54, $55, $56);
   label = 20; break;
  case 20: 
   var $58=_malloc(20);
   var $59=(($58)|(0))==0;
   if ($59) { label = 21; break; } else { label = 30; break; }
  case 21: 
   var $61=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $62=(($61)|(0))==0;
   if ($62) { label = 27; break; } else { label = 22; break; }
  case 22: 
   var $64=$61;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$64]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 20; break; } else { label = 23; break; }
  case 23: 
   var $lpad_loopexit_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i_i$1 = tempRet0;
   var $lpad_phi_i_i$1 = $lpad_loopexit_i_i$1;var $lpad_phi_i_i$0 = $lpad_loopexit_i_i$0;label = 25; break;
  case 24: 
   var $lpad_nonloopexit_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i_i$1 = tempRet0;
   var $lpad_phi_i_i$1 = $lpad_nonloopexit_i_i$1;var $lpad_phi_i_i$0 = $lpad_nonloopexit_i_i$0;label = 25; break;
  case 25: 
   var $lpad_phi_i_i$0;
   var $lpad_phi_i_i$1;
   var $66=$lpad_phi_i_i$1;
   var $67=(($66)|(0)) < 0;
   if ($67) { label = 26; break; } else { label = 28; break; }
  case 26: 
   var $69=$lpad_phi_i_i$0;
   ___cxa_call_unexpected($69);
   throw "Reached an unreachable!";
  case 27: 
   var $71=___cxa_allocate_exception(4);
   var $72=$71;
   HEAP32[(($72)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($71, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 29; break; } else { label = 24; break; }
  case 28: 
   ___resumeException($lpad_phi_i_i$0)
  case 29: 
   throw "Reached an unreachable!";
  case 30: 
   var $76=$58;
   var $77=$58;
   HEAP32[(($77)>>2)]=0;
   var $78=(($58+8)|0);
   var $79=$78;
   HEAP32[(($79)>>2)]=0;
   var $80=(($1)|0);
   HEAP32[(($80)>>2)]=$76;
   var $81=HEAP32[(($3)>>2)];
   var $82=(($81+264)|0);
   var $83=HEAP32[(($82)>>2)];
   var $84=(($81+268)|0);
   var $85=HEAP32[(($84)>>2)];
   var $86=(($81+280)|0);
   var $87=HEAP32[(($86)>>2)];
   var $88=__Z21rcCreateChunkyTriMeshPKfPKiiiP15rcChunkyTriMesh($83, $85, $87, $76);
   if ($88) { label = 32; break; } else { label = 31; break; }
  case 31: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((3560)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 32; break;
  case 32: 
   STACKTOP = sp;
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __Z12initWithFilev() {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 712)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $row_i_i=sp;
   var $face_i_i=(sp)+(512);
   var $x_i_i=(sp)+(640);
   var $y_i_i=(sp)+(648);
   var $z_i_i=(sp)+(656);
   var $vcap_i_i=(sp)+(664);
   var $tcap_i_i=(sp)+(672);
   var $e0_i_i=(sp)+(680);
   var $e1_i_i=(sp)+(696);
   var $1=_printf(((4072)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 2; break;
  case 2: 
   var $3=_malloc(50216);
   var $4=(($3)|(0))==0;
   if ($4) { label = 3; break; } else { label = 12; break; }
  case 3: 
   var $6=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $7=(($6)|(0))==0;
   if ($7) { label = 9; break; } else { label = 4; break; }
  case 4: 
   var $9=$6;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$9]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 2; break; } else { label = 5; break; }
  case 5: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 7; break;
  case 6: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 7; break;
  case 7: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $11=$lpad_phi_i$1;
   var $12=(($11)|(0)) < 0;
   if ($12) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $14=$lpad_phi_i$0;
   ___cxa_call_unexpected($14);
   throw "Reached an unreachable!";
  case 9: 
   var $16=___cxa_allocate_exception(4);
   var $17=$16;
   HEAP32[(($17)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($16, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 11; break; } else { label = 6; break; }
  case 10: 
   ___resumeException($lpad_phi_i$0)
  case 11: 
   throw "Reached an unreachable!";
  case 12: 
   var $21=$3;
   HEAP32[(($21)>>2)]=0;
   var $22=(($3+4)|0);
   var $23=$22;
   HEAP32[(($23)>>2)]=0;
   var $24=(($3+9248)|0);
   var $25=$24;
   HEAP32[(($25)>>2)]=0;
   var $26=(($3+50212)|0);
   var $27=$26;
   HEAP32[(($27)>>2)]=0;
   var $28=$3;
   HEAP32[((7616)>>2)]=$28;
   var $29=(($3+4)|0);
   var $30=$29;
   var $31=(($3+9248)|0);
   var $32=$31;
   HEAP32[(($32)>>2)]=0;
   var $33=(($3+50212)|0);
   var $34=$33;
   HEAP32[(($34)>>2)]=0;
   label = 13; break;
  case 13: 
   var $36=_malloc(284);
   var $37=(($36)|(0))==0;
   if ($37) { label = 14; break; } else { label = 23; break; }
  case 14: 
   var $39=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $40=(($39)|(0))==0;
   if ($40) { label = 20; break; } else { label = 15; break; }
  case 15: 
   var $42=$39;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$42]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 13; break; } else { label = 16; break; }
  case 16: 
   var $lpad_loopexit_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i_i$1 = tempRet0;
   var $lpad_phi_i_i$1 = $lpad_loopexit_i_i$1;var $lpad_phi_i_i$0 = $lpad_loopexit_i_i$0;label = 18; break;
  case 17: 
   var $lpad_nonloopexit_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i_i$1 = tempRet0;
   var $lpad_phi_i_i$1 = $lpad_nonloopexit_i_i$1;var $lpad_phi_i_i$0 = $lpad_nonloopexit_i_i$0;label = 18; break;
  case 18: 
   var $lpad_phi_i_i$0;
   var $lpad_phi_i_i$1;
   var $44=$lpad_phi_i_i$1;
   var $45=(($44)|(0)) < 0;
   if ($45) { label = 19; break; } else { label = 21; break; }
  case 19: 
   var $47=$lpad_phi_i_i$0;
   ___cxa_call_unexpected($47);
   throw "Reached an unreachable!";
  case 20: 
   var $49=___cxa_allocate_exception(4);
   var $50=$49;
   HEAP32[(($50)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($49, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 22; break; } else { label = 17; break; }
  case 21: 
   ___resumeException($lpad_phi_i_i$0)
  case 22: 
   throw "Reached an unreachable!";
  case 23: 
   var $54=$36;
   var $55=(($36+260)|0);
   var $56=$55;
   HEAPF32[(($56)>>2)]=1;
   var $57=(($36+264)|0);
   HEAP32[(($57)>>2)]=0; HEAP32[((($57)+(4))>>2)]=0; HEAP32[((($57)+(8))>>2)]=0; HEAP32[((($57)+(12))>>2)]=0; HEAP32[((($57)+(16))>>2)]=0;
   HEAP32[(($30)>>2)]=$54;
   var $58=(($row_i_i)|0);
   var $59=$face_i_i;
   var $60=$x_i_i;
   var $61=$y_i_i;
   var $62=$z_i_i;
   var $63=$vcap_i_i;
   var $64=$tcap_i_i;
   var $65=$e0_i_i;
   var $66=$e1_i_i;
   var $67=_fopen(((4048)|0), ((5544)|0));
   var $68=(($67)|(0))==0;
   if ($68) { label = 96; break; } else { label = 24; break; }
  case 24: 
   var $70=_fseek($67, 0, 2);
   var $71=_ftell($67);
   var $72=_fseek($67, 0, 0);
   var $73=(($71)|(0)) > -1;
   var $74=$73 ? $71 : -1;
   var $75=(($74)|(0))==0;
   var $_size_i_i_i=$75 ? 1 : $74;
   label = 25; break;
  case 25: 
   var $77=_malloc($_size_i_i_i);
   var $78=(($77)|(0))==0;
   if ($78) { label = 26; break; } else { label = 39; break; }
  case 26: 
   var $80=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $81=(($80)|(0))==0;
   if ($81) { label = 33; break; } else { label = 27; break; }
  case 27: 
   var $83=$80;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$83]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 25; break; } else { label = 28; break; }
  case 28: 
   var $lpad_loopexit_i_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i_i_i$1 = tempRet0;
   var $lpad_phi_i_i_i$1 = $lpad_loopexit_i_i_i$1;var $lpad_phi_i_i_i$0 = $lpad_loopexit_i_i_i$0;label = 30; break;
  case 29: 
   var $lpad_nonloopexit_i_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i_i_i$1 = tempRet0;
   var $lpad_phi_i_i_i$1 = $lpad_nonloopexit_i_i_i$1;var $lpad_phi_i_i_i$0 = $lpad_nonloopexit_i_i_i$0;label = 30; break;
  case 30: 
   var $lpad_phi_i_i_i$0;
   var $lpad_phi_i_i_i$1;
   var $85=$lpad_phi_i_i_i$1;
   var $86=(($85)|(0)) < 0;
   if ($86) { label = 31; break; } else { var $eh_lpad_body_i_i$1 = $lpad_phi_i_i_i$1;var $eh_lpad_body_i_i$0 = $lpad_phi_i_i_i$0;label = 36; break; }
  case 31: 
   var $88=$lpad_phi_i_i_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($88) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 32; break; } else { label = 35; break; }
  case 32: 
   throw "Reached an unreachable!";
  case 33: 
   var $90=___cxa_allocate_exception(4);
   var $91=$90;
   HEAP32[(($91)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($90, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 34; break; } else { label = 29; break; }
  case 34: 
   throw "Reached an unreachable!";
  case 35: 
   var $94$0 = ___cxa_find_matching_catch(-1, -1); $94$1 = tempRet0;
   var $eh_lpad_body_i_i$1 = $94$1;var $eh_lpad_body_i_i$0 = $94$0;label = 36; break;
  case 36: 
   var $eh_lpad_body_i_i$0;
   var $eh_lpad_body_i_i$1;
   var $95=$eh_lpad_body_i_i$1;
   var $96=(($95)|(0)) < 0;
   if ($96) { label = 37; break; } else { label = 38; break; }
  case 37: 
   var $98=$eh_lpad_body_i_i$0;
   ___cxa_call_unexpected($98);
   throw "Reached an unreachable!";
  case 38: 
   ___resumeException($eh_lpad_body_i_i$0)
  case 39: 
   var $101=_fread($77, $71, 1, $67);
   var $102=_fclose($67);
   var $103=(($77+$71)|0);
   HEAP32[(($vcap_i_i)>>2)]=0;
   HEAP32[(($tcap_i_i)>>2)]=0;
   var $104=(($row_i_i+1)|0);
   var $105=(($face_i_i)|0);
   var $106=(($36+276)|0);
   var $107=$106;
   var $src_i_i_0 = $77;label = 40; break;
  case 40: 
   var $src_i_i_0;
   var $108=(($src_i_i_0)>>>(0)) < (($103)>>>(0));
   if ($108) { label = 41; break; } else { label = 72; break; }
  case 41: 
   HEAP8[($58)]=0;
   var $_0121_ph = $src_i_i_0;var $start_i_i_i_0_ph = 0;var $done_i_i_i_0_ph = 0;var $n_i_i_i_0_ph = 0;label = 42; break;
  case 42: 
   var $n_i_i_i_0_ph;
   var $done_i_i_i_0_ph;
   var $start_i_i_i_0_ph;
   var $_0121_ph;
   var $_0121_ph125 = $_0121_ph;var $done_i_i_i_0_ph123 = $done_i_i_i_0_ph;label = 43; break;
  case 43: 
   var $done_i_i_i_0_ph123;
   var $_0121_ph125;
   var $110=$done_i_i_i_0_ph123 & 1;
   var $111=(($110 << 24) >> 24)==0;
   var $_0121 = $_0121_ph125;label = 44; break;
  case 44: 
   var $_0121;
   var $112=(($_0121)>>>(0)) < (($103)>>>(0));
   var $or_cond=$111 & $112;
   if ($or_cond) { label = 45; break; } else { label = 49; break; }
  case 45: 
   var $114=HEAP8[($_0121)];
   var $115=(($_0121+1)|0);
   var $116=(($114 << 24) >> 24);
   if ((($116)|(0))==92 | (($116)|(0))==13) {
    var $_0121 = $115;label = 44; break;
   }
   else if ((($116)|(0))==10) {
    label = 46; break;
   }
   else if ((($116)|(0))==9 | (($116)|(0))==32) {
    label = 47; break;
   }
   else {
   label = 48; break;
   }
  case 46: 
   if ($start_i_i_i_0_ph) { var $_0121_ph125 = $115;var $done_i_i_i_0_ph123 = 1;label = 43; break; } else { var $_0121 = $115;label = 44; break; }
  case 47: 
   if ($start_i_i_i_0_ph) { label = 48; break; } else { var $_0121 = $115;label = 44; break; }
  case 48: 
   var $120=((($n_i_i_i_0_ph)+(1))|0);
   var $121=(($row_i_i+$n_i_i_i_0_ph)|0);
   HEAP8[($121)]=$114;
   var $122=(($120)|(0)) < 511;
   var $done_i_i_i_0_ph123_=$122 ? $done_i_i_i_0_ph123 : 1;
   var $_0121_ph = $115;var $start_i_i_i_0_ph = 1;var $done_i_i_i_0_ph = $done_i_i_i_0_ph123_;var $n_i_i_i_0_ph = $120;label = 42; break;
  case 49: 
   var $123=(($row_i_i+$n_i_i_i_0_ph)|0);
   HEAP8[($123)]=0;
   var $124=HEAP8[($58)];
   if ((($124 << 24) >> 24)==35) {
    var $src_i_i_0 = $_0121;label = 40; break;
   }
   else if ((($124 << 24) >> 24)==118) {
    label = 50; break;
   }
   else {
   var $133 = $124;label = 52; break;
   }
  case 50: 
   var $126=HEAP8[($104)];
   if ((($126 << 24) >> 24)==110 | (($126 << 24) >> 24)==116) {
    var $src_i_i_0 = $_0121;label = 40; break;
   }
   else {
   label = 51; break;
   }
  case 51: 
   var $128=_sscanf($104, ((5632)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$x_i_i,HEAP32[(((tempVarArgs)+(8))>>2)]=$y_i_i,HEAP32[(((tempVarArgs)+(16))>>2)]=$z_i_i,tempVarArgs)); STACKTOP=tempVarArgs;
   var $129=HEAPF32[(($x_i_i)>>2)];
   var $130=HEAPF32[(($y_i_i)>>2)];
   var $131=HEAPF32[(($z_i_i)>>2)];
   __ZN15rcMeshLoaderObj9addVertexEfffRi($54, $129, $130, $131, $vcap_i_i);
   var $_pre=HEAP8[($58)];
   var $133 = $_pre;label = 52; break;
  case 52: 
   var $133;
   var $134=(($133 << 24) >> 24)==102;
   if ($134) { label = 53; break; } else { var $src_i_i_0 = $_0121;label = 40; break; }
  case 53: 
   var $136=HEAP32[(($107)>>2)];
   var $_0_ph = $104;var $j_i_i_i_0_ph = 0;label = 54; break;
  case 54: 
   var $j_i_i_i_0_ph;
   var $_0_ph;
   var $_pre129=HEAP8[($_0_ph)];
   var $_0 = $_0_ph;var $138 = $_pre129;label = 55; break;
  case 55: 
   var $138;
   var $_0;
   var $139=(($138 << 24) >> 24)==0;
   if ($139) { var $j_i_i_i_1 = $j_i_i_i_0_ph;label = 66; break; } else { var $_1 = $_0;var $140 = $138;label = 56; break; }
  case 56: 
   var $140;
   var $_1;
   var $141=(($140 << 24) >> 24)==0;
   if ($141) { var $_2 = $_1;label = 59; break; } else { label = 57; break; }
  case 57: 
   var $143=HEAP8[($_1)];
   if ((($143 << 24) >> 24)==32 | (($143 << 24) >> 24)==9) {
    label = 58; break;
   }
   else {
   var $_2 = $_1;label = 59; break;
   }
  case 58: 
   var $144=(($_1+1)|0);
   var $_pre130=HEAP8[($144)];
   var $_1 = $144;var $140 = $_pre130;label = 56; break;
  case 59: 
   var $_2;
   var $145=HEAP8[($_2)];
   var $146=(($145 << 24) >> 24)==0;
   if ($146) { var $153 = 0;label = 64; break; } else { label = 60; break; }
  case 60: 
   var $148=(($145 << 24) >> 24)==32;
   if ($148) { var $153 = 32;label = 64; break; } else { label = 61; break; }
  case 61: 
   if ((($145 << 24) >> 24)==47) {
    label = 62; break;
   }
   else if ((($145 << 24) >> 24)==9) {
    var $153 = 9;label = 64; break;
   }
   else {
   label = 63; break;
   }
  case 62: 
   HEAP8[($_2)]=0;
   label = 63; break;
  case 63: 
   var $152=(($_2+1)|0);
   var $_2 = $152;label = 59; break;
  case 64: 
   var $153;
   var $154=HEAP8[($_1)];
   var $155=(($154 << 24) >> 24)==0;
   if ($155) { var $_0 = $_2;var $138 = $153;label = 55; break; } else { label = 65; break; }
  case 65: 
   var $157=_atoi($_1);
   var $158=(($157)|(0)) < 0;
   var $_=$158 ? $136 : -1;
   var $159=((($157)+($_))|0);
   var $160=((($j_i_i_i_0_ph)+(1))|0);
   var $161=(($face_i_i+($j_i_i_i_0_ph<<2))|0);
   HEAP32[(($161)>>2)]=$159;
   var $162=(($160)|(0)) < 32;
   if ($162) { var $_0_ph = $_2;var $j_i_i_i_0_ph = $160;label = 54; break; } else { var $j_i_i_i_1 = $160;label = 66; break; }
  case 66: 
   var $j_i_i_i_1;
   var $163=HEAP32[(($105)>>2)];
   var $164=(($163)|(0)) < 0;
   var $storemerge2_i_i = 2;label = 67; break;
  case 67: 
   var $storemerge2_i_i;
   var $166=(($storemerge2_i_i)|(0)) < (($j_i_i_i_1)|(0));
   if ($166) { label = 68; break; } else { var $src_i_i_0 = $_0121;label = 40; break; }
  case 68: 
   var $168=((($storemerge2_i_i)-(1))|0);
   var $169=(($face_i_i+($168<<2))|0);
   var $170=HEAP32[(($169)>>2)];
   var $171=(($face_i_i+($storemerge2_i_i<<2))|0);
   var $172=HEAP32[(($171)>>2)];
   if ($164) { label = 71; break; } else { label = 69; break; }
  case 69: 
   var $174=HEAP32[(($107)>>2)];
   var $175=(($163)|(0)) >= (($174)|(0));
   var $176=(($170)|(0)) < 0;
   var $or_cond137=$175 | $176;
   var $or_cond137_not=$or_cond137 ^ 1;
   var $177=(($170)|(0)) < (($174)|(0));
   var $or_cond138=$or_cond137_not & $177;
   var $or_cond138_not=$or_cond138 ^ 1;
   var $178=(($172)|(0)) < 0;
   var $or_cond139=$or_cond138_not | $178;
   var $or_cond139_not=$or_cond139 ^ 1;
   var $179=(($172)|(0)) < (($174)|(0));
   var $or_cond140=$or_cond139_not & $179;
   if ($or_cond140) { label = 70; break; } else { label = 71; break; }
  case 70: 
   __ZN15rcMeshLoaderObj11addTriangleEiiiRi($54, $163, $170, $172, $tcap_i_i);
   label = 71; break;
  case 71: 
   var $182=((($storemerge2_i_i)+(1))|0);
   var $storemerge2_i_i = $182;label = 67; break;
  case 72: 
   _free($77);
   var $184=(($36+280)|0);
   var $185=$184;
   var $186=HEAP32[(($185)>>2)];
   var $187=((($186)*(3))&-1);
   var $188$0=_llvm_umul_with_overflow_i32($187, 4);
   var $188$1=tempRet0;
   var $189=$188$1;
   var $190=$188$0;
   var $191=$189 ? -1 : $190;
   var $192=(($191)|(0))==0;
   var $_size_i4_i_i=$192 ? 1 : $191;
   label = 73; break;
  case 73: 
   var $194=_malloc($_size_i4_i_i);
   var $195=(($194)|(0))==0;
   if ($195) { label = 74; break; } else { label = 83; break; }
  case 74: 
   var $197=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $198=(($197)|(0))==0;
   if ($198) { label = 81; break; } else { label = 75; break; }
  case 75: 
   var $200=$197;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$200]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 73; break; } else { label = 76; break; }
  case 76: 
   var $lpad_loopexit_i5_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i5_i_i$1 = tempRet0;
   var $lpad_phi_i9_i_i$1 = $lpad_loopexit_i5_i_i$1;var $lpad_phi_i9_i_i$0 = $lpad_loopexit_i5_i_i$0;label = 78; break;
  case 77: 
   var $lpad_nonloopexit_i7_i_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i7_i_i$1 = tempRet0;
   var $lpad_phi_i9_i_i$1 = $lpad_nonloopexit_i7_i_i$1;var $lpad_phi_i9_i_i$0 = $lpad_nonloopexit_i7_i_i$0;label = 78; break;
  case 78: 
   var $lpad_phi_i9_i_i$0;
   var $lpad_phi_i9_i_i$1;
   var $202=$lpad_phi_i9_i_i$1;
   var $203=(($202)|(0)) < 0;
   if ($203) { label = 79; break; } else { var $eh_lpad_body12_i_i$1 = $lpad_phi_i9_i_i$1;var $eh_lpad_body12_i_i$0 = $lpad_phi_i9_i_i$0;label = 85; break; }
  case 79: 
   var $205=$lpad_phi_i9_i_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($205) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 80; break; } else { label = 84; break; }
  case 80: 
   throw "Reached an unreachable!";
  case 81: 
   var $207=___cxa_allocate_exception(4);
   var $208=$207;
   HEAP32[(($208)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($207, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 82; break; } else { label = 77; break; }
  case 82: 
   throw "Reached an unreachable!";
  case 83: 
   var $210=$194;
   var $211=(($36+272)|0);
   var $212=$211;
   HEAP32[(($212)>>2)]=$210;
   var $213=(($36+268)|0);
   var $214=$213;
   var $215=(($36+264)|0);
   var $216=$215;
   var $217=(($e0_i_i+4)|0);
   var $218=(($e1_i_i+8)|0);
   var $219=(($e0_i_i+8)|0);
   var $220=(($e1_i_i+4)|0);
   var $221=(($e1_i_i)|0);
   var $222=(($e0_i_i)|0);
   var $storemerge_i_i = 0;label = 88; break;
  case 84: 
   var $224$0 = ___cxa_find_matching_catch(-1, -1); $224$1 = tempRet0;
   var $eh_lpad_body12_i_i$1 = $224$1;var $eh_lpad_body12_i_i$0 = $224$0;label = 85; break;
  case 85: 
   var $eh_lpad_body12_i_i$0;
   var $eh_lpad_body12_i_i$1;
   var $225=$eh_lpad_body12_i_i$1;
   var $226=(($225)|(0)) < 0;
   if ($226) { label = 86; break; } else { label = 87; break; }
  case 86: 
   var $228=$eh_lpad_body12_i_i$0;
   ___cxa_call_unexpected($228);
   throw "Reached an unreachable!";
  case 87: 
   ___resumeException($eh_lpad_body12_i_i$0)
  case 88: 
   var $storemerge_i_i;
   var $231=HEAP32[(($185)>>2)];
   var $232=((($231)*(3))&-1);
   var $233=(($storemerge_i_i)|(0)) < (($232)|(0));
   if ($233) { label = 89; break; } else { label = 95; break; }
  case 89: 
   var $235=HEAP32[(($214)>>2)];
   var $236=(($235+($storemerge_i_i<<2))|0);
   var $237=HEAP32[(($236)>>2)];
   var $238=((($237)*(3))&-1);
   var $239=HEAP32[(($216)>>2)];
   var $240=((($storemerge_i_i)+(1))|0);
   var $241=(($235+($240<<2))|0);
   var $242=HEAP32[(($241)>>2)];
   var $243=((($242)*(3))&-1);
   var $244=((($storemerge_i_i)+(2))|0);
   var $245=(($235+($244<<2))|0);
   var $246=HEAP32[(($245)>>2)];
   var $247=((($246)*(3))&-1);
   var $storemerge1_i_i = 0;label = 90; break;
  case 90: 
   var $storemerge1_i_i;
   var $249=(($storemerge1_i_i)|(0)) < 3;
   if ($249) { label = 91; break; } else { label = 92; break; }
  case 91: 
   var $_sum134=((($243)+($storemerge1_i_i))|0);
   var $251=(($239+($_sum134<<2))|0);
   var $252=HEAPF32[(($251)>>2)];
   var $_sum135=((($238)+($storemerge1_i_i))|0);
   var $253=(($239+($_sum135<<2))|0);
   var $254=HEAPF32[(($253)>>2)];
   var $255=($252)-($254);
   var $256=(($e0_i_i+($storemerge1_i_i<<2))|0);
   HEAPF32[(($256)>>2)]=$255;
   var $_sum136=((($247)+($storemerge1_i_i))|0);
   var $257=(($239+($_sum136<<2))|0);
   var $258=HEAPF32[(($257)>>2)];
   var $259=($258)-($254);
   var $260=(($e1_i_i+($storemerge1_i_i<<2))|0);
   HEAPF32[(($260)>>2)]=$259;
   var $261=((($storemerge1_i_i)+(1))|0);
   var $storemerge1_i_i = $261;label = 90; break;
  case 92: 
   var $263=HEAP32[(($212)>>2)];
   var $264=(($263+($storemerge_i_i<<2))|0);
   var $265=HEAPF32[(($217)>>2)];
   var $266=HEAPF32[(($218)>>2)];
   var $267=($265)*($266);
   var $268=HEAPF32[(($219)>>2)];
   var $269=HEAPF32[(($220)>>2)];
   var $270=($268)*($269);
   var $271=($267)-($270);
   HEAPF32[(($264)>>2)]=$271;
   var $272=HEAPF32[(($221)>>2)];
   var $273=($268)*($272);
   var $274=HEAPF32[(($222)>>2)];
   var $275=($274)*($266);
   var $276=($273)-($275);
   var $_sum=((($storemerge_i_i)+(1))|0);
   var $277=(($263+($_sum<<2))|0);
   HEAPF32[(($277)>>2)]=$276;
   var $278=($274)*($269);
   var $279=($265)*($272);
   var $280=($278)-($279);
   var $_sum133=((($storemerge_i_i)+(2))|0);
   var $281=(($263+($_sum133<<2))|0);
   HEAPF32[(($281)>>2)]=$280;
   var $282=($271)*($271);
   var $283=($276)*($276);
   var $284=($282)+($283);
   var $285=($280)*($280);
   var $286=($284)+($285);
   var $287=Math.sqrt($286);
   var $288=$287 > 0;
   if ($288) { label = 93; break; } else { label = 94; break; }
  case 93: 
   var $290=(1)/($287);
   var $291=($271)*($290);
   HEAPF32[(($264)>>2)]=$291;
   var $292=($276)*($290);
   HEAPF32[(($277)>>2)]=$292;
   var $293=($280)*($290);
   HEAPF32[(($281)>>2)]=$293;
   label = 94; break;
  case 94: 
   var $295=((($storemerge_i_i)+(3))|0);
   var $storemerge_i_i = $295;label = 88; break;
  case 95: 
   var $296=_strncpy($36, ((4048)|0), 260);
   var $297=(($36+259)|0);
   HEAP8[($297)]=0;
   var $298=HEAP32[(($30)>>2)];
   var $299=(($298+264)|0);
   var $300=HEAP32[(($299)>>2)];
   var $301=(($298+276)|0);
   var $302=HEAP32[(($301)>>2)];
   var $303=(($3+8)|0);
   var $304=$303;
   var $305=(($3+20)|0);
   var $306=$305;
   __Z12rcCalcBoundsPKfiPfS1_($300, $302, $304, $306);
   label = 97; break;
  case 96: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((5648)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=((4048)|0),tempVarArgs)); STACKTOP=tempVarArgs;
   label = 109; break;
  case 97: 
   var $308=_malloc(20);
   var $309=(($308)|(0))==0;
   if ($309) { label = 98; break; } else { label = 107; break; }
  case 98: 
   var $311=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $312=(($311)|(0))==0;
   if ($312) { label = 104; break; } else { label = 99; break; }
  case 99: 
   var $314=$311;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$314]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 97; break; } else { label = 100; break; }
  case 100: 
   var $lpad_loopexit_i4_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i4_i$1 = tempRet0;
   var $lpad_phi_i8_i$1 = $lpad_loopexit_i4_i$1;var $lpad_phi_i8_i$0 = $lpad_loopexit_i4_i$0;label = 102; break;
  case 101: 
   var $lpad_nonloopexit_i6_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i6_i$1 = tempRet0;
   var $lpad_phi_i8_i$1 = $lpad_nonloopexit_i6_i$1;var $lpad_phi_i8_i$0 = $lpad_nonloopexit_i6_i$0;label = 102; break;
  case 102: 
   var $lpad_phi_i8_i$0;
   var $lpad_phi_i8_i$1;
   var $316=$lpad_phi_i8_i$1;
   var $317=(($316)|(0)) < 0;
   if ($317) { label = 103; break; } else { label = 105; break; }
  case 103: 
   var $319=$lpad_phi_i8_i$0;
   ___cxa_call_unexpected($319);
   throw "Reached an unreachable!";
  case 104: 
   var $321=___cxa_allocate_exception(4);
   var $322=$321;
   HEAP32[(($322)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($321, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 106; break; } else { label = 101; break; }
  case 105: 
   ___resumeException($lpad_phi_i8_i$0)
  case 106: 
   throw "Reached an unreachable!";
  case 107: 
   var $326=$308;
   var $327=$308;
   HEAP32[(($327)>>2)]=0;
   var $328=(($308+8)|0);
   var $329=$328;
   HEAP32[(($329)>>2)]=0;
   var $330=$3;
   HEAP32[(($330)>>2)]=$326;
   var $331=HEAP32[(($30)>>2)];
   var $332=(($331+264)|0);
   var $333=HEAP32[(($332)>>2)];
   var $334=(($331+268)|0);
   var $335=HEAP32[(($334)>>2)];
   var $336=(($331+280)|0);
   var $337=HEAP32[(($336)>>2)];
   var $338=__Z21rcCreateChunkyTriMeshPKfPKiiiP15rcChunkyTriMesh($333, $335, $337, $326);
   if ($338) { var $storemerge = 1;label = 110; break; } else { label = 108; break; }
  case 108: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((3560)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   label = 109; break;
  case 109: 
   var $341=_printf(((4024)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $storemerge = 0;label = 110; break;
  case 110: 
   var $storemerge;
   STACKTOP = sp;
   return $storemerge;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10emscripten8internal7InvokerIiJEE6invokeEPFivE($fn) {
 var label = 0;
 var $1=FUNCTION_TABLE[$fn]();
 return $1;
}
function __ZN10emscripten8internal7InvokerIvJfEE6invokeEPFvfEf($fn, $args) {
 var label = 0;
 FUNCTION_TABLE[$fn]($args);
 return;
}
function __ZN10emscripten8internal7InvokerIvJiiiiEE6invokeEPFviiiiEiiii($fn, $args, $args1, $args2, $args3) {
 var label = 0;
 FUNCTION_TABLE[$fn]($args, $args1, $args2, $args3);
 return;
}
function __ZN10emscripten8internal7InvokerIvJfffiEE6invokeEPFvfffiEfffi($fn, $args, $args1, $args2, $args3) {
 var label = 0;
 FUNCTION_TABLE[$fn]($args, $args1, $args2, $args3);
 return;
}
function __ZN10emscripten8internal7InvokerIvJEE6invokeEPFvvE($fn) {
 var label = 0;
 FUNCTION_TABLE[$fn]();
 return;
}
function __ZN10emscripten8internal7InvokerIbJEE6invokeEPFbvE($fn) {
 var label = 0;
 var $1=FUNCTION_TABLE[$fn]();
 return $1;
}
function __Z5buildv() {
 var label = 0;
 var tempVarArgs = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 304)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $navData=sp;
   var $navDataSize=(sp)+(8);
   var $params=(sp)+(16);
   var $1=(sp)+(160);
   var $2=HEAP32[((7616)>>2)];
   var $3=(($2)|(0))==0;
   if ($3) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $5=(($2+4)|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=(($6)|(0))==0;
   if ($7) { label = 3; break; } else { label = 4; break; }
  case 3: 
   var $9=_printf(((3920)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((3920)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 4: 
   var $11=_printf(((5112)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $12=HEAP32[((7584)>>2)];
   var $13=(($12)|(0))==0;
   if ($13) { label = 6; break; } else { label = 5; break; }
  case 5: 
   _free($12);
   label = 6; break;
  case 6: 
   HEAP32[((7584)>>2)]=0;
   var $15=HEAP32[((7592)>>2)];
   var $16=(($15)|(0))==0;
   if ($16) { label = 13; break; } else { label = 7; break; }
  case 7: 
   var $18=(($15+40)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==0;
   if ($20) { label = 9; break; } else { label = 8; break; }
  case 8: 
   var $22=$19;
   _free($22);
   label = 9; break;
  case 9: 
   var $23=(($15+44)|0);
   var $_pre140=HEAP32[(($23)>>2)];
   var $25 = $_pre140;label = 10; break;
  case 10: 
   var $25;
   var $26=(($25)|(0))==0;
   if ($26) { label = 12; break; } else { label = 11; break; }
  case 11: 
   var $27=(($25)|0);
   var $28=HEAP32[(($27)>>2)];
   var $29=$25;
   _free($29);
   HEAP32[(($23)>>2)]=$28;
   var $25 = $28;label = 10; break;
  case 12: 
   var $30=$15;
   _free($30);
   label = 13; break;
  case 13: 
   HEAP32[((7592)>>2)]=0;
   var $31=HEAP32[((7640)>>2)];
   __Z24rcFreeCompactHeightfieldP20rcCompactHeightfield($31);
   HEAP32[((7640)>>2)]=0;
   var $32=HEAP32[((7632)>>2)];
   __Z16rcFreeContourSetP12rcContourSet($32);
   HEAP32[((7632)>>2)]=0;
   var $33=HEAP32[((7600)>>2)];
   __Z14rcFreePolyMeshP10rcPolyMesh($33);
   HEAP32[((7600)>>2)]=0;
   var $34=HEAP32[((7624)>>2)];
   var $35=(($34)|(0))==0;
   if ($35) { label = 21; break; } else { label = 14; break; }
  case 14: 
   var $37=(($34)|0);
   var $38=HEAP32[(($37)>>2)];
   var $39=(($38)|(0))==0;
   if ($39) { label = 16; break; } else { label = 15; break; }
  case 15: 
   var $41=$38;
   _free($41);
   label = 16; break;
  case 16: 
   var $42=(($34+4)|0);
   var $43=HEAP32[(($42)>>2)];
   var $44=(($43)|(0))==0;
   if ($44) { label = 18; break; } else { label = 17; break; }
  case 17: 
   var $46=$43;
   _free($46);
   label = 18; break;
  case 18: 
   var $47=(($34+8)|0);
   var $48=HEAP32[(($47)>>2)];
   var $49=(($48)|(0))==0;
   if ($49) { label = 20; break; } else { label = 19; break; }
  case 19: 
   _free($48);
   label = 20; break;
  case 20: 
   var $51=$34;
   _free($51);
   label = 21; break;
  case 21: 
   HEAP32[((7624)>>2)]=0;
   var $52=HEAP32[((7608)>>2)];
   __Z13dtFreeNavMeshP9dtNavMesh($52);
   HEAP32[((7608)>>2)]=0;
   var $53=HEAP32[((7616)>>2)];
   var $54=(($53+8)|0);
   var $55=(($53+20)|0);
   var $56=(($53+4)|0);
   var $57=HEAP32[(($56)>>2)];
   var $58=(($57+264)|0);
   var $59=HEAP32[(($58)>>2)];
   var $60=(($57+276)|0);
   var $61=HEAP32[(($60)>>2)];
   var $62=(($57+268)|0);
   var $63=HEAP32[(($62)>>2)];
   var $64=(($57+280)|0);
   var $65=HEAP32[(($64)>>2)];
   _memset(7648, 0, 92);
   var $66=HEAPF32[((64)>>2)];
   HEAPF32[((((7664)|0))>>2)]=$66;
   var $67=HEAPF32[((72)>>2)];
   HEAPF32[((((7668)|0))>>2)]=$67;
   var $68=HEAPF32[((88)>>2)];
   HEAPF32[((((7696)|0))>>2)]=$68;
   var $69=HEAPF32[((104)>>2)];
   var $70=($69)/($67);
   var $71=Math.ceil($70);
   var $72=(($71)&-1);
   HEAP32[((((7700)|0))>>2)]=$72;
   var $73=HEAPF32[((96)>>2)];
   var $74=($73)/($67);
   var $75=Math.floor($74);
   var $76=(($75)&-1);
   HEAP32[((((7704)|0))>>2)]=$76;
   var $77=HEAPF32[((80)>>2)];
   var $78=($77)/($66);
   var $79=Math.ceil($78);
   var $80=(($79)&-1);
   HEAP32[((((7708)|0))>>2)]=$80;
   var $81=HEAPF32[((32)>>2)];
   var $82=($81)/($66);
   var $83=(($82)&-1);
   HEAP32[((((7712)|0))>>2)]=$83;
   var $84=HEAPF32[((40)>>2)];
   HEAPF32[((((7716)|0))>>2)]=$84;
   var $85=HEAPF32[((16)>>2)];
   var $86=($85)*($85);
   var $87=(($86)&-1);
   HEAP32[((((7720)|0))>>2)]=$87;
   var $88=HEAPF32[((24)>>2)];
   var $89=($88)*($88);
   var $90=(($89)&-1);
   HEAP32[((((7724)|0))>>2)]=$90;
   var $91=HEAPF32[((8)>>2)];
   var $92=(($91)&-1);
   HEAP32[((((7728)|0))>>2)]=$92;
   var $93=HEAPF32[((56)>>2)];
   var $94=$93 < 0.8999999761581421;
   if ($94) { var $98 = 0;label = 23; break; } else { label = 22; break; }
  case 22: 
   var $96=($66)*($93);
   var $98 = $96;label = 23; break;
  case 23: 
   var $98;
   HEAPF32[((((7732)|0))>>2)]=$98;
   var $99=HEAPF32[((48)>>2)];
   var $100=($67)*($99);
   HEAPF32[((((7736)|0))>>2)]=$100;
   var $101=HEAPF32[(($54)>>2)];
   HEAPF32[((((7672)|0))>>2)]=$101;
   var $102=(($53+12)|0);
   var $103=HEAPF32[(($102)>>2)];
   HEAPF32[((((7676)|0))>>2)]=$103;
   var $104=(($53+16)|0);
   var $105=HEAPF32[(($104)>>2)];
   HEAPF32[((((7680)|0))>>2)]=$105;
   var $106=HEAPF32[(($55)>>2)];
   HEAPF32[((((7684)|0))>>2)]=$106;
   var $107=(($53+24)|0);
   var $108=HEAPF32[(($107)>>2)];
   HEAPF32[((((7688)|0))>>2)]=$108;
   var $109=(($53+28)|0);
   var $110=HEAPF32[(($109)>>2)];
   HEAPF32[((((7692)|0))>>2)]=$110;
   var $111=($106)-($101);
   var $112=($111)/($66);
   var $113=($112)+(0.5);
   var $114=(($113)&-1);
   HEAP32[((((7648)|0))>>2)]=$114;
   var $115=($110)-($105);
   var $116=($115)/($66);
   var $117=($116)+(0.5);
   var $118=(($117)&-1);
   HEAP32[((((7652)|0))>>2)]=$118;
   var $119=_printf(((3784)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 1, ((3536)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $120=HEAP32[((((7648)|0))>>2)];
   var $121=HEAP32[((((7652)|0))>>2)];
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 1, ((3464)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$120,HEAP32[(((tempVarArgs)+(8))>>2)]=$121,tempVarArgs)); STACKTOP=tempVarArgs;
   var $122=(($61)|(0));
   var $123=($122)/(1000);
   var $124=$123;
   var $125=(($65)|(0));
   var $126=($125)/(1000);
   var $127=$126;
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 1, ((3384)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 16)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAPF64[((tempVarArgs)>>3)]=$124,HEAPF64[(((tempVarArgs)+(8))>>3)]=$127,tempVarArgs)); STACKTOP=tempVarArgs;
   var $128=_printf(((3280)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $129=_malloc(52);
   var $130=$129;
   _memset($129, 0, 52);
   HEAP32[((7592)>>2)]=$130;
   var $131=(($129)|(0))==0;
   if ($131) { label = 24; break; } else { label = 25; break; }
  case 24: 
   var $133=_printf(((3184)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((3088)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 25: 
   var $135=HEAP32[((((7648)|0))>>2)];
   var $136=HEAP32[((((7652)|0))>>2)];
   var $137=HEAPF32[((((7664)|0))>>2)];
   var $138=HEAPF32[((((7668)|0))>>2)];
   var $139=__Z19rcCreateHeightfieldP9rcContextR13rcHeightfieldiiPKfS4_ff($130, $135, $136, ((7672)|0), ((7684)|0), $137, $138);
   if ($139) { label = 27; break; } else { label = 26; break; }
  case 26: 
   var $141=_printf(((2984)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2928)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 27: 
   var $143=_printf(((2840)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $144=(($65)|(0)) > -1;
   var $145=$144 ? $65 : -1;
   var $146=(($145)|(0))==0;
   var $_size_i=$146 ? 1 : $145;
   label = 28; break;
  case 28: 
   var $148=_malloc($_size_i);
   var $149=(($148)|(0))==0;
   if ($149) { label = 29; break; } else { label = 42; break; }
  case 29: 
   var $151=(tempValue=HEAP32[((8224)>>2)],HEAP32[((8224)>>2)]=tempValue+0,tempValue);
   var $152=(($151)|(0))==0;
   if ($152) { label = 36; break; } else { label = 30; break; }
  case 30: 
   var $154=$151;
   (function() { try { __THREW__ = 0; return FUNCTION_TABLE[$154]() } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 28; break; } else { label = 31; break; }
  case 31: 
   var $lpad_loopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_loopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_loopexit_i$1;var $lpad_phi_i$0 = $lpad_loopexit_i$0;label = 33; break;
  case 32: 
   var $lpad_nonloopexit_i$0 = ___cxa_find_matching_catch(-1, -1); $lpad_nonloopexit_i$1 = tempRet0;
   var $lpad_phi_i$1 = $lpad_nonloopexit_i$1;var $lpad_phi_i$0 = $lpad_nonloopexit_i$0;label = 33; break;
  case 33: 
   var $lpad_phi_i$0;
   var $lpad_phi_i$1;
   var $156=$lpad_phi_i$1;
   var $157=(($156)|(0)) < 0;
   if ($157) { label = 34; break; } else { var $eh_lpad_body$1 = $lpad_phi_i$1;var $eh_lpad_body$0 = $lpad_phi_i$0;label = 39; break; }
  case 34: 
   var $159=$lpad_phi_i$0;
   (function() { try { __THREW__ = 0; return ___cxa_call_unexpected($159) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 35; break; } else { label = 38; break; }
  case 35: 
   throw "Reached an unreachable!";
  case 36: 
   var $161=___cxa_allocate_exception(4);
   var $162=$161;
   HEAP32[(($162)>>2)]=(((6664)|0));
   (function() { try { __THREW__ = 0; return ___cxa_throw($161, 7384, (110)) } catch(e) { if (typeof e != "number") throw e; if (ABORT) throw e; __THREW__ = 1; return null } })();if (!__THREW__) { label = 37; break; } else { label = 32; break; }
  case 37: 
   throw "Reached an unreachable!";
  case 38: 
   var $165$0 = ___cxa_find_matching_catch(-1, -1); $165$1 = tempRet0;
   var $eh_lpad_body$1 = $165$1;var $eh_lpad_body$0 = $165$0;label = 39; break;
  case 39: 
   var $eh_lpad_body$0;
   var $eh_lpad_body$1;
   var $166=$eh_lpad_body$1;
   var $167=(($166)|(0)) < 0;
   if ($167) { label = 40; break; } else { label = 41; break; }
  case 40: 
   var $169=$eh_lpad_body$0;
   ___cxa_call_unexpected($169);
   throw "Reached an unreachable!";
  case 41: 
   ___resumeException($eh_lpad_body$0)
  case 42: 
   HEAP32[((7584)>>2)]=$148;
   _memset($148, 0, $65);
   var $172=HEAPF32[((((7696)|0))>>2)];
   __Z23rcMarkWalkableTrianglesP9rcContextfPKfiPKiiPh($172, $59, $61, $63, $65, $148);
   var $173=_printf(((2480)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=4,tempVarArgs)); STACKTOP=tempVarArgs;
   var $174=HEAP32[((7584)>>2)];
   var $175=HEAP32[((7592)>>2)];
   var $176=HEAP32[((((7704)|0))>>2)];
   __Z20rcRasterizeTrianglesP9rcContextPKfiPKiPKhiR13rcHeightfieldi(0, $59, $61, $63, $174, $65, $175, $176);
   var $177=HEAP32[((7584)>>2)];
   var $178=(($177)|(0))==0;
   if ($178) { label = 44; break; } else { label = 43; break; }
  case 43: 
   _free($177);
   label = 44; break;
  case 44: 
   HEAP32[((7584)>>2)]=0;
   var $180=HEAP32[((((7704)|0))>>2)];
   var $181=HEAP32[((7592)>>2)];
   __Z35rcFilterLowHangingWalkableObstaclesP9rcContextiR13rcHeightfield(0, $180, $181);
   var $182=HEAP32[((((7700)|0))>>2)];
   var $183=HEAP32[((((7704)|0))>>2)];
   var $184=HEAP32[((7592)>>2)];
   __Z18rcFilterLedgeSpansP9rcContextiiR13rcHeightfield(0, $182, $183, $184);
   var $185=HEAP32[((((7700)|0))>>2)];
   var $186=HEAP32[((7592)>>2)];
   __Z30rcFilterWalkableLowHeightSpansP9rcContextiR13rcHeightfield(0, $185, $186);
   var $187=_printf(((2464)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $188=_malloc(76);
   var $189=$188;
   _memset($188, 0, 76);
   HEAP32[((7640)>>2)]=$189;
   var $190=(($188)|(0))==0;
   if ($190) { label = 45; break; } else { label = 46; break; }
  case 45: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2376)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 46: 
   var $193=HEAP32[((((7700)|0))>>2)];
   var $194=HEAP32[((((7704)|0))>>2)];
   var $195=HEAP32[((7592)>>2)];
   var $196=__Z25rcBuildCompactHeightfieldP9rcContextiiR13rcHeightfieldR20rcCompactHeightfield(0, $193, $194, $195, $189);
   if ($196) { label = 48; break; } else { label = 47; break; }
  case 47: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2264)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 48: 
   var $199=HEAP32[((7592)>>2)];
   var $200=(($199)|(0))==0;
   if ($200) { label = 55; break; } else { label = 49; break; }
  case 49: 
   var $202=(($199+40)|0);
   var $203=HEAP32[(($202)>>2)];
   var $204=(($203)|(0))==0;
   if ($204) { label = 51; break; } else { label = 50; break; }
  case 50: 
   var $206=$203;
   _free($206);
   label = 51; break;
  case 51: 
   var $207=(($199+44)|0);
   var $_pre139=HEAP32[(($207)>>2)];
   var $209 = $_pre139;label = 52; break;
  case 52: 
   var $209;
   var $210=(($209)|(0))==0;
   if ($210) { label = 54; break; } else { label = 53; break; }
  case 53: 
   var $211=(($209)|0);
   var $212=HEAP32[(($211)>>2)];
   var $213=$209;
   _free($213);
   HEAP32[(($207)>>2)]=$212;
   var $209 = $212;label = 52; break;
  case 54: 
   var $214=$199;
   _free($214);
   label = 55; break;
  case 55: 
   HEAP32[((7592)>>2)]=0;
   var $216=HEAP32[((((7708)|0))>>2)];
   var $217=HEAP32[((7640)>>2)];
   var $218=__Z19rcErodeWalkableAreaP9rcContextiR20rcCompactHeightfield(0, $216, $217);
   if ($218) { label = 57; break; } else { label = 56; break; }
  case 56: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2224)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 57: 
   var $221=HEAP32[((7616)>>2)];
   var $storemerge = 0;var $223 = $221;label = 58; break;
  case 58: 
   var $223;
   var $storemerge;
   var $224=(($223+50212)|0);
   var $225=HEAP32[(($224)>>2)];
   var $226=(($storemerge)|(0)) < (($225)|(0));
   if ($226) { label = 59; break; } else { label = 60; break; }
  case 59: 
   var $228=(($221+9252+((($storemerge)*(160))&-1))|0);
   var $229=(($221+9252+((($storemerge)*(160))&-1)+152)|0);
   var $230=HEAP32[(($229)>>2)];
   var $231=(($221+9252+((($storemerge)*(160))&-1)+144)|0);
   var $232=HEAPF32[(($231)>>2)];
   var $233=(($221+9252+((($storemerge)*(160))&-1)+148)|0);
   var $234=HEAPF32[(($233)>>2)];
   var $235=(($221+9252+((($storemerge)*(160))&-1)+156)|0);
   var $236=HEAP32[(($235)>>2)];
   var $237=(($236) & 255);
   var $238=HEAP32[((7640)>>2)];
   __Z20rcMarkConvexPolyAreaP9rcContextPKfiffhR20rcCompactHeightfield(0, $228, $230, $232, $234, $237, $238);
   var $239=((($storemerge)+(1))|0);
   var $_pre=HEAP32[((7616)>>2)];
   var $storemerge = $239;var $223 = $_pre;label = 58; break;
  case 60: 
   var $241=HEAP32[((7640)>>2)];
   var $242=__Z20rcBuildDistanceFieldP9rcContextR20rcCompactHeightfield(0, $241);
   if ($242) { label = 62; break; } else { label = 61; break; }
  case 61: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2112)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 62: 
   var $245=HEAP32[((7640)>>2)];
   var $246=HEAP32[((((7720)|0))>>2)];
   var $247=HEAP32[((((7724)|0))>>2)];
   var $248=__Z14rcBuildRegionsP9rcContextR20rcCompactHeightfieldiii(0, $245, 0, $246, $247);
   if ($248) { label = 64; break; } else { label = 63; break; }
  case 63: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2168)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 64: 
   var $251=_printf(((2080)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $252=_malloc(52);
   var $253=$252;
   _memset($252, 0, 52);
   HEAP32[((7632)>>2)]=$253;
   var $254=(($252)|(0))==0;
   if ($254) { label = 65; break; } else { label = 66; break; }
  case 65: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((2040)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 66: 
   var $257=HEAP32[((7640)>>2)];
   var $258=HEAPF32[((((7716)|0))>>2)];
   var $259=HEAP32[((((7712)|0))>>2)];
   var $260=__Z15rcBuildContoursP9rcContextR20rcCompactHeightfieldfiR12rcContourSeti(0, $257, $258, $259, $253);
   if ($260) { label = 68; break; } else { label = 67; break; }
  case 67: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1928)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 68: 
   var $263=HEAP32[((7632)>>2)];
   var $264=(($263+4)|0);
   var $265=HEAP32[(($264)>>2)];
   var $266=HEAPF32[((((7716)|0))>>2)];
   var $267=$266;
   var $268=HEAP32[((((7712)|0))>>2)];
   var $269=_printf(((1664)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 24)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$265,HEAPF64[(((tempVarArgs)+(8))>>3)]=$267,HEAP32[(((tempVarArgs)+(16))>>2)]=$268,tempVarArgs)); STACKTOP=tempVarArgs;
   var $270=_malloc(72);
   var $271=$270;
   _memset($270, 0, 72);
   HEAP32[((7600)>>2)]=$271;
   var $272=(($270)|(0))==0;
   if ($272) { label = 69; break; } else { label = 70; break; }
  case 69: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1624)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 70: 
   var $275=HEAP32[((7632)>>2)];
   var $276=HEAP32[((((7728)|0))>>2)];
   var $277=__Z15rcBuildPolyMeshP9rcContextR12rcContourSetiR10rcPolyMesh(0, $275, $276, $271);
   if ($277) { label = 72; break; } else { label = 71; break; }
  case 71: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1568)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 72: 
   var $280=_printf(((1520)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $281=_malloc(24);
   var $282=$281;
   HEAP32[(($281)>>2)]=0; HEAP32[((($281)+(4))>>2)]=0; HEAP32[((($281)+(8))>>2)]=0; HEAP32[((($281)+(12))>>2)]=0; HEAP32[((($281)+(16))>>2)]=0; HEAP32[((($281)+(20))>>2)]=0;
   HEAP32[((7624)>>2)]=$282;
   var $283=(($281)|(0))==0;
   if ($283) { label = 73; break; } else { label = 74; break; }
  case 73: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1480)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 74: 
   var $286=HEAP32[((7600)>>2)];
   var $287=HEAP32[((7640)>>2)];
   var $288=HEAPF32[((((7732)|0))>>2)];
   var $289=HEAPF32[((((7736)|0))>>2)];
   var $290=__Z21rcBuildPolyMeshDetailP9rcContextRK10rcPolyMeshRK20rcCompactHeightfieldffR16rcPolyMeshDetail(0, $286, $287, $288, $289, $282);
   if ($290) { label = 76; break; } else { label = 75; break; }
  case 75: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1424)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 76: 
   var $293=HEAP32[((7640)>>2)];
   __Z24rcFreeCompactHeightfieldP20rcCompactHeightfield($293);
   HEAP32[((7640)>>2)]=0;
   var $294=HEAP32[((7632)>>2)];
   __Z16rcFreeContourSetP12rcContourSet($294);
   HEAP32[((7632)>>2)]=0;
   var $295=_printf(((1400)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $296=HEAP32[((((7728)|0))>>2)];
   var $297=(($296)|(0)) < 7;
   if ($297) { label = 77; break; } else { label = 98; break; }
  case 77: 
   HEAP32[(($navData)>>2)]=0;
   HEAP32[(($navDataSize)>>2)]=0;
   var $299=HEAP32[((7600)>>2)];
   var $300=(($299+24)|0);
   var $301=HEAP32[(($300)>>2)];
   var $302=_printf(((1376)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$301,tempVarArgs)); STACKTOP=tempVarArgs;
   var $303=HEAP32[((7600)>>2)];
   var $304=(($303+24)|0);
   var $305=(($303+16)|0);
   var $306=(($303+12)|0);
   var $storemerge1 = 0;label = 78; break;
  case 78: 
   var $storemerge1;
   var $308=HEAP32[(($304)>>2)];
   var $309=(($storemerge1)|(0)) < (($308)|(0));
   if ($309) { label = 79; break; } else { label = 86; break; }
  case 79: 
   var $311=HEAP32[(($305)>>2)];
   var $312=(($311+$storemerge1)|0);
   var $313=HEAP8[($312)];
   var $314=(($313 << 24) >> 24)==63;
   if ($314) { label = 80; break; } else { var $317 = $313;label = 81; break; }
  case 80: 
   HEAP8[($312)]=0;
   var $_pre137=HEAP32[(($305)>>2)];
   var $_phi_trans_insert=(($_pre137+$storemerge1)|0);
   var $_pre138=HEAP8[($_phi_trans_insert)];
   var $317 = $_pre138;label = 81; break;
  case 81: 
   var $317;
   if ((($317 << 24) >> 24)==0 | (($317 << 24) >> 24)==4 | (($317 << 24) >> 24)==2) {
    label = 82; break;
   }
   else if ((($317 << 24) >> 24)==1) {
    label = 83; break;
   }
   else if ((($317 << 24) >> 24)==3) {
    label = 84; break;
   }
   else {
   label = 85; break;
   }
  case 82: 
   var $319=HEAP32[(($306)>>2)];
   var $320=(($319+($storemerge1<<1))|0);
   HEAP16[(($320)>>1)]=1;
   label = 85; break;
  case 83: 
   var $322=HEAP32[(($306)>>2)];
   var $323=(($322+($storemerge1<<1))|0);
   HEAP16[(($323)>>1)]=2;
   label = 85; break;
  case 84: 
   var $325=HEAP32[(($306)>>2)];
   var $326=(($325+($storemerge1<<1))|0);
   HEAP16[(($326)>>1)]=5;
   label = 85; break;
  case 85: 
   var $328=((($storemerge1)+(1))|0);
   var $storemerge1 = $328;label = 78; break;
  case 86: 
   var $330=$params;
   _memset($330, 0, 140);
   var $331=(($303)|0);
   var $332=HEAP32[(($331)>>2)];
   var $333=(($params)|0);
   HEAP32[(($333)>>2)]=$332;
   var $334=(($303+20)|0);
   var $335=HEAP32[(($334)>>2)];
   var $336=(($params+4)|0);
   HEAP32[(($336)>>2)]=$335;
   var $337=(($303+4)|0);
   var $338=HEAP32[(($337)>>2)];
   var $339=(($params+8)|0);
   HEAP32[(($339)>>2)]=$338;
   var $340=HEAP32[(($305)>>2)];
   var $341=(($params+16)|0);
   HEAP32[(($341)>>2)]=$340;
   var $342=HEAP32[(($306)>>2)];
   var $343=(($params+12)|0);
   HEAP32[(($343)>>2)]=$342;
   var $344=HEAP32[(($304)>>2)];
   var $345=(($params+20)|0);
   HEAP32[(($345)>>2)]=$344;
   var $346=(($303+32)|0);
   var $347=HEAP32[(($346)>>2)];
   var $348=(($params+24)|0);
   HEAP32[(($348)>>2)]=$347;
   var $349=HEAP32[((7624)>>2)];
   var $350=(($349)|0);
   var $351=HEAP32[(($350)>>2)];
   var $352=(($params+28)|0);
   HEAP32[(($352)>>2)]=$351;
   var $353=(($349+4)|0);
   var $354=HEAP32[(($353)>>2)];
   var $355=(($params+32)|0);
   HEAP32[(($355)>>2)]=$354;
   var $356=(($349+16)|0);
   var $357=HEAP32[(($356)>>2)];
   var $358=(($params+36)|0);
   HEAP32[(($358)>>2)]=$357;
   var $359=(($349+8)|0);
   var $360=HEAP32[(($359)>>2)];
   var $361=(($params+40)|0);
   HEAP32[(($361)>>2)]=$360;
   var $362=(($349+20)|0);
   var $363=HEAP32[(($362)>>2)];
   var $364=(($params+44)|0);
   HEAP32[(($364)>>2)]=$363;
   var $365=HEAP32[((7616)>>2)];
   var $366=(($365+32)|0);
   var $367=(($params+48)|0);
   HEAP32[(($367)>>2)]=$366;
   var $368=(($365+6176)|0);
   var $369=(($params+52)|0);
   HEAP32[(($369)>>2)]=$368;
   var $370=(($365+7200)|0);
   var $371=(($params+64)|0);
   HEAP32[(($371)>>2)]=$370;
   var $372=(($365+7456)|0);
   var $373=(($params+60)|0);
   HEAP32[(($373)>>2)]=$372;
   var $374=(($365+7712)|0);
   var $375=(($params+56)|0);
   HEAP32[(($375)>>2)]=$374;
   var $376=(($365+8224)|0);
   var $377=(($params+68)|0);
   HEAP32[(($377)>>2)]=$376;
   var $378=(($365+9248)|0);
   var $379=HEAP32[(($378)>>2)];
   var $380=(($params+72)|0);
   HEAP32[(($380)>>2)]=$379;
   var $381=HEAPF32[((104)>>2)];
   var $382=(($params+116)|0);
   HEAPF32[(($382)>>2)]=$381;
   var $383=HEAPF32[((80)>>2)];
   var $384=(($params+120)|0);
   HEAPF32[(($384)>>2)]=$383;
   var $385=HEAPF32[((96)>>2)];
   var $386=(($params+124)|0);
   HEAPF32[(($386)>>2)]=$385;
   var $387=(($params+92)|0);
   var $388=(($303+36)|0);
   var $389=HEAPF32[(($388)>>2)];
   HEAPF32[(($387)>>2)]=$389;
   var $390=(($303+40)|0);
   var $391=HEAPF32[(($390)>>2)];
   var $392=(($params+96)|0);
   HEAPF32[(($392)>>2)]=$391;
   var $393=(($303+44)|0);
   var $394=HEAPF32[(($393)>>2)];
   var $395=(($params+100)|0);
   HEAPF32[(($395)>>2)]=$394;
   var $396=(($params+104)|0);
   var $397=(($303+48)|0);
   var $398=HEAPF32[(($397)>>2)];
   HEAPF32[(($396)>>2)]=$398;
   var $399=(($303+52)|0);
   var $400=HEAPF32[(($399)>>2)];
   var $401=(($params+108)|0);
   HEAPF32[(($401)>>2)]=$400;
   var $402=(($303+56)|0);
   var $403=HEAPF32[(($402)>>2)];
   var $404=(($params+112)|0);
   HEAPF32[(($404)>>2)]=$403;
   var $405=HEAPF32[((((7664)|0))>>2)];
   var $406=(($params+128)|0);
   HEAPF32[(($406)>>2)]=$405;
   var $407=HEAPF32[((((7668)|0))>>2)];
   var $408=(($params+132)|0);
   HEAPF32[(($408)>>2)]=$407;
   var $409=(($params+136)|0);
   HEAP8[($409)]=1;
   var $410=$1;
   assert(140 % 1 === 0);(_memcpy($410, $330, 140)|0);
   var $411=_printf(((1344)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 144)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),(_memcpy(tempVarArgs, $1, 140)|0),tempVarArgs)); STACKTOP=tempVarArgs;
   var $412=__Z19dtCreateNavMeshDataP21dtNavMeshCreateParamsPPhPi($params, $navData, $navDataSize);
   if ($412) { label = 88; break; } else { label = 87; break; }
  case 87: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1256)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 88: 
   var $415=HEAP32[(($navData)>>2)];
   var $416=_printf(((1120)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$415,tempVarArgs)); STACKTOP=tempVarArgs;
   var $417=_malloc(84);
   var $418=(($417)|(0))==0;
   if ($418) { label = 89; break; } else { label = 92; break; }
  case 89: 
   HEAP32[((7608)>>2)]=0;
   var $420=(($415)|(0))==0;
   if ($420) { label = 91; break; } else { label = 90; break; }
  case 90: 
   _free($415);
   label = 91; break;
  case 91: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1088)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 92: 
   var $423=$417;
   _memset($417, 0, 84);
   HEAP32[((7608)>>2)]=$423;
   var $424=(($417)|(0))==0;
   var $425=_printf(((1056)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$417,tempVarArgs)); STACKTOP=tempVarArgs;
   var $426=HEAP32[((7608)>>2)];
   var $427=HEAP32[(($navDataSize)>>2)];
   var $428=__ZN9dtNavMesh4initEPhii($426, $415, $427);
   var $429=(($428)|(0)) < 0;
   if ($429) { label = 93; break; } else { label = 96; break; }
  case 93: 
   var $431=(($415)|(0))==0;
   if ($431) { label = 95; break; } else { label = 94; break; }
  case 94: 
   _free($415);
   label = 95; break;
  case 95: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((1008)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 96: 
   var $434=_printf(((976)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$415,tempVarArgs)); STACKTOP=tempVarArgs;
   var $435=HEAP32[((7608)>>2)];
   var $436=__ZN14dtNavMeshQuery4initEPK9dtNavMeshi(0, $435);
   var $437=(($436)|(0)) < 0;
   if ($437) { label = 97; break; } else { label = 98; break; }
  case 97: 
   __ZN9rcContext3logE13rcLogCategoryPKcz(0, 3, ((936)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 1)|0,STACKTOP = ((((STACKTOP)+7)>>3)<<3),(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=0,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 0;label = 99; break;
  case 98: 
   var $440=HEAP32[((7608)>>2)];
   var $441=_printf(((920)|0), (tempVarArgs=STACKTOP,STACKTOP = (STACKTOP + 8)|0,(assert((STACKTOP|0) < (STACK_MAX|0))|0),HEAP32[((tempVarArgs)>>2)]=$440,tempVarArgs)); STACKTOP=tempVarArgs;
   var $_0 = 1;label = 99; break;
  case 99: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10__cxxabiv116__shim_type_infoD2Ev($this) {
 var label = 0;
 return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop1Ev($this) {
 var label = 0;
 return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop2Ev($this) {
 var label = 0;
 return;
}
function __ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv($this, $thrown_type, $0) {
 var label = 0;
 var $2=(($this)|0);
 var $3=(($thrown_type)|0);
 var $4=(($2)|(0))==(($3)|(0));
 return $4;
}
function __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this, $info, $adjustedPtr, $path_below) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($info+8)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0))==(($this)|(0));
   if ($3) { label = 2; break; } else { label = 8; break; }
  case 2: 
   var $5=(($info+16)|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=(($6)|(0))==0;
   if ($7) { label = 3; break; } else { label = 4; break; }
  case 3: 
   HEAP32[(($5)>>2)]=$adjustedPtr;
   var $9=(($info+24)|0);
   HEAP32[(($9)>>2)]=$path_below;
   var $10=(($info+36)|0);
   HEAP32[(($10)>>2)]=1;
   label = 8; break;
  case 4: 
   var $12=(($6)|(0))==(($adjustedPtr)|(0));
   if ($12) { label = 5; break; } else { label = 7; break; }
  case 5: 
   var $14=(($info+24)|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=(($15)|(0))==2;
   if ($16) { label = 6; break; } else { label = 8; break; }
  case 6: 
   HEAP32[(($14)>>2)]=$path_below;
   label = 8; break;
  case 7: 
   var $19=(($info+36)|0);
   var $20=HEAP32[(($19)>>2)];
   var $21=((($20)+(1))|0);
   HEAP32[(($19)>>2)]=$21;
   var $22=(($info+24)|0);
   HEAP32[(($22)>>2)]=2;
   var $23=(($info+54)|0);
   HEAP8[($23)]=1;
   label = 8; break;
  case 8: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __GLOBAL__I_a596() {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 312)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 var $args_i21_i_i=sp;
 var $args_i20_i_i=(sp)+(8);
 var $args_i19_i_i=(sp)+(24);
 var $args_i18_i_i=(sp)+(40);
 var $args_i17_i_i=(sp)+(56);
 var $args_i16_i_i=(sp)+(72);
 var $args_i15_i_i=(sp)+(88);
 var $args_i14_i_i=(sp)+(104);
 var $args_i13_i_i=(sp)+(120);
 var $args_i12_i_i=(sp)+(136);
 var $args_i11_i_i=(sp)+(152);
 var $args_i10_i_i=(sp)+(168);
 var $args_i9_i_i=(sp)+(184);
 var $args_i8_i_i=(sp)+(200);
 var $args_i7_i_i=(sp)+(216);
 var $args_i6_i_i=(sp)+(224);
 var $args_i5_i_i=(sp)+(232);
 var $args_i4_i_i=(sp)+(256);
 var $args_i3_i_i=(sp)+(280);
 var $args_i2_i_i=(sp)+(288);
 var $args_i1_i_i=(sp)+(296);
 var $args_i_i_i=(sp)+(304);
 var $1=$args_i_i_i;
 var $2=(($args_i_i_i)|0);
 HEAP32[(($2)>>2)]=1;
 var $3=(($args_i_i_i+4)|0);
 HEAP32[(($3)>>2)]=7360;
 __embind_register_function(((912)|0), 1, $3, (78), (28));
 var $4=$args_i1_i_i;
 var $5=(($args_i1_i_i)|0);
 HEAP32[(($5)>>2)]=1;
 var $6=(($args_i1_i_i+4)|0);
 HEAP32[(($6)>>2)]=7360;
 __embind_register_function(((896)|0), 1, $6, (78), (90));
 var $7=$args_i2_i_i;
 var $8=(($args_i2_i_i)|0);
 HEAP32[(($8)>>2)]=1;
 var $9=(($args_i2_i_i+4)|0);
 HEAP32[(($9)>>2)]=7360;
 __embind_register_function(((888)|0), 1, $9, (78), (44));
 var $10=$args_i3_i_i;
 var $11=(($args_i3_i_i)|0);
 HEAP32[(($11)>>2)]=1;
 var $12=(($args_i3_i_i+4)|0);
 HEAP32[(($12)>>2)]=7352;
 __embind_register_function(((816)|0), 1, $12, (50), 26);
 var $13=$args_i4_i_i;
 var $14=(($args_i4_i_i)|0);
 HEAP32[(($14)>>2)]=5;
 var $15=(($args_i4_i_i+4)|0);
 HEAP32[(($15)>>2)]=7352;
 var $16=(($args_i4_i_i+8)|0);
 HEAP32[(($16)>>2)]=__ZTIf;
 var $17=(($args_i4_i_i+12)|0);
 HEAP32[(($17)>>2)]=__ZTIf;
 var $18=(($args_i4_i_i+16)|0);
 HEAP32[(($18)>>2)]=__ZTIf;
 var $19=(($args_i4_i_i+20)|0);
 HEAP32[(($19)>>2)]=__ZTIi;
 __embind_register_function(((696)|0), 5, $15, (92), (72));
 var $20=$args_i5_i_i;
 var $21=(($args_i5_i_i)|0);
 HEAP32[(($21)>>2)]=5;
 var $22=(($args_i5_i_i+4)|0);
 HEAP32[(($22)>>2)]=7352;
 var $23=(($args_i5_i_i+8)|0);
 HEAP32[(($23)>>2)]=__ZTIi;
 var $24=(($args_i5_i_i+12)|0);
 HEAP32[(($24)>>2)]=__ZTIi;
 var $25=(($args_i5_i_i+16)|0);
 HEAP32[(($25)>>2)]=__ZTIi;
 var $26=(($args_i5_i_i+20)|0);
 HEAP32[(($26)>>2)]=__ZTIi;
 __embind_register_function(((672)|0), 5, $22, (106), (4));
 var $27=$args_i6_i_i;
 var $28=(($args_i6_i_i)|0);
 HEAP32[(($28)>>2)]=1;
 var $29=(($args_i6_i_i+4)|0);
 HEAP32[(($29)>>2)]=7352;
 __embind_register_function(((648)|0), 1, $29, (50), 82);
 var $30=$args_i7_i_i;
 var $31=(($args_i7_i_i)|0);
 HEAP32[(($31)>>2)]=1;
 var $32=(($args_i7_i_i+4)|0);
 HEAP32[(($32)>>2)]=7352;
 __embind_register_function(((616)|0), 1, $32, (50), 80);
 var $33=$args_i8_i_i;
 var $34=(($args_i8_i_i)|0);
 HEAP32[(($34)>>2)]=2;
 var $35=(($args_i8_i_i+4)|0);
 HEAP32[(($35)>>2)]=7352;
 var $36=(($args_i8_i_i+8)|0);
 HEAP32[(($36)>>2)]=__ZTIf;
 __embind_register_function(((600)|0), 2, $35, (24), (12));
 var $37=$args_i9_i_i;
 var $38=(($args_i9_i_i)|0);
 HEAP32[(($38)>>2)]=2;
 var $39=(($args_i9_i_i+4)|0);
 HEAP32[(($39)>>2)]=7352;
 var $40=(($args_i9_i_i+8)|0);
 HEAP32[(($40)>>2)]=__ZTIf;
 __embind_register_function(((576)|0), 2, $39, (24), (76));
 var $41=$args_i10_i_i;
 var $42=(($args_i10_i_i)|0);
 HEAP32[(($42)>>2)]=2;
 var $43=(($args_i10_i_i+4)|0);
 HEAP32[(($43)>>2)]=7352;
 var $44=(($args_i10_i_i+8)|0);
 HEAP32[(($44)>>2)]=__ZTIf;
 __embind_register_function(((560)|0), 2, $43, (24), (2));
 var $45=$args_i11_i_i;
 var $46=(($args_i11_i_i)|0);
 HEAP32[(($46)>>2)]=2;
 var $47=(($args_i11_i_i+4)|0);
 HEAP32[(($47)>>2)]=7352;
 var $48=(($args_i11_i_i+8)|0);
 HEAP32[(($48)>>2)]=__ZTIf;
 __embind_register_function(((544)|0), 2, $47, (24), (22));
 var $49=$args_i12_i_i;
 var $50=(($args_i12_i_i)|0);
 HEAP32[(($50)>>2)]=2;
 var $51=(($args_i12_i_i+4)|0);
 HEAP32[(($51)>>2)]=7352;
 var $52=(($args_i12_i_i+8)|0);
 HEAP32[(($52)>>2)]=__ZTIf;
 __embind_register_function(((520)|0), 2, $51, (24), (98));
 var $53=$args_i13_i_i;
 var $54=(($args_i13_i_i)|0);
 HEAP32[(($54)>>2)]=2;
 var $55=(($args_i13_i_i+4)|0);
 HEAP32[(($55)>>2)]=7352;
 var $56=(($args_i13_i_i+8)|0);
 HEAP32[(($56)>>2)]=__ZTIf;
 __embind_register_function(((448)|0), 2, $55, (24), (62));
 var $57=$args_i14_i_i;
 var $58=(($args_i14_i_i)|0);
 HEAP32[(($58)>>2)]=2;
 var $59=(($args_i14_i_i+4)|0);
 HEAP32[(($59)>>2)]=7352;
 var $60=(($args_i14_i_i+8)|0);
 HEAP32[(($60)>>2)]=__ZTIf;
 __embind_register_function(((424)|0), 2, $59, (24), (8));
 var $61=$args_i15_i_i;
 var $62=(($args_i15_i_i)|0);
 HEAP32[(($62)>>2)]=2;
 var $63=(($args_i15_i_i+4)|0);
 HEAP32[(($63)>>2)]=7352;
 var $64=(($args_i15_i_i+8)|0);
 HEAP32[(($64)>>2)]=__ZTIf;
 __embind_register_function(((400)|0), 2, $63, (24), (60));
 var $65=$args_i16_i_i;
 var $66=(($args_i16_i_i)|0);
 HEAP32[(($66)>>2)]=2;
 var $67=(($args_i16_i_i+4)|0);
 HEAP32[(($67)>>2)]=7352;
 var $68=(($args_i16_i_i+8)|0);
 HEAP32[(($68)>>2)]=__ZTIf;
 __embind_register_function(((384)|0), 2, $67, (24), (34));
 var $69=$args_i17_i_i;
 var $70=(($args_i17_i_i)|0);
 HEAP32[(($70)>>2)]=2;
 var $71=(($args_i17_i_i+4)|0);
 HEAP32[(($71)>>2)]=7352;
 var $72=(($args_i17_i_i+8)|0);
 HEAP32[(($72)>>2)]=__ZTIf;
 __embind_register_function(((344)|0), 2, $71, (24), (66));
 var $73=$args_i18_i_i;
 var $74=(($args_i18_i_i)|0);
 HEAP32[(($74)>>2)]=2;
 var $75=(($args_i18_i_i+4)|0);
 HEAP32[(($75)>>2)]=7352;
 var $76=(($args_i18_i_i+8)|0);
 HEAP32[(($76)>>2)]=__ZTIf;
 __embind_register_function(((320)|0), 2, $75, (24), (104));
 var $77=$args_i19_i_i;
 var $78=(($args_i19_i_i)|0);
 HEAP32[(($78)>>2)]=2;
 var $79=(($args_i19_i_i+4)|0);
 HEAP32[(($79)>>2)]=7352;
 var $80=(($args_i19_i_i+8)|0);
 HEAP32[(($80)>>2)]=__ZTIf;
 __embind_register_function(((296)|0), 2, $79, (24), (102));
 var $81=$args_i20_i_i;
 var $82=(($args_i20_i_i)|0);
 HEAP32[(($82)>>2)]=2;
 var $83=(($args_i20_i_i+4)|0);
 HEAP32[(($83)>>2)]=7352;
 var $84=(($args_i20_i_i+8)|0);
 HEAP32[(($84)>>2)]=__ZTIf;
 __embind_register_function(((264)|0), 2, $83, (24), (88));
 var $85=$args_i21_i_i;
 var $86=(($args_i21_i_i)|0);
 HEAP32[(($86)>>2)]=1;
 var $87=(($args_i21_i_i+4)|0);
 HEAP32[(($87)>>2)]=__ZTIi;
 __embind_register_function(((248)|0), 1, $87, (96), (64));
 STACKTOP = sp;
 return;
}
function ___getTypeName($ti) {
 var label = 0;
 var $1=(($ti+4)|0);
 var $2=HEAP32[(($1)>>2)];
 var $3=_strdup($2);
 return $3;
}
function __GLOBAL__I_a616() {
 var label = 0;
 __embind_register_void(7352, ((1392)|0));
 __embind_register_bool(7360, ((5400)|0), 1, 0);
 __embind_register_integer(__ZTIc, ((4200)|0), -128, 127);
 __embind_register_integer(__ZTIa, ((3368)|0), -128, 127);
 __embind_register_integer(__ZTIh, ((2360)|0), 0, 255);
 __embind_register_integer(__ZTIs, ((1560)|0), -32768, 32767);
 __embind_register_integer(__ZTIt, ((1040)|0), 0, 65535);
 __embind_register_integer(__ZTIi, ((640)|0), -2147483648, 2147483647);
 __embind_register_integer(__ZTIj, ((368)|0), 0, -1);
 __embind_register_integer(__ZTIl, ((120)|0), -2147483648, 2147483647);
 __embind_register_integer(__ZTIm, ((6272)|0), 0, -1);
 __embind_register_float(__ZTIf, ((6160)|0));
 __embind_register_float(__ZTId, ((5944)|0));
 __embind_register_std_string(7432, ((5616)|0));
 __embind_register_std_wstring(7408, 4, ((5504)|0));
 __embind_register_emval(7456, ((5408)|0));
 __embind_register_memory_view(7464, ((5280)|0));
 return;
}
function __ZN10__cxxabiv123__fundamental_type_infoD0Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|(0))==0;
   if ($1) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $3=$this;
   _free($3);
   label = 3; break;
  case 3: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10__cxxabiv117__class_type_infoD0Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|(0))==0;
   if ($1) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $3=$this;
   _free($3);
   label = 3; break;
  case 3: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10__cxxabiv120__si_class_type_infoD0Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|(0))==0;
   if ($1) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $3=$this;
   _free($3);
   label = 3; break;
  case 3: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZN10__cxxabiv121__vmi_class_type_infoD0Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|(0))==0;
   if ($1) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $3=$this;
   _free($3);
   label = 3; break;
  case 3: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv($this, $thrown_type, $adjustedPtr) {
 var label = 0;
 var sp  = STACKTOP; STACKTOP = (STACKTOP + 112)|0; (assert((STACKTOP|0) < (STACK_MAX|0))|0);
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $info_i=sp;
   var $info=(sp)+(56);
   var $1=(($this)|0);
   var $2=(($thrown_type)|0);
   var $3=(($1)|(0))==(($2)|(0));
   if ($3) { var $_0 = 1;label = 17; break; } else { label = 2; break; }
  case 2: 
   var $5=(($thrown_type)|(0))==0;
   if ($5) { var $_0 = 0;label = 17; break; } else { label = 3; break; }
  case 3: 
   var $7=$thrown_type;
   var $8=$info_i;
   var $9=$thrown_type;
   var $10=HEAP32[(($9)>>2)];
   var $11=((($10)-(8))|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=$12;
   var $14=(($7+$13)|0);
   var $15=((($10)-(4))|0);
   var $16=HEAP32[(($15)>>2)];
   var $17=$16;
   var $18=(($info_i)|0);
   HEAP32[(($18)>>2)]=7520;
   var $19=(($info_i+4)|0);
   HEAP32[(($19)>>2)]=$7;
   var $20=(($info_i+8)|0);
   HEAP32[(($20)>>2)]=7536;
   var $21=(($info_i+12)|0);
   HEAP32[(($21)>>2)]=-1;
   var $22=(($info_i+16)|0);
   var $23=(($info_i+20)|0);
   var $24=(($info_i+24)|0);
   var $25=(($info_i+28)|0);
   var $26=(($info_i+32)|0);
   var $27=(($info_i+40)|0);
   var $28=(($16)|(0))==7520;
   var $29=$22;
   _memset($29, 0, 39);
   if ($28) { label = 4; break; } else { label = 5; break; }
  case 4: 
   var $31=(($info_i+48)|0);
   HEAP32[(($31)>>2)]=1;
   var $32=HEAP32[((7520)>>2)];
   var $33=(($32+20)|0);
   var $34=HEAP32[(($33)>>2)];
   FUNCTION_TABLE[$34]($17, $info_i, $14, $14, 1, 0);
   var $35=HEAP32[(($24)>>2)];
   var $36=(($35)|(0))==1;
   var $__i=$36 ? $14 : 0;
   var $68 = $__i;label = 14; break;
  case 5: 
   var $38=(($info_i+36)|0);
   var $39=$16;
   var $40=HEAP32[(($39)>>2)];
   var $41=(($40+24)|0);
   var $42=HEAP32[(($41)>>2)];
   FUNCTION_TABLE[$42]($17, $info_i, $14, 1, 0);
   var $43=HEAP32[(($38)>>2)];
   if ((($43)|(0))==0) {
    label = 6; break;
   }
   else if ((($43)|(0))==1) {
    label = 9; break;
   }
   else {
   var $68 = 0;label = 14; break;
   }
  case 6: 
   var $45=HEAP32[(($27)>>2)];
   var $46=(($45)|(0))==1;
   if ($46) { label = 7; break; } else { var $68 = 0;label = 14; break; }
  case 7: 
   var $48=HEAP32[(($25)>>2)];
   var $49=(($48)|(0))==1;
   if ($49) { label = 8; break; } else { var $68 = 0;label = 14; break; }
  case 8: 
   var $51=HEAP32[(($26)>>2)];
   var $52=(($51)|(0))==1;
   var $53=HEAP32[(($23)>>2)];
   var $_13_i=$52 ? $53 : 0;
   var $68 = $_13_i;label = 14; break;
  case 9: 
   var $55=HEAP32[(($24)>>2)];
   var $56=(($55)|(0))==1;
   if ($56) { label = 13; break; } else { label = 10; break; }
  case 10: 
   var $58=HEAP32[(($27)>>2)];
   var $59=(($58)|(0))==0;
   if ($59) { label = 11; break; } else { var $68 = 0;label = 14; break; }
  case 11: 
   var $61=HEAP32[(($25)>>2)];
   var $62=(($61)|(0))==1;
   if ($62) { label = 12; break; } else { var $68 = 0;label = 14; break; }
  case 12: 
   var $64=HEAP32[(($26)>>2)];
   var $65=(($64)|(0))==1;
   if ($65) { label = 13; break; } else { var $68 = 0;label = 14; break; }
  case 13: 
   var $67=HEAP32[(($22)>>2)];
   var $68 = $67;label = 14; break;
  case 14: 
   var $68;
   var $69=$68;
   var $70=(($68)|(0))==0;
   if ($70) { var $_0 = 0;label = 17; break; } else { label = 15; break; }
  case 15: 
   var $72=$info;
   _memset($72, 0, 56);
   var $73=(($info)|0);
   HEAP32[(($73)>>2)]=$69;
   var $74=(($info+8)|0);
   HEAP32[(($74)>>2)]=$this;
   var $75=(($info+12)|0);
   HEAP32[(($75)>>2)]=-1;
   var $76=(($info+48)|0);
   HEAP32[(($76)>>2)]=1;
   var $77=$68;
   var $78=HEAP32[(($77)>>2)];
   var $79=(($78+28)|0);
   var $80=HEAP32[(($79)>>2)];
   var $81=HEAP32[(($adjustedPtr)>>2)];
   FUNCTION_TABLE[$80]($69, $info, $81, 1);
   var $82=(($info+24)|0);
   var $83=HEAP32[(($82)>>2)];
   var $84=(($83)|(0))==1;
   if ($84) { label = 16; break; } else { var $_0 = 0;label = 17; break; }
  case 16: 
   var $86=(($info+16)|0);
   var $87=HEAP32[(($86)>>2)];
   HEAP32[(($adjustedPtr)>>2)]=$87;
   var $_0 = 1;label = 17; break;
  case 17: 
   var $_0;
   STACKTOP = sp;
   return $_0;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this, $info, $adjustedPtr, $path_below) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 8; break; }
  case 2: 
   var $7=(($info+16)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==0;
   if ($9) { label = 3; break; } else { label = 4; break; }
  case 3: 
   HEAP32[(($7)>>2)]=$adjustedPtr;
   var $11=(($info+24)|0);
   HEAP32[(($11)>>2)]=$path_below;
   var $12=(($info+36)|0);
   HEAP32[(($12)>>2)]=1;
   label = 9; break;
  case 4: 
   var $14=(($8)|(0))==(($adjustedPtr)|(0));
   if ($14) { label = 5; break; } else { label = 7; break; }
  case 5: 
   var $16=(($info+24)|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=(($17)|(0))==2;
   if ($18) { label = 6; break; } else { label = 9; break; }
  case 6: 
   HEAP32[(($16)>>2)]=$path_below;
   label = 9; break;
  case 7: 
   var $21=(($info+36)|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=((($22)+(1))|0);
   HEAP32[(($21)>>2)]=$23;
   var $24=(($info+24)|0);
   HEAP32[(($24)>>2)]=2;
   var $25=(($info+54)|0);
   HEAP8[($25)]=1;
   label = 9; break;
  case 8: 
   var $27=(($this+8)|0);
   var $28=HEAP32[(($27)>>2)];
   var $29=$28;
   var $30=HEAP32[(($29)>>2)];
   var $31=(($30+28)|0);
   var $32=HEAP32[(($31)>>2)];
   FUNCTION_TABLE[$32]($28, $info, $adjustedPtr, $path_below);
   label = 9; break;
  case 9: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this, $info, $adjustedPtr, $path_below) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 8; break; }
  case 2: 
   var $7=(($info+16)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==0;
   if ($9) { label = 3; break; } else { label = 4; break; }
  case 3: 
   HEAP32[(($7)>>2)]=$adjustedPtr;
   var $11=(($info+24)|0);
   HEAP32[(($11)>>2)]=$path_below;
   var $12=(($info+36)|0);
   HEAP32[(($12)>>2)]=1;
   label = 16; break;
  case 4: 
   var $14=(($8)|(0))==(($adjustedPtr)|(0));
   if ($14) { label = 5; break; } else { label = 7; break; }
  case 5: 
   var $16=(($info+24)|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=(($17)|(0))==2;
   if ($18) { label = 6; break; } else { label = 16; break; }
  case 6: 
   HEAP32[(($16)>>2)]=$path_below;
   label = 16; break;
  case 7: 
   var $21=(($info+36)|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=((($22)+(1))|0);
   HEAP32[(($21)>>2)]=$23;
   var $24=(($info+24)|0);
   HEAP32[(($24)>>2)]=2;
   var $25=(($info+54)|0);
   HEAP8[($25)]=1;
   label = 16; break;
  case 8: 
   var $27=(($this+12)|0);
   var $28=HEAP32[(($27)>>2)];
   var $29=(($this+16+($28<<3))|0);
   var $30=(($this+20)|0);
   var $31=HEAP32[(($30)>>2)];
   var $32=$31 >> 8;
   var $33=$31 & 1;
   var $34=(($33)|(0))==0;
   if ($34) { var $offset_to_base_0_i16 = $32;label = 10; break; } else { label = 9; break; }
  case 9: 
   var $36=$adjustedPtr;
   var $37=HEAP32[(($36)>>2)];
   var $38=(($37+$32)|0);
   var $39=$38;
   var $40=HEAP32[(($39)>>2)];
   var $offset_to_base_0_i16 = $40;label = 10; break;
  case 10: 
   var $offset_to_base_0_i16;
   var $41=(($this+16)|0);
   var $42=HEAP32[(($41)>>2)];
   var $43=$42;
   var $44=HEAP32[(($43)>>2)];
   var $45=(($44+28)|0);
   var $46=HEAP32[(($45)>>2)];
   var $47=(($adjustedPtr+$offset_to_base_0_i16)|0);
   var $48=$31 & 2;
   var $49=(($48)|(0))!=0;
   var $50=$49 ? $path_below : 2;
   FUNCTION_TABLE[$46]($42, $info, $47, $50);
   var $51=(($28)|(0)) > 1;
   if ($51) { label = 11; break; } else { label = 16; break; }
  case 11: 
   var $52=(($this+24)|0);
   var $53=(($info+54)|0);
   var $54=$adjustedPtr;
   var $p_0 = $52;label = 12; break;
  case 12: 
   var $p_0;
   var $56=(($p_0+4)|0);
   var $57=HEAP32[(($56)>>2)];
   var $58=$57 >> 8;
   var $59=$57 & 1;
   var $60=(($59)|(0))==0;
   if ($60) { var $offset_to_base_0_i = $58;label = 14; break; } else { label = 13; break; }
  case 13: 
   var $62=HEAP32[(($54)>>2)];
   var $63=(($62+$58)|0);
   var $64=$63;
   var $65=HEAP32[(($64)>>2)];
   var $offset_to_base_0_i = $65;label = 14; break;
  case 14: 
   var $offset_to_base_0_i;
   var $66=(($p_0)|0);
   var $67=HEAP32[(($66)>>2)];
   var $68=$67;
   var $69=HEAP32[(($68)>>2)];
   var $70=(($69+28)|0);
   var $71=HEAP32[(($70)>>2)];
   var $72=(($adjustedPtr+$offset_to_base_0_i)|0);
   var $73=$57 & 2;
   var $74=(($73)|(0))!=0;
   var $75=$74 ? $path_below : 2;
   FUNCTION_TABLE[$71]($67, $info, $72, $75);
   var $76=HEAP8[($53)];
   var $77=$76 & 1;
   var $78=(($77 << 24) >> 24)==0;
   if ($78) { label = 15; break; } else { label = 16; break; }
  case 15: 
   var $80=(($p_0+8)|0);
   var $81=(($80)>>>(0)) < (($29)>>>(0));
   if ($81) { var $p_0 = $80;label = 12; break; } else { label = 16; break; }
  case 16: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this, $info, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($info+8)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0))==(($this)|(0));
   if ($3) { label = 2; break; } else { label = 5; break; }
  case 2: 
   var $5=(($info+4)|0);
   var $6=HEAP32[(($5)>>2)];
   var $7=(($6)|(0))==(($current_ptr)|(0));
   if ($7) { label = 3; break; } else { label = 14; break; }
  case 3: 
   var $9=(($info+28)|0);
   var $10=HEAP32[(($9)>>2)];
   var $11=(($10)|(0))==1;
   if ($11) { label = 14; break; } else { label = 4; break; }
  case 4: 
   HEAP32[(($9)>>2)]=$path_below;
   label = 14; break;
  case 5: 
   var $14=(($info)|0);
   var $15=HEAP32[(($14)>>2)];
   var $16=(($15)|(0))==(($this)|(0));
   if ($16) { label = 6; break; } else { label = 14; break; }
  case 6: 
   var $18=(($info+16)|0);
   var $19=HEAP32[(($18)>>2)];
   var $20=(($19)|(0))==(($current_ptr)|(0));
   if ($20) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $22=(($info+20)|0);
   var $23=HEAP32[(($22)>>2)];
   var $24=(($23)|(0))==(($current_ptr)|(0));
   if ($24) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $26=(($path_below)|(0))==1;
   if ($26) { label = 9; break; } else { label = 14; break; }
  case 9: 
   var $28=(($info+32)|0);
   HEAP32[(($28)>>2)]=1;
   label = 14; break;
  case 10: 
   var $30=(($info+32)|0);
   HEAP32[(($30)>>2)]=$path_below;
   HEAP32[(($22)>>2)]=$current_ptr;
   var $31=(($info+40)|0);
   var $32=HEAP32[(($31)>>2)];
   var $33=((($32)+(1))|0);
   HEAP32[(($31)>>2)]=$33;
   var $34=(($info+36)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==1;
   if ($36) { label = 11; break; } else { label = 13; break; }
  case 11: 
   var $38=(($info+24)|0);
   var $39=HEAP32[(($38)>>2)];
   var $40=(($39)|(0))==2;
   if ($40) { label = 12; break; } else { label = 13; break; }
  case 12: 
   var $42=(($info+54)|0);
   HEAP8[($42)]=1;
   label = 13; break;
  case 13: 
   var $44=(($info+44)|0);
   HEAP32[(($44)>>2)]=4;
   label = 14; break;
  case 14: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this, $info, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 5; break; }
  case 2: 
   var $7=(($info+4)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==(($current_ptr)|(0));
   if ($9) { label = 3; break; } else { label = 53; break; }
  case 3: 
   var $11=(($info+28)|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=(($12)|(0))==1;
   if ($13) { label = 53; break; } else { label = 4; break; }
  case 4: 
   HEAP32[(($11)>>2)]=$path_below;
   label = 53; break;
  case 5: 
   var $16=(($info)|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=(($17)|0);
   var $19=(($1)|(0))==(($18)|(0));
   if ($19) { label = 6; break; } else { label = 29; break; }
  case 6: 
   var $21=(($info+16)|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=(($22)|(0))==(($current_ptr)|(0));
   if ($23) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $25=(($info+20)|0);
   var $26=HEAP32[(($25)>>2)];
   var $27=(($26)|(0))==(($current_ptr)|(0));
   if ($27) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $29=(($path_below)|(0))==1;
   if ($29) { label = 9; break; } else { label = 53; break; }
  case 9: 
   var $31=(($info+32)|0);
   HEAP32[(($31)>>2)]=1;
   label = 53; break;
  case 10: 
   var $33=(($info+32)|0);
   HEAP32[(($33)>>2)]=$path_below;
   var $34=(($info+44)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==4;
   if ($36) { label = 53; break; } else { label = 11; break; }
  case 11: 
   var $38=(($this+12)|0);
   var $39=HEAP32[(($38)>>2)];
   var $40=(($this+16+($39<<3))|0);
   var $41=(($39)|(0)) > 0;
   if ($41) { label = 12; break; } else { var $is_dst_type_derived_from_static_type_2_off098 = 0;label = 23; break; }
  case 12: 
   var $42=(($this+16)|0);
   var $43=(($info+52)|0);
   var $44=(($info+53)|0);
   var $45=(($info+54)|0);
   var $46=(($this+8)|0);
   var $47=(($info+24)|0);
   var $48=$current_ptr;
   var $does_dst_type_point_to_our_static_type_0_off087 = 0;var $p_088 = $42;var $is_dst_type_derived_from_static_type_0_off089 = 0;label = 13; break;
  case 13: 
   var $is_dst_type_derived_from_static_type_0_off089;
   var $p_088;
   var $does_dst_type_point_to_our_static_type_0_off087;
   HEAP8[($43)]=0;
   HEAP8[($44)]=0;
   var $50=(($p_088+4)|0);
   var $51=HEAP32[(($50)>>2)];
   var $52=$51 >> 8;
   var $53=$51 & 1;
   var $54=(($53)|(0))==0;
   if ($54) { var $offset_to_base_0_i81 = $52;label = 15; break; } else { label = 14; break; }
  case 14: 
   var $56=HEAP32[(($48)>>2)];
   var $57=(($56+$52)|0);
   var $58=$57;
   var $59=HEAP32[(($58)>>2)];
   var $offset_to_base_0_i81 = $59;label = 15; break;
  case 15: 
   var $offset_to_base_0_i81;
   var $60=(($p_088)|0);
   var $61=HEAP32[(($60)>>2)];
   var $62=$61;
   var $63=HEAP32[(($62)>>2)];
   var $64=(($63+20)|0);
   var $65=HEAP32[(($64)>>2)];
   var $66=(($current_ptr+$offset_to_base_0_i81)|0);
   var $67=$51 >>> 1;
   var $68=$67 & 1;
   var $69=(((2)-($68))|0);
   FUNCTION_TABLE[$65]($61, $info, $current_ptr, $66, $69, $use_strcmp);
   var $70=HEAP8[($45)];
   var $71=$70 & 1;
   var $72=(($71 << 24) >> 24)==0;
   if ($72) { label = 16; break; } else { var $is_dst_type_derived_from_static_type_2_off0 = $is_dst_type_derived_from_static_type_0_off089;var $does_dst_type_point_to_our_static_type_0_off0_lcssa = $does_dst_type_point_to_our_static_type_0_off087;label = 22; break; }
  case 16: 
   var $74=HEAP8[($44)];
   var $75=$74 & 1;
   var $76=(($75 << 24) >> 24)==0;
   if ($76) { var $is_dst_type_derived_from_static_type_1_off0 = $is_dst_type_derived_from_static_type_0_off089;var $does_dst_type_point_to_our_static_type_1_off0 = $does_dst_type_point_to_our_static_type_0_off087;label = 21; break; } else { label = 17; break; }
  case 17: 
   var $78=HEAP8[($43)];
   var $79=$78 & 1;
   var $80=(($79 << 24) >> 24)==0;
   if ($80) { label = 20; break; } else { label = 18; break; }
  case 18: 
   var $82=HEAP32[(($47)>>2)];
   var $83=(($82)|(0))==1;
   if ($83) { label = 27; break; } else { label = 19; break; }
  case 19: 
   var $85=HEAP32[(($46)>>2)];
   var $86=$85 & 2;
   var $87=(($86)|(0))==0;
   if ($87) { label = 27; break; } else { var $is_dst_type_derived_from_static_type_1_off0 = 1;var $does_dst_type_point_to_our_static_type_1_off0 = 1;label = 21; break; }
  case 20: 
   var $89=HEAP32[(($46)>>2)];
   var $90=$89 & 1;
   var $91=(($90)|(0))==0;
   if ($91) { var $is_dst_type_derived_from_static_type_2_off0 = 1;var $does_dst_type_point_to_our_static_type_0_off0_lcssa = $does_dst_type_point_to_our_static_type_0_off087;label = 22; break; } else { var $is_dst_type_derived_from_static_type_1_off0 = 1;var $does_dst_type_point_to_our_static_type_1_off0 = $does_dst_type_point_to_our_static_type_0_off087;label = 21; break; }
  case 21: 
   var $does_dst_type_point_to_our_static_type_1_off0;
   var $is_dst_type_derived_from_static_type_1_off0;
   var $93=(($p_088+8)|0);
   var $94=(($93)>>>(0)) < (($40)>>>(0));
   if ($94) { var $does_dst_type_point_to_our_static_type_0_off087 = $does_dst_type_point_to_our_static_type_1_off0;var $p_088 = $93;var $is_dst_type_derived_from_static_type_0_off089 = $is_dst_type_derived_from_static_type_1_off0;label = 13; break; } else { var $is_dst_type_derived_from_static_type_2_off0 = $is_dst_type_derived_from_static_type_1_off0;var $does_dst_type_point_to_our_static_type_0_off0_lcssa = $does_dst_type_point_to_our_static_type_1_off0;label = 22; break; }
  case 22: 
   var $does_dst_type_point_to_our_static_type_0_off0_lcssa;
   var $is_dst_type_derived_from_static_type_2_off0;
   if ($does_dst_type_point_to_our_static_type_0_off0_lcssa) { var $is_dst_type_derived_from_static_type_2_off099 = $is_dst_type_derived_from_static_type_2_off0;label = 26; break; } else { var $is_dst_type_derived_from_static_type_2_off098 = $is_dst_type_derived_from_static_type_2_off0;label = 23; break; }
  case 23: 
   var $is_dst_type_derived_from_static_type_2_off098;
   HEAP32[(($25)>>2)]=$current_ptr;
   var $95=(($info+40)|0);
   var $96=HEAP32[(($95)>>2)];
   var $97=((($96)+(1))|0);
   HEAP32[(($95)>>2)]=$97;
   var $98=(($info+36)|0);
   var $99=HEAP32[(($98)>>2)];
   var $100=(($99)|(0))==1;
   if ($100) { label = 24; break; } else { var $is_dst_type_derived_from_static_type_2_off099 = $is_dst_type_derived_from_static_type_2_off098;label = 26; break; }
  case 24: 
   var $102=(($info+24)|0);
   var $103=HEAP32[(($102)>>2)];
   var $104=(($103)|(0))==2;
   if ($104) { label = 25; break; } else { var $is_dst_type_derived_from_static_type_2_off099 = $is_dst_type_derived_from_static_type_2_off098;label = 26; break; }
  case 25: 
   var $106=(($info+54)|0);
   HEAP8[($106)]=1;
   if ($is_dst_type_derived_from_static_type_2_off098) { label = 27; break; } else { label = 28; break; }
  case 26: 
   var $is_dst_type_derived_from_static_type_2_off099;
   if ($is_dst_type_derived_from_static_type_2_off099) { label = 27; break; } else { label = 28; break; }
  case 27: 
   HEAP32[(($34)>>2)]=3;
   label = 53; break;
  case 28: 
   HEAP32[(($34)>>2)]=4;
   label = 53; break;
  case 29: 
   var $110=(($this+12)|0);
   var $111=HEAP32[(($110)>>2)];
   var $112=(($this+16+($111<<3))|0);
   var $113=(($this+20)|0);
   var $114=HEAP32[(($113)>>2)];
   var $115=$114 >> 8;
   var $116=$114 & 1;
   var $117=(($116)|(0))==0;
   if ($117) { var $offset_to_base_0_i82 = $115;label = 31; break; } else { label = 30; break; }
  case 30: 
   var $119=$current_ptr;
   var $120=HEAP32[(($119)>>2)];
   var $121=(($120+$115)|0);
   var $122=$121;
   var $123=HEAP32[(($122)>>2)];
   var $offset_to_base_0_i82 = $123;label = 31; break;
  case 31: 
   var $offset_to_base_0_i82;
   var $124=(($this+16)|0);
   var $125=HEAP32[(($124)>>2)];
   var $126=$125;
   var $127=HEAP32[(($126)>>2)];
   var $128=(($127+24)|0);
   var $129=HEAP32[(($128)>>2)];
   var $130=(($current_ptr+$offset_to_base_0_i82)|0);
   var $131=$114 & 2;
   var $132=(($131)|(0))!=0;
   var $133=$132 ? $path_below : 2;
   FUNCTION_TABLE[$129]($125, $info, $130, $133, $use_strcmp);
   var $134=(($this+24)|0);
   var $135=(($111)|(0)) > 1;
   if ($135) { label = 32; break; } else { label = 53; break; }
  case 32: 
   var $137=(($this+8)|0);
   var $138=HEAP32[(($137)>>2)];
   var $139=$138 & 2;
   var $140=(($139)|(0))==0;
   if ($140) { label = 33; break; } else { label = 34; break; }
  case 33: 
   var $142=(($info+36)|0);
   var $143=HEAP32[(($142)>>2)];
   var $144=(($143)|(0))==1;
   if ($144) { label = 34; break; } else { label = 39; break; }
  case 34: 
   var $145=(($info+54)|0);
   var $146=$current_ptr;
   var $p2_0 = $134;label = 35; break;
  case 35: 
   var $p2_0;
   var $148=HEAP8[($145)];
   var $149=$148 & 1;
   var $150=(($149 << 24) >> 24)==0;
   if ($150) { label = 36; break; } else { label = 53; break; }
  case 36: 
   var $152=(($p2_0+4)|0);
   var $153=HEAP32[(($152)>>2)];
   var $154=$153 >> 8;
   var $155=$153 & 1;
   var $156=(($155)|(0))==0;
   if ($156) { var $offset_to_base_0_i79 = $154;label = 38; break; } else { label = 37; break; }
  case 37: 
   var $158=HEAP32[(($146)>>2)];
   var $159=(($158+$154)|0);
   var $160=$159;
   var $161=HEAP32[(($160)>>2)];
   var $offset_to_base_0_i79 = $161;label = 38; break;
  case 38: 
   var $offset_to_base_0_i79;
   var $162=(($p2_0)|0);
   var $163=HEAP32[(($162)>>2)];
   var $164=$163;
   var $165=HEAP32[(($164)>>2)];
   var $166=(($165+24)|0);
   var $167=HEAP32[(($166)>>2)];
   var $168=(($current_ptr+$offset_to_base_0_i79)|0);
   var $169=$153 & 2;
   var $170=(($169)|(0))!=0;
   var $171=$170 ? $path_below : 2;
   FUNCTION_TABLE[$167]($163, $info, $168, $171, $use_strcmp);
   var $172=(($p2_0+8)|0);
   var $173=(($172)>>>(0)) < (($112)>>>(0));
   if ($173) { var $p2_0 = $172;label = 35; break; } else { label = 53; break; }
  case 39: 
   var $175=$138 & 1;
   var $176=(($175)|(0))==0;
   if ($176) { label = 41; break; } else { label = 40; break; }
  case 40: 
   var $177=(($info+24)|0);
   var $178=(($info+54)|0);
   var $179=$current_ptr;
   var $p2_1 = $134;label = 42; break;
  case 41: 
   var $180=(($info+54)|0);
   var $181=$current_ptr;
   var $p2_2 = $134;label = 48; break;
  case 42: 
   var $p2_1;
   var $183=HEAP8[($178)];
   var $184=$183 & 1;
   var $185=(($184 << 24) >> 24)==0;
   if ($185) { label = 43; break; } else { label = 53; break; }
  case 43: 
   var $187=HEAP32[(($142)>>2)];
   var $188=(($187)|(0))==1;
   if ($188) { label = 44; break; } else { label = 45; break; }
  case 44: 
   var $190=HEAP32[(($177)>>2)];
   var $191=(($190)|(0))==1;
   if ($191) { label = 53; break; } else { label = 45; break; }
  case 45: 
   var $193=(($p2_1+4)|0);
   var $194=HEAP32[(($193)>>2)];
   var $195=$194 >> 8;
   var $196=$194 & 1;
   var $197=(($196)|(0))==0;
   if ($197) { var $offset_to_base_0_i77 = $195;label = 47; break; } else { label = 46; break; }
  case 46: 
   var $199=HEAP32[(($179)>>2)];
   var $200=(($199+$195)|0);
   var $201=$200;
   var $202=HEAP32[(($201)>>2)];
   var $offset_to_base_0_i77 = $202;label = 47; break;
  case 47: 
   var $offset_to_base_0_i77;
   var $203=(($p2_1)|0);
   var $204=HEAP32[(($203)>>2)];
   var $205=$204;
   var $206=HEAP32[(($205)>>2)];
   var $207=(($206+24)|0);
   var $208=HEAP32[(($207)>>2)];
   var $209=(($current_ptr+$offset_to_base_0_i77)|0);
   var $210=$194 & 2;
   var $211=(($210)|(0))!=0;
   var $212=$211 ? $path_below : 2;
   FUNCTION_TABLE[$208]($204, $info, $209, $212, $use_strcmp);
   var $213=(($p2_1+8)|0);
   var $214=(($213)>>>(0)) < (($112)>>>(0));
   if ($214) { var $p2_1 = $213;label = 42; break; } else { label = 53; break; }
  case 48: 
   var $p2_2;
   var $216=HEAP8[($180)];
   var $217=$216 & 1;
   var $218=(($217 << 24) >> 24)==0;
   if ($218) { label = 49; break; } else { label = 53; break; }
  case 49: 
   var $220=HEAP32[(($142)>>2)];
   var $221=(($220)|(0))==1;
   if ($221) { label = 53; break; } else { label = 50; break; }
  case 50: 
   var $223=(($p2_2+4)|0);
   var $224=HEAP32[(($223)>>2)];
   var $225=$224 >> 8;
   var $226=$224 & 1;
   var $227=(($226)|(0))==0;
   if ($227) { var $offset_to_base_0_i = $225;label = 52; break; } else { label = 51; break; }
  case 51: 
   var $229=HEAP32[(($181)>>2)];
   var $230=(($229+$225)|0);
   var $231=$230;
   var $232=HEAP32[(($231)>>2)];
   var $offset_to_base_0_i = $232;label = 52; break;
  case 52: 
   var $offset_to_base_0_i;
   var $233=(($p2_2)|0);
   var $234=HEAP32[(($233)>>2)];
   var $235=$234;
   var $236=HEAP32[(($235)>>2)];
   var $237=(($236+24)|0);
   var $238=HEAP32[(($237)>>2)];
   var $239=(($current_ptr+$offset_to_base_0_i)|0);
   var $240=$224 & 2;
   var $241=(($240)|(0))!=0;
   var $242=$241 ? $path_below : 2;
   FUNCTION_TABLE[$238]($234, $info, $239, $242, $use_strcmp);
   var $243=(($p2_2+8)|0);
   var $244=(($243)>>>(0)) < (($112)>>>(0));
   if ($244) { var $p2_2 = $243;label = 48; break; } else { label = 53; break; }
  case 53: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this, $info, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 5; break; }
  case 2: 
   var $7=(($info+4)|0);
   var $8=HEAP32[(($7)>>2)];
   var $9=(($8)|(0))==(($current_ptr)|(0));
   if ($9) { label = 3; break; } else { label = 20; break; }
  case 3: 
   var $11=(($info+28)|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=(($12)|(0))==1;
   if ($13) { label = 20; break; } else { label = 4; break; }
  case 4: 
   HEAP32[(($11)>>2)]=$path_below;
   label = 20; break;
  case 5: 
   var $16=(($info)|0);
   var $17=HEAP32[(($16)>>2)];
   var $18=(($17)|0);
   var $19=(($1)|(0))==(($18)|(0));
   if ($19) { label = 6; break; } else { label = 19; break; }
  case 6: 
   var $21=(($info+16)|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=(($22)|(0))==(($current_ptr)|(0));
   if ($23) { label = 8; break; } else { label = 7; break; }
  case 7: 
   var $25=(($info+20)|0);
   var $26=HEAP32[(($25)>>2)];
   var $27=(($26)|(0))==(($current_ptr)|(0));
   if ($27) { label = 8; break; } else { label = 10; break; }
  case 8: 
   var $29=(($path_below)|(0))==1;
   if ($29) { label = 9; break; } else { label = 20; break; }
  case 9: 
   var $31=(($info+32)|0);
   HEAP32[(($31)>>2)]=1;
   label = 20; break;
  case 10: 
   var $33=(($info+32)|0);
   HEAP32[(($33)>>2)]=$path_below;
   var $34=(($info+44)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==4;
   if ($36) { label = 20; break; } else { label = 11; break; }
  case 11: 
   var $38=(($info+52)|0);
   HEAP8[($38)]=0;
   var $39=(($info+53)|0);
   HEAP8[($39)]=0;
   var $40=(($this+8)|0);
   var $41=HEAP32[(($40)>>2)];
   var $42=$41;
   var $43=HEAP32[(($42)>>2)];
   var $44=(($43+20)|0);
   var $45=HEAP32[(($44)>>2)];
   FUNCTION_TABLE[$45]($41, $info, $current_ptr, $current_ptr, 1, $use_strcmp);
   var $46=HEAP8[($39)];
   var $47=$46 & 1;
   var $48=(($47 << 24) >> 24)==0;
   if ($48) { var $is_dst_type_derived_from_static_type_0_off036 = 0;label = 13; break; } else { label = 12; break; }
  case 12: 
   var $50=HEAP8[($38)];
   var $51=$50 & 1;
   var $not_=(($51 << 24) >> 24)==0;
   if ($not_) { var $is_dst_type_derived_from_static_type_0_off036 = 1;label = 13; break; } else { label = 17; break; }
  case 13: 
   var $is_dst_type_derived_from_static_type_0_off036;
   HEAP32[(($25)>>2)]=$current_ptr;
   var $52=(($info+40)|0);
   var $53=HEAP32[(($52)>>2)];
   var $54=((($53)+(1))|0);
   HEAP32[(($52)>>2)]=$54;
   var $55=(($info+36)|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=(($56)|(0))==1;
   if ($57) { label = 14; break; } else { label = 16; break; }
  case 14: 
   var $59=(($info+24)|0);
   var $60=HEAP32[(($59)>>2)];
   var $61=(($60)|(0))==2;
   if ($61) { label = 15; break; } else { label = 16; break; }
  case 15: 
   var $63=(($info+54)|0);
   HEAP8[($63)]=1;
   if ($is_dst_type_derived_from_static_type_0_off036) { label = 17; break; } else { label = 18; break; }
  case 16: 
   if ($is_dst_type_derived_from_static_type_0_off036) { label = 17; break; } else { label = 18; break; }
  case 17: 
   HEAP32[(($34)>>2)]=3;
   label = 20; break;
  case 18: 
   HEAP32[(($34)>>2)]=4;
   label = 20; break;
  case 19: 
   var $67=(($this+8)|0);
   var $68=HEAP32[(($67)>>2)];
   var $69=$68;
   var $70=HEAP32[(($69)>>2)];
   var $71=(($70+24)|0);
   var $72=HEAP32[(($71)>>2)];
   FUNCTION_TABLE[$72]($68, $info, $current_ptr, $path_below, $use_strcmp);
   label = 20; break;
  case 20: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this, $info, $dst_ptr, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 12; break; }
  case 2: 
   var $7=(($info+53)|0);
   HEAP8[($7)]=1;
   var $8=(($info+4)|0);
   var $9=HEAP32[(($8)>>2)];
   var $10=(($9)|(0))==(($current_ptr)|(0));
   if ($10) { label = 3; break; } else { label = 26; break; }
  case 3: 
   var $12=(($info+52)|0);
   HEAP8[($12)]=1;
   var $13=(($info+16)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($14)|(0))==0;
   if ($15) { label = 4; break; } else { label = 6; break; }
  case 4: 
   HEAP32[(($13)>>2)]=$dst_ptr;
   var $17=(($info+24)|0);
   HEAP32[(($17)>>2)]=$path_below;
   var $18=(($info+36)|0);
   HEAP32[(($18)>>2)]=1;
   var $19=(($info+48)|0);
   var $20=HEAP32[(($19)>>2)];
   var $21=(($20)|(0))==1;
   var $22=(($path_below)|(0))==1;
   var $or_cond_i=$21 & $22;
   if ($or_cond_i) { label = 5; break; } else { label = 26; break; }
  case 5: 
   var $24=(($info+54)|0);
   HEAP8[($24)]=1;
   label = 26; break;
  case 6: 
   var $26=(($14)|(0))==(($dst_ptr)|(0));
   if ($26) { label = 7; break; } else { label = 11; break; }
  case 7: 
   var $28=(($info+24)|0);
   var $29=HEAP32[(($28)>>2)];
   var $30=(($29)|(0))==2;
   if ($30) { label = 8; break; } else { var $33 = $29;label = 9; break; }
  case 8: 
   HEAP32[(($28)>>2)]=$path_below;
   var $33 = $path_below;label = 9; break;
  case 9: 
   var $33;
   var $34=(($info+48)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==1;
   var $37=(($33)|(0))==1;
   var $or_cond23_i=$36 & $37;
   if ($or_cond23_i) { label = 10; break; } else { label = 26; break; }
  case 10: 
   var $39=(($info+54)|0);
   HEAP8[($39)]=1;
   label = 26; break;
  case 11: 
   var $41=(($info+36)|0);
   var $42=HEAP32[(($41)>>2)];
   var $43=((($42)+(1))|0);
   HEAP32[(($41)>>2)]=$43;
   var $44=(($info+54)|0);
   HEAP8[($44)]=1;
   label = 26; break;
  case 12: 
   var $46=(($info+52)|0);
   var $47=HEAP8[($46)];
   var $48=$47 & 1;
   var $49=(($info+53)|0);
   var $50=HEAP8[($49)];
   var $51=$50 & 1;
   var $52=(($this+12)|0);
   var $53=HEAP32[(($52)>>2)];
   var $54=(($this+16+($53<<3))|0);
   HEAP8[($46)]=0;
   HEAP8[($49)]=0;
   var $55=(($this+20)|0);
   var $56=HEAP32[(($55)>>2)];
   var $57=$56 >> 8;
   var $58=$56 & 1;
   var $59=(($58)|(0))==0;
   if ($59) { var $offset_to_base_0_i32 = $57;label = 14; break; } else { label = 13; break; }
  case 13: 
   var $61=$current_ptr;
   var $62=HEAP32[(($61)>>2)];
   var $63=(($62+$57)|0);
   var $64=$63;
   var $65=HEAP32[(($64)>>2)];
   var $offset_to_base_0_i32 = $65;label = 14; break;
  case 14: 
   var $offset_to_base_0_i32;
   var $66=(($this+16)|0);
   var $67=HEAP32[(($66)>>2)];
   var $68=$67;
   var $69=HEAP32[(($68)>>2)];
   var $70=(($69+20)|0);
   var $71=HEAP32[(($70)>>2)];
   var $72=(($current_ptr+$offset_to_base_0_i32)|0);
   var $73=$56 & 2;
   var $74=(($73)|(0))!=0;
   var $75=$74 ? $path_below : 2;
   FUNCTION_TABLE[$71]($67, $info, $dst_ptr, $72, $75, $use_strcmp);
   var $76=(($53)|(0)) > 1;
   if ($76) { label = 15; break; } else { label = 25; break; }
  case 15: 
   var $77=(($this+24)|0);
   var $78=(($info+24)|0);
   var $79=(($this+8)|0);
   var $80=(($info+54)|0);
   var $81=$current_ptr;
   var $p_0 = $77;label = 16; break;
  case 16: 
   var $p_0;
   var $83=HEAP8[($80)];
   var $84=$83 & 1;
   var $85=(($84 << 24) >> 24)==0;
   if ($85) { label = 17; break; } else { label = 25; break; }
  case 17: 
   var $87=HEAP8[($46)];
   var $88=$87 & 1;
   var $89=(($88 << 24) >> 24)==0;
   if ($89) { label = 20; break; } else { label = 18; break; }
  case 18: 
   var $91=HEAP32[(($78)>>2)];
   var $92=(($91)|(0))==1;
   if ($92) { label = 25; break; } else { label = 19; break; }
  case 19: 
   var $94=HEAP32[(($79)>>2)];
   var $95=$94 & 2;
   var $96=(($95)|(0))==0;
   if ($96) { label = 25; break; } else { label = 22; break; }
  case 20: 
   var $98=HEAP8[($49)];
   var $99=$98 & 1;
   var $100=(($99 << 24) >> 24)==0;
   if ($100) { label = 22; break; } else { label = 21; break; }
  case 21: 
   var $102=HEAP32[(($79)>>2)];
   var $103=$102 & 1;
   var $104=(($103)|(0))==0;
   if ($104) { label = 25; break; } else { label = 22; break; }
  case 22: 
   HEAP8[($46)]=0;
   HEAP8[($49)]=0;
   var $106=(($p_0+4)|0);
   var $107=HEAP32[(($106)>>2)];
   var $108=$107 >> 8;
   var $109=$107 & 1;
   var $110=(($109)|(0))==0;
   if ($110) { var $offset_to_base_0_i = $108;label = 24; break; } else { label = 23; break; }
  case 23: 
   var $112=HEAP32[(($81)>>2)];
   var $113=(($112+$108)|0);
   var $114=$113;
   var $115=HEAP32[(($114)>>2)];
   var $offset_to_base_0_i = $115;label = 24; break;
  case 24: 
   var $offset_to_base_0_i;
   var $116=(($p_0)|0);
   var $117=HEAP32[(($116)>>2)];
   var $118=$117;
   var $119=HEAP32[(($118)>>2)];
   var $120=(($119+20)|0);
   var $121=HEAP32[(($120)>>2)];
   var $122=(($current_ptr+$offset_to_base_0_i)|0);
   var $123=$107 & 2;
   var $124=(($123)|(0))!=0;
   var $125=$124 ? $path_below : 2;
   FUNCTION_TABLE[$121]($117, $info, $dst_ptr, $122, $125, $use_strcmp);
   var $126=(($p_0+8)|0);
   var $127=(($126)>>>(0)) < (($54)>>>(0));
   if ($127) { var $p_0 = $126;label = 16; break; } else { label = 25; break; }
  case 25: 
   HEAP8[($46)]=$48;
   HEAP8[($49)]=$51;
   label = 26; break;
  case 26: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this, $info, $dst_ptr, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($info+8)|0);
   var $2=HEAP32[(($1)>>2)];
   var $3=(($2)|(0))==(($this)|(0));
   if ($3) { label = 2; break; } else { label = 12; break; }
  case 2: 
   var $5=(($info+53)|0);
   HEAP8[($5)]=1;
   var $6=(($info+4)|0);
   var $7=HEAP32[(($6)>>2)];
   var $8=(($7)|(0))==(($current_ptr)|(0));
   if ($8) { label = 3; break; } else { label = 12; break; }
  case 3: 
   var $10=(($info+52)|0);
   HEAP8[($10)]=1;
   var $11=(($info+16)|0);
   var $12=HEAP32[(($11)>>2)];
   var $13=(($12)|(0))==0;
   if ($13) { label = 4; break; } else { label = 6; break; }
  case 4: 
   HEAP32[(($11)>>2)]=$dst_ptr;
   var $15=(($info+24)|0);
   HEAP32[(($15)>>2)]=$path_below;
   var $16=(($info+36)|0);
   HEAP32[(($16)>>2)]=1;
   var $17=(($info+48)|0);
   var $18=HEAP32[(($17)>>2)];
   var $19=(($18)|(0))==1;
   var $20=(($path_below)|(0))==1;
   var $or_cond_i=$19 & $20;
   if ($or_cond_i) { label = 5; break; } else { label = 12; break; }
  case 5: 
   var $22=(($info+54)|0);
   HEAP8[($22)]=1;
   label = 12; break;
  case 6: 
   var $24=(($12)|(0))==(($dst_ptr)|(0));
   if ($24) { label = 7; break; } else { label = 11; break; }
  case 7: 
   var $26=(($info+24)|0);
   var $27=HEAP32[(($26)>>2)];
   var $28=(($27)|(0))==2;
   if ($28) { label = 8; break; } else { var $31 = $27;label = 9; break; }
  case 8: 
   HEAP32[(($26)>>2)]=$path_below;
   var $31 = $path_below;label = 9; break;
  case 9: 
   var $31;
   var $32=(($info+48)|0);
   var $33=HEAP32[(($32)>>2)];
   var $34=(($33)|(0))==1;
   var $35=(($31)|(0))==1;
   var $or_cond23_i=$34 & $35;
   if ($or_cond23_i) { label = 10; break; } else { label = 12; break; }
  case 10: 
   var $37=(($info+54)|0);
   HEAP8[($37)]=1;
   label = 12; break;
  case 11: 
   var $39=(($info+36)|0);
   var $40=HEAP32[(($39)>>2)];
   var $41=((($40)+(1))|0);
   HEAP32[(($39)>>2)]=$41;
   var $42=(($info+54)|0);
   HEAP8[($42)]=1;
   label = 12; break;
  case 12: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this, $info, $dst_ptr, $current_ptr, $path_below, $use_strcmp) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|0);
   var $2=(($info+8)|0);
   var $3=HEAP32[(($2)>>2)];
   var $4=(($3)|0);
   var $5=(($1)|(0))==(($4)|(0));
   if ($5) { label = 2; break; } else { label = 12; break; }
  case 2: 
   var $7=(($info+53)|0);
   HEAP8[($7)]=1;
   var $8=(($info+4)|0);
   var $9=HEAP32[(($8)>>2)];
   var $10=(($9)|(0))==(($current_ptr)|(0));
   if ($10) { label = 3; break; } else { label = 13; break; }
  case 3: 
   var $12=(($info+52)|0);
   HEAP8[($12)]=1;
   var $13=(($info+16)|0);
   var $14=HEAP32[(($13)>>2)];
   var $15=(($14)|(0))==0;
   if ($15) { label = 4; break; } else { label = 6; break; }
  case 4: 
   HEAP32[(($13)>>2)]=$dst_ptr;
   var $17=(($info+24)|0);
   HEAP32[(($17)>>2)]=$path_below;
   var $18=(($info+36)|0);
   HEAP32[(($18)>>2)]=1;
   var $19=(($info+48)|0);
   var $20=HEAP32[(($19)>>2)];
   var $21=(($20)|(0))==1;
   var $22=(($path_below)|(0))==1;
   var $or_cond_i=$21 & $22;
   if ($or_cond_i) { label = 5; break; } else { label = 13; break; }
  case 5: 
   var $24=(($info+54)|0);
   HEAP8[($24)]=1;
   label = 13; break;
  case 6: 
   var $26=(($14)|(0))==(($dst_ptr)|(0));
   if ($26) { label = 7; break; } else { label = 11; break; }
  case 7: 
   var $28=(($info+24)|0);
   var $29=HEAP32[(($28)>>2)];
   var $30=(($29)|(0))==2;
   if ($30) { label = 8; break; } else { var $33 = $29;label = 9; break; }
  case 8: 
   HEAP32[(($28)>>2)]=$path_below;
   var $33 = $path_below;label = 9; break;
  case 9: 
   var $33;
   var $34=(($info+48)|0);
   var $35=HEAP32[(($34)>>2)];
   var $36=(($35)|(0))==1;
   var $37=(($33)|(0))==1;
   var $or_cond23_i=$36 & $37;
   if ($or_cond23_i) { label = 10; break; } else { label = 13; break; }
  case 10: 
   var $39=(($info+54)|0);
   HEAP8[($39)]=1;
   label = 13; break;
  case 11: 
   var $41=(($info+36)|0);
   var $42=HEAP32[(($41)>>2)];
   var $43=((($42)+(1))|0);
   HEAP32[(($41)>>2)]=$43;
   var $44=(($info+54)|0);
   HEAP8[($44)]=1;
   label = 13; break;
  case 12: 
   var $46=(($this+8)|0);
   var $47=HEAP32[(($46)>>2)];
   var $48=$47;
   var $49=HEAP32[(($48)>>2)];
   var $50=(($49+20)|0);
   var $51=HEAP32[(($50)>>2)];
   FUNCTION_TABLE[$51]($47, $info, $dst_ptr, $current_ptr, $path_below, $use_strcmp);
   label = 13; break;
  case 13: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function _malloc($bytes) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($bytes)>>>(0)) < 245;
   if ($1) { label = 2; break; } else { label = 78; break; }
  case 2: 
   var $3=(($bytes)>>>(0)) < 11;
   if ($3) { var $8 = 16;label = 4; break; } else { label = 3; break; }
  case 3: 
   var $5=((($bytes)+(11))|0);
   var $6=$5 & -8;
   var $8 = $6;label = 4; break;
  case 4: 
   var $8;
   var $9=$8 >>> 3;
   var $10=HEAP32[((((7752)|0))>>2)];
   var $11=$10 >>> (($9)>>>(0));
   var $12=$11 & 3;
   var $13=(($12)|(0))==0;
   if ($13) { label = 12; break; } else { label = 5; break; }
  case 5: 
   var $15=$11 & 1;
   var $16=$15 ^ 1;
   var $17=((($16)+($9))|0);
   var $18=$17 << 1;
   var $19=((7792+($18<<2))|0);
   var $20=$19;
   var $_sum111=((($18)+(2))|0);
   var $21=((7792+($_sum111<<2))|0);
   var $22=HEAP32[(($21)>>2)];
   var $23=(($22+8)|0);
   var $24=HEAP32[(($23)>>2)];
   var $25=(($20)|(0))==(($24)|(0));
   if ($25) { label = 6; break; } else { label = 7; break; }
  case 6: 
   var $27=1 << $17;
   var $28=$27 ^ -1;
   var $29=$10 & $28;
   HEAP32[((((7752)|0))>>2)]=$29;
   label = 11; break;
  case 7: 
   var $31=$24;
   var $32=HEAP32[((((7768)|0))>>2)];
   var $33=(($31)>>>(0)) < (($32)>>>(0));
   if ($33) { label = 10; break; } else { label = 8; break; }
  case 8: 
   var $35=(($24+12)|0);
   var $36=HEAP32[(($35)>>2)];
   var $37=(($36)|(0))==(($22)|(0));
   if ($37) { label = 9; break; } else { label = 10; break; }
  case 9: 
   HEAP32[(($35)>>2)]=$20;
   HEAP32[(($21)>>2)]=$24;
   label = 11; break;
  case 10: 
   _abort();
   throw "Reached an unreachable!";
  case 11: 
   var $40=$17 << 3;
   var $41=$40 | 3;
   var $42=(($22+4)|0);
   HEAP32[(($42)>>2)]=$41;
   var $43=$22;
   var $_sum113114=$40 | 4;
   var $44=(($43+$_sum113114)|0);
   var $45=$44;
   var $46=HEAP32[(($45)>>2)];
   var $47=$46 | 1;
   HEAP32[(($45)>>2)]=$47;
   var $48=$23;
   var $mem_0 = $48;label = 341; break;
  case 12: 
   var $50=HEAP32[((((7760)|0))>>2)];
   var $51=(($8)>>>(0)) > (($50)>>>(0));
   if ($51) { label = 13; break; } else { var $nb_0 = $8;label = 160; break; }
  case 13: 
   var $53=(($11)|(0))==0;
   if ($53) { label = 27; break; } else { label = 14; break; }
  case 14: 
   var $55=$11 << $9;
   var $56=2 << $9;
   var $57=(((-$56))|0);
   var $58=$56 | $57;
   var $59=$55 & $58;
   var $60=(((-$59))|0);
   var $61=$59 & $60;
   var $62=((($61)-(1))|0);
   var $63=$62 >>> 12;
   var $64=$63 & 16;
   var $65=$62 >>> (($64)>>>(0));
   var $66=$65 >>> 5;
   var $67=$66 & 8;
   var $68=$67 | $64;
   var $69=$65 >>> (($67)>>>(0));
   var $70=$69 >>> 2;
   var $71=$70 & 4;
   var $72=$68 | $71;
   var $73=$69 >>> (($71)>>>(0));
   var $74=$73 >>> 1;
   var $75=$74 & 2;
   var $76=$72 | $75;
   var $77=$73 >>> (($75)>>>(0));
   var $78=$77 >>> 1;
   var $79=$78 & 1;
   var $80=$76 | $79;
   var $81=$77 >>> (($79)>>>(0));
   var $82=((($80)+($81))|0);
   var $83=$82 << 1;
   var $84=((7792+($83<<2))|0);
   var $85=$84;
   var $_sum104=((($83)+(2))|0);
   var $86=((7792+($_sum104<<2))|0);
   var $87=HEAP32[(($86)>>2)];
   var $88=(($87+8)|0);
   var $89=HEAP32[(($88)>>2)];
   var $90=(($85)|(0))==(($89)|(0));
   if ($90) { label = 15; break; } else { label = 16; break; }
  case 15: 
   var $92=1 << $82;
   var $93=$92 ^ -1;
   var $94=$10 & $93;
   HEAP32[((((7752)|0))>>2)]=$94;
   label = 20; break;
  case 16: 
   var $96=$89;
   var $97=HEAP32[((((7768)|0))>>2)];
   var $98=(($96)>>>(0)) < (($97)>>>(0));
   if ($98) { label = 19; break; } else { label = 17; break; }
  case 17: 
   var $100=(($89+12)|0);
   var $101=HEAP32[(($100)>>2)];
   var $102=(($101)|(0))==(($87)|(0));
   if ($102) { label = 18; break; } else { label = 19; break; }
  case 18: 
   HEAP32[(($100)>>2)]=$85;
   HEAP32[(($86)>>2)]=$89;
   label = 20; break;
  case 19: 
   _abort();
   throw "Reached an unreachable!";
  case 20: 
   var $105=$82 << 3;
   var $106=((($105)-($8))|0);
   var $107=$8 | 3;
   var $108=(($87+4)|0);
   HEAP32[(($108)>>2)]=$107;
   var $109=$87;
   var $110=(($109+$8)|0);
   var $111=$110;
   var $112=$106 | 1;
   var $_sum106107=$8 | 4;
   var $113=(($109+$_sum106107)|0);
   var $114=$113;
   HEAP32[(($114)>>2)]=$112;
   var $115=(($109+$105)|0);
   var $116=$115;
   HEAP32[(($116)>>2)]=$106;
   var $117=HEAP32[((((7760)|0))>>2)];
   var $118=(($117)|(0))==0;
   if ($118) { label = 26; break; } else { label = 21; break; }
  case 21: 
   var $120=HEAP32[((((7772)|0))>>2)];
   var $121=$117 >>> 3;
   var $122=$121 << 1;
   var $123=((7792+($122<<2))|0);
   var $124=$123;
   var $125=HEAP32[((((7752)|0))>>2)];
   var $126=1 << $121;
   var $127=$125 & $126;
   var $128=(($127)|(0))==0;
   if ($128) { label = 22; break; } else { label = 23; break; }
  case 22: 
   var $130=$125 | $126;
   HEAP32[((((7752)|0))>>2)]=$130;
   var $_sum109_pre=((($122)+(2))|0);
   var $_pre=((7792+($_sum109_pre<<2))|0);
   var $F4_0 = $124;var $_pre_phi = $_pre;label = 25; break;
  case 23: 
   var $_sum110=((($122)+(2))|0);
   var $132=((7792+($_sum110<<2))|0);
   var $133=HEAP32[(($132)>>2)];
   var $134=$133;
   var $135=HEAP32[((((7768)|0))>>2)];
   var $136=(($134)>>>(0)) < (($135)>>>(0));
   if ($136) { label = 24; break; } else { var $F4_0 = $133;var $_pre_phi = $132;label = 25; break; }
  case 24: 
   _abort();
   throw "Reached an unreachable!";
  case 25: 
   var $_pre_phi;
   var $F4_0;
   HEAP32[(($_pre_phi)>>2)]=$120;
   var $139=(($F4_0+12)|0);
   HEAP32[(($139)>>2)]=$120;
   var $140=(($120+8)|0);
   HEAP32[(($140)>>2)]=$F4_0;
   var $141=(($120+12)|0);
   HEAP32[(($141)>>2)]=$124;
   label = 26; break;
  case 26: 
   HEAP32[((((7760)|0))>>2)]=$106;
   HEAP32[((((7772)|0))>>2)]=$111;
   var $143=$88;
   var $mem_0 = $143;label = 341; break;
  case 27: 
   var $145=HEAP32[((((7756)|0))>>2)];
   var $146=(($145)|(0))==0;
   if ($146) { var $nb_0 = $8;label = 160; break; } else { label = 28; break; }
  case 28: 
   var $148=(((-$145))|0);
   var $149=$145 & $148;
   var $150=((($149)-(1))|0);
   var $151=$150 >>> 12;
   var $152=$151 & 16;
   var $153=$150 >>> (($152)>>>(0));
   var $154=$153 >>> 5;
   var $155=$154 & 8;
   var $156=$155 | $152;
   var $157=$153 >>> (($155)>>>(0));
   var $158=$157 >>> 2;
   var $159=$158 & 4;
   var $160=$156 | $159;
   var $161=$157 >>> (($159)>>>(0));
   var $162=$161 >>> 1;
   var $163=$162 & 2;
   var $164=$160 | $163;
   var $165=$161 >>> (($163)>>>(0));
   var $166=$165 >>> 1;
   var $167=$166 & 1;
   var $168=$164 | $167;
   var $169=$165 >>> (($167)>>>(0));
   var $170=((($168)+($169))|0);
   var $171=((8056+($170<<2))|0);
   var $172=HEAP32[(($171)>>2)];
   var $173=(($172+4)|0);
   var $174=HEAP32[(($173)>>2)];
   var $175=$174 & -8;
   var $176=((($175)-($8))|0);
   var $t_0_i = $172;var $v_0_i = $172;var $rsize_0_i = $176;label = 29; break;
  case 29: 
   var $rsize_0_i;
   var $v_0_i;
   var $t_0_i;
   var $178=(($t_0_i+16)|0);
   var $179=HEAP32[(($178)>>2)];
   var $180=(($179)|(0))==0;
   if ($180) { label = 30; break; } else { var $185 = $179;label = 31; break; }
  case 30: 
   var $182=(($t_0_i+20)|0);
   var $183=HEAP32[(($182)>>2)];
   var $184=(($183)|(0))==0;
   if ($184) { label = 32; break; } else { var $185 = $183;label = 31; break; }
  case 31: 
   var $185;
   var $186=(($185+4)|0);
   var $187=HEAP32[(($186)>>2)];
   var $188=$187 & -8;
   var $189=((($188)-($8))|0);
   var $190=(($189)>>>(0)) < (($rsize_0_i)>>>(0));
   var $_rsize_0_i=$190 ? $189 : $rsize_0_i;
   var $_v_0_i=$190 ? $185 : $v_0_i;
   var $t_0_i = $185;var $v_0_i = $_v_0_i;var $rsize_0_i = $_rsize_0_i;label = 29; break;
  case 32: 
   var $192=$v_0_i;
   var $193=HEAP32[((((7768)|0))>>2)];
   var $194=(($192)>>>(0)) < (($193)>>>(0));
   if ($194) { label = 76; break; } else { label = 33; break; }
  case 33: 
   var $196=(($192+$8)|0);
   var $197=$196;
   var $198=(($192)>>>(0)) < (($196)>>>(0));
   if ($198) { label = 34; break; } else { label = 76; break; }
  case 34: 
   var $200=(($v_0_i+24)|0);
   var $201=HEAP32[(($200)>>2)];
   var $202=(($v_0_i+12)|0);
   var $203=HEAP32[(($202)>>2)];
   var $204=(($203)|(0))==(($v_0_i)|(0));
   if ($204) { label = 40; break; } else { label = 35; break; }
  case 35: 
   var $206=(($v_0_i+8)|0);
   var $207=HEAP32[(($206)>>2)];
   var $208=$207;
   var $209=(($208)>>>(0)) < (($193)>>>(0));
   if ($209) { label = 39; break; } else { label = 36; break; }
  case 36: 
   var $211=(($207+12)|0);
   var $212=HEAP32[(($211)>>2)];
   var $213=(($212)|(0))==(($v_0_i)|(0));
   if ($213) { label = 37; break; } else { label = 39; break; }
  case 37: 
   var $215=(($203+8)|0);
   var $216=HEAP32[(($215)>>2)];
   var $217=(($216)|(0))==(($v_0_i)|(0));
   if ($217) { label = 38; break; } else { label = 39; break; }
  case 38: 
   HEAP32[(($211)>>2)]=$203;
   HEAP32[(($215)>>2)]=$207;
   var $R_1_i = $203;label = 47; break;
  case 39: 
   _abort();
   throw "Reached an unreachable!";
  case 40: 
   var $220=(($v_0_i+20)|0);
   var $221=HEAP32[(($220)>>2)];
   var $222=(($221)|(0))==0;
   if ($222) { label = 41; break; } else { var $R_0_i = $221;var $RP_0_i = $220;label = 42; break; }
  case 41: 
   var $224=(($v_0_i+16)|0);
   var $225=HEAP32[(($224)>>2)];
   var $226=(($225)|(0))==0;
   if ($226) { var $R_1_i = 0;label = 47; break; } else { var $R_0_i = $225;var $RP_0_i = $224;label = 42; break; }
  case 42: 
   var $RP_0_i;
   var $R_0_i;
   var $227=(($R_0_i+20)|0);
   var $228=HEAP32[(($227)>>2)];
   var $229=(($228)|(0))==0;
   if ($229) { label = 43; break; } else { var $R_0_i = $228;var $RP_0_i = $227;label = 42; break; }
  case 43: 
   var $231=(($R_0_i+16)|0);
   var $232=HEAP32[(($231)>>2)];
   var $233=(($232)|(0))==0;
   if ($233) { label = 44; break; } else { var $R_0_i = $232;var $RP_0_i = $231;label = 42; break; }
  case 44: 
   var $235=$RP_0_i;
   var $236=(($235)>>>(0)) < (($193)>>>(0));
   if ($236) { label = 46; break; } else { label = 45; break; }
  case 45: 
   HEAP32[(($RP_0_i)>>2)]=0;
   var $R_1_i = $R_0_i;label = 47; break;
  case 46: 
   _abort();
   throw "Reached an unreachable!";
  case 47: 
   var $R_1_i;
   var $240=(($201)|(0))==0;
   if ($240) { label = 67; break; } else { label = 48; break; }
  case 48: 
   var $242=(($v_0_i+28)|0);
   var $243=HEAP32[(($242)>>2)];
   var $244=((8056+($243<<2))|0);
   var $245=HEAP32[(($244)>>2)];
   var $246=(($v_0_i)|(0))==(($245)|(0));
   if ($246) { label = 49; break; } else { label = 51; break; }
  case 49: 
   HEAP32[(($244)>>2)]=$R_1_i;
   var $cond_i=(($R_1_i)|(0))==0;
   if ($cond_i) { label = 50; break; } else { label = 57; break; }
  case 50: 
   var $248=HEAP32[(($242)>>2)];
   var $249=1 << $248;
   var $250=$249 ^ -1;
   var $251=HEAP32[((((7756)|0))>>2)];
   var $252=$251 & $250;
   HEAP32[((((7756)|0))>>2)]=$252;
   label = 67; break;
  case 51: 
   var $254=$201;
   var $255=HEAP32[((((7768)|0))>>2)];
   var $256=(($254)>>>(0)) < (($255)>>>(0));
   if ($256) { label = 55; break; } else { label = 52; break; }
  case 52: 
   var $258=(($201+16)|0);
   var $259=HEAP32[(($258)>>2)];
   var $260=(($259)|(0))==(($v_0_i)|(0));
   if ($260) { label = 53; break; } else { label = 54; break; }
  case 53: 
   HEAP32[(($258)>>2)]=$R_1_i;
   label = 56; break;
  case 54: 
   var $263=(($201+20)|0);
   HEAP32[(($263)>>2)]=$R_1_i;
   label = 56; break;
  case 55: 
   _abort();
   throw "Reached an unreachable!";
  case 56: 
   var $266=(($R_1_i)|(0))==0;
   if ($266) { label = 67; break; } else { label = 57; break; }
  case 57: 
   var $268=$R_1_i;
   var $269=HEAP32[((((7768)|0))>>2)];
   var $270=(($268)>>>(0)) < (($269)>>>(0));
   if ($270) { label = 66; break; } else { label = 58; break; }
  case 58: 
   var $272=(($R_1_i+24)|0);
   HEAP32[(($272)>>2)]=$201;
   var $273=(($v_0_i+16)|0);
   var $274=HEAP32[(($273)>>2)];
   var $275=(($274)|(0))==0;
   if ($275) { label = 62; break; } else { label = 59; break; }
  case 59: 
   var $277=$274;
   var $278=HEAP32[((((7768)|0))>>2)];
   var $279=(($277)>>>(0)) < (($278)>>>(0));
   if ($279) { label = 61; break; } else { label = 60; break; }
  case 60: 
   var $281=(($R_1_i+16)|0);
   HEAP32[(($281)>>2)]=$274;
   var $282=(($274+24)|0);
   HEAP32[(($282)>>2)]=$R_1_i;
   label = 62; break;
  case 61: 
   _abort();
   throw "Reached an unreachable!";
  case 62: 
   var $285=(($v_0_i+20)|0);
   var $286=HEAP32[(($285)>>2)];
   var $287=(($286)|(0))==0;
   if ($287) { label = 67; break; } else { label = 63; break; }
  case 63: 
   var $289=$286;
   var $290=HEAP32[((((7768)|0))>>2)];
   var $291=(($289)>>>(0)) < (($290)>>>(0));
   if ($291) { label = 65; break; } else { label = 64; break; }
  case 64: 
   var $293=(($R_1_i+20)|0);
   HEAP32[(($293)>>2)]=$286;
   var $294=(($286+24)|0);
   HEAP32[(($294)>>2)]=$R_1_i;
   label = 67; break;
  case 65: 
   _abort();
   throw "Reached an unreachable!";
  case 66: 
   _abort();
   throw "Reached an unreachable!";
  case 67: 
   var $298=(($rsize_0_i)>>>(0)) < 16;
   if ($298) { label = 68; break; } else { label = 69; break; }
  case 68: 
   var $300=((($rsize_0_i)+($8))|0);
   var $301=$300 | 3;
   var $302=(($v_0_i+4)|0);
   HEAP32[(($302)>>2)]=$301;
   var $_sum4_i=((($300)+(4))|0);
   var $303=(($192+$_sum4_i)|0);
   var $304=$303;
   var $305=HEAP32[(($304)>>2)];
   var $306=$305 | 1;
   HEAP32[(($304)>>2)]=$306;
   label = 77; break;
  case 69: 
   var $308=$8 | 3;
   var $309=(($v_0_i+4)|0);
   HEAP32[(($309)>>2)]=$308;
   var $310=$rsize_0_i | 1;
   var $_sum_i137=$8 | 4;
   var $311=(($192+$_sum_i137)|0);
   var $312=$311;
   HEAP32[(($312)>>2)]=$310;
   var $_sum1_i=((($rsize_0_i)+($8))|0);
   var $313=(($192+$_sum1_i)|0);
   var $314=$313;
   HEAP32[(($314)>>2)]=$rsize_0_i;
   var $315=HEAP32[((((7760)|0))>>2)];
   var $316=(($315)|(0))==0;
   if ($316) { label = 75; break; } else { label = 70; break; }
  case 70: 
   var $318=HEAP32[((((7772)|0))>>2)];
   var $319=$315 >>> 3;
   var $320=$319 << 1;
   var $321=((7792+($320<<2))|0);
   var $322=$321;
   var $323=HEAP32[((((7752)|0))>>2)];
   var $324=1 << $319;
   var $325=$323 & $324;
   var $326=(($325)|(0))==0;
   if ($326) { label = 71; break; } else { label = 72; break; }
  case 71: 
   var $328=$323 | $324;
   HEAP32[((((7752)|0))>>2)]=$328;
   var $_sum2_pre_i=((($320)+(2))|0);
   var $_pre_i=((7792+($_sum2_pre_i<<2))|0);
   var $F1_0_i = $322;var $_pre_phi_i = $_pre_i;label = 74; break;
  case 72: 
   var $_sum3_i=((($320)+(2))|0);
   var $330=((7792+($_sum3_i<<2))|0);
   var $331=HEAP32[(($330)>>2)];
   var $332=$331;
   var $333=HEAP32[((((7768)|0))>>2)];
   var $334=(($332)>>>(0)) < (($333)>>>(0));
   if ($334) { label = 73; break; } else { var $F1_0_i = $331;var $_pre_phi_i = $330;label = 74; break; }
  case 73: 
   _abort();
   throw "Reached an unreachable!";
  case 74: 
   var $_pre_phi_i;
   var $F1_0_i;
   HEAP32[(($_pre_phi_i)>>2)]=$318;
   var $337=(($F1_0_i+12)|0);
   HEAP32[(($337)>>2)]=$318;
   var $338=(($318+8)|0);
   HEAP32[(($338)>>2)]=$F1_0_i;
   var $339=(($318+12)|0);
   HEAP32[(($339)>>2)]=$322;
   label = 75; break;
  case 75: 
   HEAP32[((((7760)|0))>>2)]=$rsize_0_i;
   HEAP32[((((7772)|0))>>2)]=$197;
   label = 77; break;
  case 76: 
   _abort();
   throw "Reached an unreachable!";
  case 77: 
   var $342=(($v_0_i+8)|0);
   var $343=$342;
   var $344=(($342)|(0))==0;
   if ($344) { var $nb_0 = $8;label = 160; break; } else { var $mem_0 = $343;label = 341; break; }
  case 78: 
   var $346=(($bytes)>>>(0)) > 4294967231;
   if ($346) { var $nb_0 = -1;label = 160; break; } else { label = 79; break; }
  case 79: 
   var $348=((($bytes)+(11))|0);
   var $349=$348 & -8;
   var $350=HEAP32[((((7756)|0))>>2)];
   var $351=(($350)|(0))==0;
   if ($351) { var $nb_0 = $349;label = 160; break; } else { label = 80; break; }
  case 80: 
   var $353=(((-$349))|0);
   var $354=$348 >>> 8;
   var $355=(($354)|(0))==0;
   if ($355) { var $idx_0_i = 0;label = 83; break; } else { label = 81; break; }
  case 81: 
   var $357=(($349)>>>(0)) > 16777215;
   if ($357) { var $idx_0_i = 31;label = 83; break; } else { label = 82; break; }
  case 82: 
   var $359=((($354)+(1048320))|0);
   var $360=$359 >>> 16;
   var $361=$360 & 8;
   var $362=$354 << $361;
   var $363=((($362)+(520192))|0);
   var $364=$363 >>> 16;
   var $365=$364 & 4;
   var $366=$365 | $361;
   var $367=$362 << $365;
   var $368=((($367)+(245760))|0);
   var $369=$368 >>> 16;
   var $370=$369 & 2;
   var $371=$366 | $370;
   var $372=(((14)-($371))|0);
   var $373=$367 << $370;
   var $374=$373 >>> 15;
   var $375=((($372)+($374))|0);
   var $376=$375 << 1;
   var $377=((($375)+(7))|0);
   var $378=$349 >>> (($377)>>>(0));
   var $379=$378 & 1;
   var $380=$379 | $376;
   var $idx_0_i = $380;label = 83; break;
  case 83: 
   var $idx_0_i;
   var $382=((8056+($idx_0_i<<2))|0);
   var $383=HEAP32[(($382)>>2)];
   var $384=(($383)|(0))==0;
   if ($384) { var $v_2_i = 0;var $rsize_2_i = $353;var $t_1_i = 0;label = 90; break; } else { label = 84; break; }
  case 84: 
   var $386=(($idx_0_i)|(0))==31;
   if ($386) { var $391 = 0;label = 86; break; } else { label = 85; break; }
  case 85: 
   var $388=$idx_0_i >>> 1;
   var $389=(((25)-($388))|0);
   var $391 = $389;label = 86; break;
  case 86: 
   var $391;
   var $392=$349 << $391;
   var $v_0_i118 = 0;var $rsize_0_i117 = $353;var $t_0_i116 = $383;var $sizebits_0_i = $392;var $rst_0_i = 0;label = 87; break;
  case 87: 
   var $rst_0_i;
   var $sizebits_0_i;
   var $t_0_i116;
   var $rsize_0_i117;
   var $v_0_i118;
   var $394=(($t_0_i116+4)|0);
   var $395=HEAP32[(($394)>>2)];
   var $396=$395 & -8;
   var $397=((($396)-($349))|0);
   var $398=(($397)>>>(0)) < (($rsize_0_i117)>>>(0));
   if ($398) { label = 88; break; } else { var $v_1_i = $v_0_i118;var $rsize_1_i = $rsize_0_i117;label = 89; break; }
  case 88: 
   var $400=(($396)|(0))==(($349)|(0));
   if ($400) { var $v_2_i = $t_0_i116;var $rsize_2_i = $397;var $t_1_i = $t_0_i116;label = 90; break; } else { var $v_1_i = $t_0_i116;var $rsize_1_i = $397;label = 89; break; }
  case 89: 
   var $rsize_1_i;
   var $v_1_i;
   var $402=(($t_0_i116+20)|0);
   var $403=HEAP32[(($402)>>2)];
   var $404=$sizebits_0_i >>> 31;
   var $405=(($t_0_i116+16+($404<<2))|0);
   var $406=HEAP32[(($405)>>2)];
   var $407=(($403)|(0))==0;
   var $408=(($403)|(0))==(($406)|(0));
   var $or_cond_i=$407 | $408;
   var $rst_1_i=$or_cond_i ? $rst_0_i : $403;
   var $409=(($406)|(0))==0;
   var $410=$sizebits_0_i << 1;
   if ($409) { var $v_2_i = $v_1_i;var $rsize_2_i = $rsize_1_i;var $t_1_i = $rst_1_i;label = 90; break; } else { var $v_0_i118 = $v_1_i;var $rsize_0_i117 = $rsize_1_i;var $t_0_i116 = $406;var $sizebits_0_i = $410;var $rst_0_i = $rst_1_i;label = 87; break; }
  case 90: 
   var $t_1_i;
   var $rsize_2_i;
   var $v_2_i;
   var $411=(($t_1_i)|(0))==0;
   var $412=(($v_2_i)|(0))==0;
   var $or_cond21_i=$411 & $412;
   if ($or_cond21_i) { label = 91; break; } else { var $t_2_ph_i = $t_1_i;label = 93; break; }
  case 91: 
   var $414=2 << $idx_0_i;
   var $415=(((-$414))|0);
   var $416=$414 | $415;
   var $417=$350 & $416;
   var $418=(($417)|(0))==0;
   if ($418) { var $nb_0 = $349;label = 160; break; } else { label = 92; break; }
  case 92: 
   var $420=(((-$417))|0);
   var $421=$417 & $420;
   var $422=((($421)-(1))|0);
   var $423=$422 >>> 12;
   var $424=$423 & 16;
   var $425=$422 >>> (($424)>>>(0));
   var $426=$425 >>> 5;
   var $427=$426 & 8;
   var $428=$427 | $424;
   var $429=$425 >>> (($427)>>>(0));
   var $430=$429 >>> 2;
   var $431=$430 & 4;
   var $432=$428 | $431;
   var $433=$429 >>> (($431)>>>(0));
   var $434=$433 >>> 1;
   var $435=$434 & 2;
   var $436=$432 | $435;
   var $437=$433 >>> (($435)>>>(0));
   var $438=$437 >>> 1;
   var $439=$438 & 1;
   var $440=$436 | $439;
   var $441=$437 >>> (($439)>>>(0));
   var $442=((($440)+($441))|0);
   var $443=((8056+($442<<2))|0);
   var $444=HEAP32[(($443)>>2)];
   var $t_2_ph_i = $444;label = 93; break;
  case 93: 
   var $t_2_ph_i;
   var $445=(($t_2_ph_i)|(0))==0;
   if ($445) { var $rsize_3_lcssa_i = $rsize_2_i;var $v_3_lcssa_i = $v_2_i;label = 96; break; } else { var $t_228_i = $t_2_ph_i;var $rsize_329_i = $rsize_2_i;var $v_330_i = $v_2_i;label = 94; break; }
  case 94: 
   var $v_330_i;
   var $rsize_329_i;
   var $t_228_i;
   var $446=(($t_228_i+4)|0);
   var $447=HEAP32[(($446)>>2)];
   var $448=$447 & -8;
   var $449=((($448)-($349))|0);
   var $450=(($449)>>>(0)) < (($rsize_329_i)>>>(0));
   var $_rsize_3_i=$450 ? $449 : $rsize_329_i;
   var $t_2_v_3_i=$450 ? $t_228_i : $v_330_i;
   var $451=(($t_228_i+16)|0);
   var $452=HEAP32[(($451)>>2)];
   var $453=(($452)|(0))==0;
   if ($453) { label = 95; break; } else { var $t_228_i = $452;var $rsize_329_i = $_rsize_3_i;var $v_330_i = $t_2_v_3_i;label = 94; break; }
  case 95: 
   var $454=(($t_228_i+20)|0);
   var $455=HEAP32[(($454)>>2)];
   var $456=(($455)|(0))==0;
   if ($456) { var $rsize_3_lcssa_i = $_rsize_3_i;var $v_3_lcssa_i = $t_2_v_3_i;label = 96; break; } else { var $t_228_i = $455;var $rsize_329_i = $_rsize_3_i;var $v_330_i = $t_2_v_3_i;label = 94; break; }
  case 96: 
   var $v_3_lcssa_i;
   var $rsize_3_lcssa_i;
   var $457=(($v_3_lcssa_i)|(0))==0;
   if ($457) { var $nb_0 = $349;label = 160; break; } else { label = 97; break; }
  case 97: 
   var $459=HEAP32[((((7760)|0))>>2)];
   var $460=((($459)-($349))|0);
   var $461=(($rsize_3_lcssa_i)>>>(0)) < (($460)>>>(0));
   if ($461) { label = 98; break; } else { var $nb_0 = $349;label = 160; break; }
  case 98: 
   var $463=$v_3_lcssa_i;
   var $464=HEAP32[((((7768)|0))>>2)];
   var $465=(($463)>>>(0)) < (($464)>>>(0));
   if ($465) { label = 158; break; } else { label = 99; break; }
  case 99: 
   var $467=(($463+$349)|0);
   var $468=$467;
   var $469=(($463)>>>(0)) < (($467)>>>(0));
   if ($469) { label = 100; break; } else { label = 158; break; }
  case 100: 
   var $471=(($v_3_lcssa_i+24)|0);
   var $472=HEAP32[(($471)>>2)];
   var $473=(($v_3_lcssa_i+12)|0);
   var $474=HEAP32[(($473)>>2)];
   var $475=(($474)|(0))==(($v_3_lcssa_i)|(0));
   if ($475) { label = 106; break; } else { label = 101; break; }
  case 101: 
   var $477=(($v_3_lcssa_i+8)|0);
   var $478=HEAP32[(($477)>>2)];
   var $479=$478;
   var $480=(($479)>>>(0)) < (($464)>>>(0));
   if ($480) { label = 105; break; } else { label = 102; break; }
  case 102: 
   var $482=(($478+12)|0);
   var $483=HEAP32[(($482)>>2)];
   var $484=(($483)|(0))==(($v_3_lcssa_i)|(0));
   if ($484) { label = 103; break; } else { label = 105; break; }
  case 103: 
   var $486=(($474+8)|0);
   var $487=HEAP32[(($486)>>2)];
   var $488=(($487)|(0))==(($v_3_lcssa_i)|(0));
   if ($488) { label = 104; break; } else { label = 105; break; }
  case 104: 
   HEAP32[(($482)>>2)]=$474;
   HEAP32[(($486)>>2)]=$478;
   var $R_1_i122 = $474;label = 113; break;
  case 105: 
   _abort();
   throw "Reached an unreachable!";
  case 106: 
   var $491=(($v_3_lcssa_i+20)|0);
   var $492=HEAP32[(($491)>>2)];
   var $493=(($492)|(0))==0;
   if ($493) { label = 107; break; } else { var $R_0_i120 = $492;var $RP_0_i119 = $491;label = 108; break; }
  case 107: 
   var $495=(($v_3_lcssa_i+16)|0);
   var $496=HEAP32[(($495)>>2)];
   var $497=(($496)|(0))==0;
   if ($497) { var $R_1_i122 = 0;label = 113; break; } else { var $R_0_i120 = $496;var $RP_0_i119 = $495;label = 108; break; }
  case 108: 
   var $RP_0_i119;
   var $R_0_i120;
   var $498=(($R_0_i120+20)|0);
   var $499=HEAP32[(($498)>>2)];
   var $500=(($499)|(0))==0;
   if ($500) { label = 109; break; } else { var $R_0_i120 = $499;var $RP_0_i119 = $498;label = 108; break; }
  case 109: 
   var $502=(($R_0_i120+16)|0);
   var $503=HEAP32[(($502)>>2)];
   var $504=(($503)|(0))==0;
   if ($504) { label = 110; break; } else { var $R_0_i120 = $503;var $RP_0_i119 = $502;label = 108; break; }
  case 110: 
   var $506=$RP_0_i119;
   var $507=(($506)>>>(0)) < (($464)>>>(0));
   if ($507) { label = 112; break; } else { label = 111; break; }
  case 111: 
   HEAP32[(($RP_0_i119)>>2)]=0;
   var $R_1_i122 = $R_0_i120;label = 113; break;
  case 112: 
   _abort();
   throw "Reached an unreachable!";
  case 113: 
   var $R_1_i122;
   var $511=(($472)|(0))==0;
   if ($511) { label = 133; break; } else { label = 114; break; }
  case 114: 
   var $513=(($v_3_lcssa_i+28)|0);
   var $514=HEAP32[(($513)>>2)];
   var $515=((8056+($514<<2))|0);
   var $516=HEAP32[(($515)>>2)];
   var $517=(($v_3_lcssa_i)|(0))==(($516)|(0));
   if ($517) { label = 115; break; } else { label = 117; break; }
  case 115: 
   HEAP32[(($515)>>2)]=$R_1_i122;
   var $cond_i123=(($R_1_i122)|(0))==0;
   if ($cond_i123) { label = 116; break; } else { label = 123; break; }
  case 116: 
   var $519=HEAP32[(($513)>>2)];
   var $520=1 << $519;
   var $521=$520 ^ -1;
   var $522=HEAP32[((((7756)|0))>>2)];
   var $523=$522 & $521;
   HEAP32[((((7756)|0))>>2)]=$523;
   label = 133; break;
  case 117: 
   var $525=$472;
   var $526=HEAP32[((((7768)|0))>>2)];
   var $527=(($525)>>>(0)) < (($526)>>>(0));
   if ($527) { label = 121; break; } else { label = 118; break; }
  case 118: 
   var $529=(($472+16)|0);
   var $530=HEAP32[(($529)>>2)];
   var $531=(($530)|(0))==(($v_3_lcssa_i)|(0));
   if ($531) { label = 119; break; } else { label = 120; break; }
  case 119: 
   HEAP32[(($529)>>2)]=$R_1_i122;
   label = 122; break;
  case 120: 
   var $534=(($472+20)|0);
   HEAP32[(($534)>>2)]=$R_1_i122;
   label = 122; break;
  case 121: 
   _abort();
   throw "Reached an unreachable!";
  case 122: 
   var $537=(($R_1_i122)|(0))==0;
   if ($537) { label = 133; break; } else { label = 123; break; }
  case 123: 
   var $539=$R_1_i122;
   var $540=HEAP32[((((7768)|0))>>2)];
   var $541=(($539)>>>(0)) < (($540)>>>(0));
   if ($541) { label = 132; break; } else { label = 124; break; }
  case 124: 
   var $543=(($R_1_i122+24)|0);
   HEAP32[(($543)>>2)]=$472;
   var $544=(($v_3_lcssa_i+16)|0);
   var $545=HEAP32[(($544)>>2)];
   var $546=(($545)|(0))==0;
   if ($546) { label = 128; break; } else { label = 125; break; }
  case 125: 
   var $548=$545;
   var $549=HEAP32[((((7768)|0))>>2)];
   var $550=(($548)>>>(0)) < (($549)>>>(0));
   if ($550) { label = 127; break; } else { label = 126; break; }
  case 126: 
   var $552=(($R_1_i122+16)|0);
   HEAP32[(($552)>>2)]=$545;
   var $553=(($545+24)|0);
   HEAP32[(($553)>>2)]=$R_1_i122;
   label = 128; break;
  case 127: 
   _abort();
   throw "Reached an unreachable!";
  case 128: 
   var $556=(($v_3_lcssa_i+20)|0);
   var $557=HEAP32[(($556)>>2)];
   var $558=(($557)|(0))==0;
   if ($558) { label = 133; break; } else { label = 129; break; }
  case 129: 
   var $560=$557;
   var $561=HEAP32[((((7768)|0))>>2)];
   var $562=(($560)>>>(0)) < (($561)>>>(0));
   if ($562) { label = 131; break; } else { label = 130; break; }
  case 130: 
   var $564=(($R_1_i122+20)|0);
   HEAP32[(($564)>>2)]=$557;
   var $565=(($557+24)|0);
   HEAP32[(($565)>>2)]=$R_1_i122;
   label = 133; break;
  case 131: 
   _abort();
   throw "Reached an unreachable!";
  case 132: 
   _abort();
   throw "Reached an unreachable!";
  case 133: 
   var $569=(($rsize_3_lcssa_i)>>>(0)) < 16;
   if ($569) { label = 134; break; } else { label = 135; break; }
  case 134: 
   var $571=((($rsize_3_lcssa_i)+($349))|0);
   var $572=$571 | 3;
   var $573=(($v_3_lcssa_i+4)|0);
   HEAP32[(($573)>>2)]=$572;
   var $_sum19_i=((($571)+(4))|0);
   var $574=(($463+$_sum19_i)|0);
   var $575=$574;
   var $576=HEAP32[(($575)>>2)];
   var $577=$576 | 1;
   HEAP32[(($575)>>2)]=$577;
   label = 159; break;
  case 135: 
   var $579=$349 | 3;
   var $580=(($v_3_lcssa_i+4)|0);
   HEAP32[(($580)>>2)]=$579;
   var $581=$rsize_3_lcssa_i | 1;
   var $_sum_i125136=$349 | 4;
   var $582=(($463+$_sum_i125136)|0);
   var $583=$582;
   HEAP32[(($583)>>2)]=$581;
   var $_sum1_i126=((($rsize_3_lcssa_i)+($349))|0);
   var $584=(($463+$_sum1_i126)|0);
   var $585=$584;
   HEAP32[(($585)>>2)]=$rsize_3_lcssa_i;
   var $586=$rsize_3_lcssa_i >>> 3;
   var $587=(($rsize_3_lcssa_i)>>>(0)) < 256;
   if ($587) { label = 136; break; } else { label = 141; break; }
  case 136: 
   var $589=$586 << 1;
   var $590=((7792+($589<<2))|0);
   var $591=$590;
   var $592=HEAP32[((((7752)|0))>>2)];
   var $593=1 << $586;
   var $594=$592 & $593;
   var $595=(($594)|(0))==0;
   if ($595) { label = 137; break; } else { label = 138; break; }
  case 137: 
   var $597=$592 | $593;
   HEAP32[((((7752)|0))>>2)]=$597;
   var $_sum15_pre_i=((($589)+(2))|0);
   var $_pre_i127=((7792+($_sum15_pre_i<<2))|0);
   var $F5_0_i = $591;var $_pre_phi_i128 = $_pre_i127;label = 140; break;
  case 138: 
   var $_sum18_i=((($589)+(2))|0);
   var $599=((7792+($_sum18_i<<2))|0);
   var $600=HEAP32[(($599)>>2)];
   var $601=$600;
   var $602=HEAP32[((((7768)|0))>>2)];
   var $603=(($601)>>>(0)) < (($602)>>>(0));
   if ($603) { label = 139; break; } else { var $F5_0_i = $600;var $_pre_phi_i128 = $599;label = 140; break; }
  case 139: 
   _abort();
   throw "Reached an unreachable!";
  case 140: 
   var $_pre_phi_i128;
   var $F5_0_i;
   HEAP32[(($_pre_phi_i128)>>2)]=$468;
   var $606=(($F5_0_i+12)|0);
   HEAP32[(($606)>>2)]=$468;
   var $_sum16_i=((($349)+(8))|0);
   var $607=(($463+$_sum16_i)|0);
   var $608=$607;
   HEAP32[(($608)>>2)]=$F5_0_i;
   var $_sum17_i=((($349)+(12))|0);
   var $609=(($463+$_sum17_i)|0);
   var $610=$609;
   HEAP32[(($610)>>2)]=$591;
   label = 159; break;
  case 141: 
   var $612=$467;
   var $613=$rsize_3_lcssa_i >>> 8;
   var $614=(($613)|(0))==0;
   if ($614) { var $I7_0_i = 0;label = 144; break; } else { label = 142; break; }
  case 142: 
   var $616=(($rsize_3_lcssa_i)>>>(0)) > 16777215;
   if ($616) { var $I7_0_i = 31;label = 144; break; } else { label = 143; break; }
  case 143: 
   var $618=((($613)+(1048320))|0);
   var $619=$618 >>> 16;
   var $620=$619 & 8;
   var $621=$613 << $620;
   var $622=((($621)+(520192))|0);
   var $623=$622 >>> 16;
   var $624=$623 & 4;
   var $625=$624 | $620;
   var $626=$621 << $624;
   var $627=((($626)+(245760))|0);
   var $628=$627 >>> 16;
   var $629=$628 & 2;
   var $630=$625 | $629;
   var $631=(((14)-($630))|0);
   var $632=$626 << $629;
   var $633=$632 >>> 15;
   var $634=((($631)+($633))|0);
   var $635=$634 << 1;
   var $636=((($634)+(7))|0);
   var $637=$rsize_3_lcssa_i >>> (($636)>>>(0));
   var $638=$637 & 1;
   var $639=$638 | $635;
   var $I7_0_i = $639;label = 144; break;
  case 144: 
   var $I7_0_i;
   var $641=((8056+($I7_0_i<<2))|0);
   var $_sum2_i=((($349)+(28))|0);
   var $642=(($463+$_sum2_i)|0);
   var $643=$642;
   HEAP32[(($643)>>2)]=$I7_0_i;
   var $_sum3_i129=((($349)+(16))|0);
   var $644=(($463+$_sum3_i129)|0);
   var $_sum4_i130=((($349)+(20))|0);
   var $645=(($463+$_sum4_i130)|0);
   var $646=$645;
   HEAP32[(($646)>>2)]=0;
   var $647=$644;
   HEAP32[(($647)>>2)]=0;
   var $648=HEAP32[((((7756)|0))>>2)];
   var $649=1 << $I7_0_i;
   var $650=$648 & $649;
   var $651=(($650)|(0))==0;
   if ($651) { label = 145; break; } else { label = 146; break; }
  case 145: 
   var $653=$648 | $649;
   HEAP32[((((7756)|0))>>2)]=$653;
   HEAP32[(($641)>>2)]=$612;
   var $654=$641;
   var $_sum5_i=((($349)+(24))|0);
   var $655=(($463+$_sum5_i)|0);
   var $656=$655;
   HEAP32[(($656)>>2)]=$654;
   var $_sum6_i=((($349)+(12))|0);
   var $657=(($463+$_sum6_i)|0);
   var $658=$657;
   HEAP32[(($658)>>2)]=$612;
   var $_sum7_i=((($349)+(8))|0);
   var $659=(($463+$_sum7_i)|0);
   var $660=$659;
   HEAP32[(($660)>>2)]=$612;
   label = 159; break;
  case 146: 
   var $662=HEAP32[(($641)>>2)];
   var $663=(($I7_0_i)|(0))==31;
   if ($663) { var $668 = 0;label = 148; break; } else { label = 147; break; }
  case 147: 
   var $665=$I7_0_i >>> 1;
   var $666=(((25)-($665))|0);
   var $668 = $666;label = 148; break;
  case 148: 
   var $668;
   var $669=$rsize_3_lcssa_i << $668;
   var $K12_0_i = $669;var $T_0_i = $662;label = 149; break;
  case 149: 
   var $T_0_i;
   var $K12_0_i;
   var $671=(($T_0_i+4)|0);
   var $672=HEAP32[(($671)>>2)];
   var $673=$672 & -8;
   var $674=(($673)|(0))==(($rsize_3_lcssa_i)|(0));
   if ($674) { label = 154; break; } else { label = 150; break; }
  case 150: 
   var $676=$K12_0_i >>> 31;
   var $677=(($T_0_i+16+($676<<2))|0);
   var $678=HEAP32[(($677)>>2)];
   var $679=(($678)|(0))==0;
   var $680=$K12_0_i << 1;
   if ($679) { label = 151; break; } else { var $K12_0_i = $680;var $T_0_i = $678;label = 149; break; }
  case 151: 
   var $682=$677;
   var $683=HEAP32[((((7768)|0))>>2)];
   var $684=(($682)>>>(0)) < (($683)>>>(0));
   if ($684) { label = 153; break; } else { label = 152; break; }
  case 152: 
   HEAP32[(($677)>>2)]=$612;
   var $_sum12_i=((($349)+(24))|0);
   var $686=(($463+$_sum12_i)|0);
   var $687=$686;
   HEAP32[(($687)>>2)]=$T_0_i;
   var $_sum13_i=((($349)+(12))|0);
   var $688=(($463+$_sum13_i)|0);
   var $689=$688;
   HEAP32[(($689)>>2)]=$612;
   var $_sum14_i=((($349)+(8))|0);
   var $690=(($463+$_sum14_i)|0);
   var $691=$690;
   HEAP32[(($691)>>2)]=$612;
   label = 159; break;
  case 153: 
   _abort();
   throw "Reached an unreachable!";
  case 154: 
   var $694=(($T_0_i+8)|0);
   var $695=HEAP32[(($694)>>2)];
   var $696=$T_0_i;
   var $697=HEAP32[((((7768)|0))>>2)];
   var $698=(($696)>>>(0)) < (($697)>>>(0));
   if ($698) { label = 157; break; } else { label = 155; break; }
  case 155: 
   var $700=$695;
   var $701=(($700)>>>(0)) < (($697)>>>(0));
   if ($701) { label = 157; break; } else { label = 156; break; }
  case 156: 
   var $703=(($695+12)|0);
   HEAP32[(($703)>>2)]=$612;
   HEAP32[(($694)>>2)]=$612;
   var $_sum9_i=((($349)+(8))|0);
   var $704=(($463+$_sum9_i)|0);
   var $705=$704;
   HEAP32[(($705)>>2)]=$695;
   var $_sum10_i=((($349)+(12))|0);
   var $706=(($463+$_sum10_i)|0);
   var $707=$706;
   HEAP32[(($707)>>2)]=$T_0_i;
   var $_sum11_i=((($349)+(24))|0);
   var $708=(($463+$_sum11_i)|0);
   var $709=$708;
   HEAP32[(($709)>>2)]=0;
   label = 159; break;
  case 157: 
   _abort();
   throw "Reached an unreachable!";
  case 158: 
   _abort();
   throw "Reached an unreachable!";
  case 159: 
   var $711=(($v_3_lcssa_i+8)|0);
   var $712=$711;
   var $713=(($711)|(0))==0;
   if ($713) { var $nb_0 = $349;label = 160; break; } else { var $mem_0 = $712;label = 341; break; }
  case 160: 
   var $nb_0;
   var $714=HEAP32[((((7760)|0))>>2)];
   var $715=(($nb_0)>>>(0)) > (($714)>>>(0));
   if ($715) { label = 165; break; } else { label = 161; break; }
  case 161: 
   var $717=((($714)-($nb_0))|0);
   var $718=HEAP32[((((7772)|0))>>2)];
   var $719=(($717)>>>(0)) > 15;
   if ($719) { label = 162; break; } else { label = 163; break; }
  case 162: 
   var $721=$718;
   var $722=(($721+$nb_0)|0);
   var $723=$722;
   HEAP32[((((7772)|0))>>2)]=$723;
   HEAP32[((((7760)|0))>>2)]=$717;
   var $724=$717 | 1;
   var $_sum102=((($nb_0)+(4))|0);
   var $725=(($721+$_sum102)|0);
   var $726=$725;
   HEAP32[(($726)>>2)]=$724;
   var $727=(($721+$714)|0);
   var $728=$727;
   HEAP32[(($728)>>2)]=$717;
   var $729=$nb_0 | 3;
   var $730=(($718+4)|0);
   HEAP32[(($730)>>2)]=$729;
   label = 164; break;
  case 163: 
   HEAP32[((((7760)|0))>>2)]=0;
   HEAP32[((((7772)|0))>>2)]=0;
   var $732=$714 | 3;
   var $733=(($718+4)|0);
   HEAP32[(($733)>>2)]=$732;
   var $734=$718;
   var $_sum101=((($714)+(4))|0);
   var $735=(($734+$_sum101)|0);
   var $736=$735;
   var $737=HEAP32[(($736)>>2)];
   var $738=$737 | 1;
   HEAP32[(($736)>>2)]=$738;
   label = 164; break;
  case 164: 
   var $740=(($718+8)|0);
   var $741=$740;
   var $mem_0 = $741;label = 341; break;
  case 165: 
   var $743=HEAP32[((((7764)|0))>>2)];
   var $744=(($nb_0)>>>(0)) < (($743)>>>(0));
   if ($744) { label = 166; break; } else { label = 167; break; }
  case 166: 
   var $746=((($743)-($nb_0))|0);
   HEAP32[((((7764)|0))>>2)]=$746;
   var $747=HEAP32[((((7776)|0))>>2)];
   var $748=$747;
   var $749=(($748+$nb_0)|0);
   var $750=$749;
   HEAP32[((((7776)|0))>>2)]=$750;
   var $751=$746 | 1;
   var $_sum=((($nb_0)+(4))|0);
   var $752=(($748+$_sum)|0);
   var $753=$752;
   HEAP32[(($753)>>2)]=$751;
   var $754=$nb_0 | 3;
   var $755=(($747+4)|0);
   HEAP32[(($755)>>2)]=$754;
   var $756=(($747+8)|0);
   var $757=$756;
   var $mem_0 = $757;label = 341; break;
  case 167: 
   var $759=HEAP32[((((7552)|0))>>2)];
   var $760=(($759)|(0))==0;
   if ($760) { label = 168; break; } else { label = 171; break; }
  case 168: 
   var $762=_sysconf(8);
   var $763=((($762)-(1))|0);
   var $764=$763 & $762;
   var $765=(($764)|(0))==0;
   if ($765) { label = 170; break; } else { label = 169; break; }
  case 169: 
   _abort();
   throw "Reached an unreachable!";
  case 170: 
   HEAP32[((((7560)|0))>>2)]=$762;
   HEAP32[((((7556)|0))>>2)]=$762;
   HEAP32[((((7564)|0))>>2)]=-1;
   HEAP32[((((7568)|0))>>2)]=-1;
   HEAP32[((((7572)|0))>>2)]=0;
   HEAP32[((((8196)|0))>>2)]=0;
   var $767=_time(0);
   var $768=$767 & -16;
   var $769=$768 ^ 1431655768;
   HEAP32[((((7552)|0))>>2)]=$769;
   label = 171; break;
  case 171: 
   var $771=((($nb_0)+(48))|0);
   var $772=HEAP32[((((7560)|0))>>2)];
   var $773=((($nb_0)+(47))|0);
   var $774=((($772)+($773))|0);
   var $775=(((-$772))|0);
   var $776=$774 & $775;
   var $777=(($776)>>>(0)) > (($nb_0)>>>(0));
   if ($777) { label = 172; break; } else { var $mem_0 = 0;label = 341; break; }
  case 172: 
   var $779=HEAP32[((((8192)|0))>>2)];
   var $780=(($779)|(0))==0;
   if ($780) { label = 174; break; } else { label = 173; break; }
  case 173: 
   var $782=HEAP32[((((8184)|0))>>2)];
   var $783=((($782)+($776))|0);
   var $784=(($783)>>>(0)) <= (($782)>>>(0));
   var $785=(($783)>>>(0)) > (($779)>>>(0));
   var $or_cond1_i=$784 | $785;
   if ($or_cond1_i) { var $mem_0 = 0;label = 341; break; } else { label = 174; break; }
  case 174: 
   var $787=HEAP32[((((8196)|0))>>2)];
   var $788=$787 & 4;
   var $789=(($788)|(0))==0;
   if ($789) { label = 175; break; } else { var $tsize_1_i = 0;label = 198; break; }
  case 175: 
   var $791=HEAP32[((((7776)|0))>>2)];
   var $792=(($791)|(0))==0;
   if ($792) { label = 181; break; } else { label = 176; break; }
  case 176: 
   var $794=$791;
   var $sp_0_i_i = ((8200)|0);label = 177; break;
  case 177: 
   var $sp_0_i_i;
   var $796=(($sp_0_i_i)|0);
   var $797=HEAP32[(($796)>>2)];
   var $798=(($797)>>>(0)) > (($794)>>>(0));
   if ($798) { label = 179; break; } else { label = 178; break; }
  case 178: 
   var $800=(($sp_0_i_i+4)|0);
   var $801=HEAP32[(($800)>>2)];
   var $802=(($797+$801)|0);
   var $803=(($802)>>>(0)) > (($794)>>>(0));
   if ($803) { label = 180; break; } else { label = 179; break; }
  case 179: 
   var $805=(($sp_0_i_i+8)|0);
   var $806=HEAP32[(($805)>>2)];
   var $807=(($806)|(0))==0;
   if ($807) { label = 181; break; } else { var $sp_0_i_i = $806;label = 177; break; }
  case 180: 
   var $808=(($sp_0_i_i)|(0))==0;
   if ($808) { label = 181; break; } else { label = 188; break; }
  case 181: 
   var $809=_sbrk(0);
   var $810=(($809)|(0))==-1;
   if ($810) { var $tsize_0303639_i = 0;label = 197; break; } else { label = 182; break; }
  case 182: 
   var $812=$809;
   var $813=HEAP32[((((7556)|0))>>2)];
   var $814=((($813)-(1))|0);
   var $815=$814 & $812;
   var $816=(($815)|(0))==0;
   if ($816) { var $ssize_0_i = $776;label = 184; break; } else { label = 183; break; }
  case 183: 
   var $818=((($814)+($812))|0);
   var $819=(((-$813))|0);
   var $820=$818 & $819;
   var $821=((($776)-($812))|0);
   var $822=((($821)+($820))|0);
   var $ssize_0_i = $822;label = 184; break;
  case 184: 
   var $ssize_0_i;
   var $824=HEAP32[((((8184)|0))>>2)];
   var $825=((($824)+($ssize_0_i))|0);
   var $826=(($ssize_0_i)>>>(0)) > (($nb_0)>>>(0));
   var $827=(($ssize_0_i)>>>(0)) < 2147483647;
   var $or_cond_i131=$826 & $827;
   if ($or_cond_i131) { label = 185; break; } else { var $tsize_0303639_i = 0;label = 197; break; }
  case 185: 
   var $829=HEAP32[((((8192)|0))>>2)];
   var $830=(($829)|(0))==0;
   if ($830) { label = 187; break; } else { label = 186; break; }
  case 186: 
   var $832=(($825)>>>(0)) <= (($824)>>>(0));
   var $833=(($825)>>>(0)) > (($829)>>>(0));
   var $or_cond2_i=$832 | $833;
   if ($or_cond2_i) { var $tsize_0303639_i = 0;label = 197; break; } else { label = 187; break; }
  case 187: 
   var $835=_sbrk($ssize_0_i);
   var $836=(($835)|(0))==(($809)|(0));
   var $ssize_0__i=$836 ? $ssize_0_i : 0;
   var $__i=$836 ? $809 : -1;
   var $tbase_0_i = $__i;var $tsize_0_i = $ssize_0__i;var $br_0_i = $835;var $ssize_1_i = $ssize_0_i;label = 190; break;
  case 188: 
   var $838=HEAP32[((((7764)|0))>>2)];
   var $839=((($774)-($838))|0);
   var $840=$839 & $775;
   var $841=(($840)>>>(0)) < 2147483647;
   if ($841) { label = 189; break; } else { var $tsize_0303639_i = 0;label = 197; break; }
  case 189: 
   var $843=_sbrk($840);
   var $844=HEAP32[(($796)>>2)];
   var $845=HEAP32[(($800)>>2)];
   var $846=(($844+$845)|0);
   var $847=(($843)|(0))==(($846)|(0));
   var $_3_i=$847 ? $840 : 0;
   var $_4_i=$847 ? $843 : -1;
   var $tbase_0_i = $_4_i;var $tsize_0_i = $_3_i;var $br_0_i = $843;var $ssize_1_i = $840;label = 190; break;
  case 190: 
   var $ssize_1_i;
   var $br_0_i;
   var $tsize_0_i;
   var $tbase_0_i;
   var $849=(((-$ssize_1_i))|0);
   var $850=(($tbase_0_i)|(0))==-1;
   if ($850) { label = 191; break; } else { var $tsize_244_i = $tsize_0_i;var $tbase_245_i = $tbase_0_i;label = 201; break; }
  case 191: 
   var $852=(($br_0_i)|(0))!=-1;
   var $853=(($ssize_1_i)>>>(0)) < 2147483647;
   var $or_cond5_i=$852 & $853;
   var $854=(($ssize_1_i)>>>(0)) < (($771)>>>(0));
   var $or_cond6_i=$or_cond5_i & $854;
   if ($or_cond6_i) { label = 192; break; } else { var $ssize_2_i = $ssize_1_i;label = 196; break; }
  case 192: 
   var $856=HEAP32[((((7560)|0))>>2)];
   var $857=((($773)-($ssize_1_i))|0);
   var $858=((($857)+($856))|0);
   var $859=(((-$856))|0);
   var $860=$858 & $859;
   var $861=(($860)>>>(0)) < 2147483647;
   if ($861) { label = 193; break; } else { var $ssize_2_i = $ssize_1_i;label = 196; break; }
  case 193: 
   var $863=_sbrk($860);
   var $864=(($863)|(0))==-1;
   if ($864) { label = 195; break; } else { label = 194; break; }
  case 194: 
   var $866=((($860)+($ssize_1_i))|0);
   var $ssize_2_i = $866;label = 196; break;
  case 195: 
   var $868=_sbrk($849);
   var $tsize_0303639_i = $tsize_0_i;label = 197; break;
  case 196: 
   var $ssize_2_i;
   var $870=(($br_0_i)|(0))==-1;
   if ($870) { var $tsize_0303639_i = $tsize_0_i;label = 197; break; } else { var $tsize_244_i = $ssize_2_i;var $tbase_245_i = $br_0_i;label = 201; break; }
  case 197: 
   var $tsize_0303639_i;
   var $871=HEAP32[((((8196)|0))>>2)];
   var $872=$871 | 4;
   HEAP32[((((8196)|0))>>2)]=$872;
   var $tsize_1_i = $tsize_0303639_i;label = 198; break;
  case 198: 
   var $tsize_1_i;
   var $874=(($776)>>>(0)) < 2147483647;
   if ($874) { label = 199; break; } else { label = 340; break; }
  case 199: 
   var $876=_sbrk($776);
   var $877=_sbrk(0);
   var $notlhs_i=(($876)|(0))!=-1;
   var $notrhs_i=(($877)|(0))!=-1;
   var $or_cond8_not_i=$notrhs_i & $notlhs_i;
   var $878=(($876)>>>(0)) < (($877)>>>(0));
   var $or_cond9_i=$or_cond8_not_i & $878;
   if ($or_cond9_i) { label = 200; break; } else { label = 340; break; }
  case 200: 
   var $879=$877;
   var $880=$876;
   var $881=((($879)-($880))|0);
   var $882=((($nb_0)+(40))|0);
   var $883=(($881)>>>(0)) > (($882)>>>(0));
   var $_tsize_1_i=$883 ? $881 : $tsize_1_i;
   var $_tbase_1_i=$883 ? $876 : -1;
   var $884=(($_tbase_1_i)|(0))==-1;
   if ($884) { label = 340; break; } else { var $tsize_244_i = $_tsize_1_i;var $tbase_245_i = $_tbase_1_i;label = 201; break; }
  case 201: 
   var $tbase_245_i;
   var $tsize_244_i;
   var $885=HEAP32[((((8184)|0))>>2)];
   var $886=((($885)+($tsize_244_i))|0);
   HEAP32[((((8184)|0))>>2)]=$886;
   var $887=HEAP32[((((8188)|0))>>2)];
   var $888=(($886)>>>(0)) > (($887)>>>(0));
   if ($888) { label = 202; break; } else { label = 203; break; }
  case 202: 
   HEAP32[((((8188)|0))>>2)]=$886;
   label = 203; break;
  case 203: 
   var $890=HEAP32[((((7776)|0))>>2)];
   var $891=(($890)|(0))==0;
   if ($891) { label = 204; break; } else { var $sp_067_i = ((8200)|0);label = 211; break; }
  case 204: 
   var $893=HEAP32[((((7768)|0))>>2)];
   var $894=(($893)|(0))==0;
   var $895=(($tbase_245_i)>>>(0)) < (($893)>>>(0));
   var $or_cond10_i=$894 | $895;
   if ($or_cond10_i) { label = 205; break; } else { label = 206; break; }
  case 205: 
   HEAP32[((((7768)|0))>>2)]=$tbase_245_i;
   label = 206; break;
  case 206: 
   HEAP32[((((8200)|0))>>2)]=$tbase_245_i;
   HEAP32[((((8204)|0))>>2)]=$tsize_244_i;
   HEAP32[((((8212)|0))>>2)]=0;
   var $897=HEAP32[((((7552)|0))>>2)];
   HEAP32[((((7788)|0))>>2)]=$897;
   HEAP32[((((7784)|0))>>2)]=-1;
   var $i_02_i_i = 0;label = 207; break;
  case 207: 
   var $i_02_i_i;
   var $899=$i_02_i_i << 1;
   var $900=((7792+($899<<2))|0);
   var $901=$900;
   var $_sum_i_i=((($899)+(3))|0);
   var $902=((7792+($_sum_i_i<<2))|0);
   HEAP32[(($902)>>2)]=$901;
   var $_sum1_i_i=((($899)+(2))|0);
   var $903=((7792+($_sum1_i_i<<2))|0);
   HEAP32[(($903)>>2)]=$901;
   var $904=((($i_02_i_i)+(1))|0);
   var $905=(($904)>>>(0)) < 32;
   if ($905) { var $i_02_i_i = $904;label = 207; break; } else { label = 208; break; }
  case 208: 
   var $906=((($tsize_244_i)-(40))|0);
   var $907=(($tbase_245_i+8)|0);
   var $908=$907;
   var $909=$908 & 7;
   var $910=(($909)|(0))==0;
   if ($910) { var $914 = 0;label = 210; break; } else { label = 209; break; }
  case 209: 
   var $912=(((-$908))|0);
   var $913=$912 & 7;
   var $914 = $913;label = 210; break;
  case 210: 
   var $914;
   var $915=(($tbase_245_i+$914)|0);
   var $916=$915;
   var $917=((($906)-($914))|0);
   HEAP32[((((7776)|0))>>2)]=$916;
   HEAP32[((((7764)|0))>>2)]=$917;
   var $918=$917 | 1;
   var $_sum_i14_i=((($914)+(4))|0);
   var $919=(($tbase_245_i+$_sum_i14_i)|0);
   var $920=$919;
   HEAP32[(($920)>>2)]=$918;
   var $_sum2_i_i=((($tsize_244_i)-(36))|0);
   var $921=(($tbase_245_i+$_sum2_i_i)|0);
   var $922=$921;
   HEAP32[(($922)>>2)]=40;
   var $923=HEAP32[((((7568)|0))>>2)];
   HEAP32[((((7780)|0))>>2)]=$923;
   label = 338; break;
  case 211: 
   var $sp_067_i;
   var $924=(($sp_067_i)|0);
   var $925=HEAP32[(($924)>>2)];
   var $926=(($sp_067_i+4)|0);
   var $927=HEAP32[(($926)>>2)];
   var $928=(($925+$927)|0);
   var $929=(($tbase_245_i)|(0))==(($928)|(0));
   if ($929) { label = 213; break; } else { label = 212; break; }
  case 212: 
   var $931=(($sp_067_i+8)|0);
   var $932=HEAP32[(($931)>>2)];
   var $933=(($932)|(0))==0;
   if ($933) { label = 218; break; } else { var $sp_067_i = $932;label = 211; break; }
  case 213: 
   var $934=(($sp_067_i+12)|0);
   var $935=HEAP32[(($934)>>2)];
   var $936=$935 & 8;
   var $937=(($936)|(0))==0;
   if ($937) { label = 214; break; } else { label = 218; break; }
  case 214: 
   var $939=$890;
   var $940=(($939)>>>(0)) >= (($925)>>>(0));
   var $941=(($939)>>>(0)) < (($tbase_245_i)>>>(0));
   var $or_cond47_i=$940 & $941;
   if ($or_cond47_i) { label = 215; break; } else { label = 218; break; }
  case 215: 
   var $943=((($927)+($tsize_244_i))|0);
   HEAP32[(($926)>>2)]=$943;
   var $944=HEAP32[((((7776)|0))>>2)];
   var $945=HEAP32[((((7764)|0))>>2)];
   var $946=((($945)+($tsize_244_i))|0);
   var $947=$944;
   var $948=(($944+8)|0);
   var $949=$948;
   var $950=$949 & 7;
   var $951=(($950)|(0))==0;
   if ($951) { var $955 = 0;label = 217; break; } else { label = 216; break; }
  case 216: 
   var $953=(((-$949))|0);
   var $954=$953 & 7;
   var $955 = $954;label = 217; break;
  case 217: 
   var $955;
   var $956=(($947+$955)|0);
   var $957=$956;
   var $958=((($946)-($955))|0);
   HEAP32[((((7776)|0))>>2)]=$957;
   HEAP32[((((7764)|0))>>2)]=$958;
   var $959=$958 | 1;
   var $_sum_i18_i=((($955)+(4))|0);
   var $960=(($947+$_sum_i18_i)|0);
   var $961=$960;
   HEAP32[(($961)>>2)]=$959;
   var $_sum2_i19_i=((($946)+(4))|0);
   var $962=(($947+$_sum2_i19_i)|0);
   var $963=$962;
   HEAP32[(($963)>>2)]=40;
   var $964=HEAP32[((((7568)|0))>>2)];
   HEAP32[((((7780)|0))>>2)]=$964;
   label = 338; break;
  case 218: 
   var $965=HEAP32[((((7768)|0))>>2)];
   var $966=(($tbase_245_i)>>>(0)) < (($965)>>>(0));
   if ($966) { label = 219; break; } else { label = 220; break; }
  case 219: 
   HEAP32[((((7768)|0))>>2)]=$tbase_245_i;
   label = 220; break;
  case 220: 
   var $968=(($tbase_245_i+$tsize_244_i)|0);
   var $sp_160_i = ((8200)|0);label = 221; break;
  case 221: 
   var $sp_160_i;
   var $970=(($sp_160_i)|0);
   var $971=HEAP32[(($970)>>2)];
   var $972=(($971)|(0))==(($968)|(0));
   if ($972) { label = 223; break; } else { label = 222; break; }
  case 222: 
   var $974=(($sp_160_i+8)|0);
   var $975=HEAP32[(($974)>>2)];
   var $976=(($975)|(0))==0;
   if ($976) { label = 304; break; } else { var $sp_160_i = $975;label = 221; break; }
  case 223: 
   var $977=(($sp_160_i+12)|0);
   var $978=HEAP32[(($977)>>2)];
   var $979=$978 & 8;
   var $980=(($979)|(0))==0;
   if ($980) { label = 224; break; } else { label = 304; break; }
  case 224: 
   HEAP32[(($970)>>2)]=$tbase_245_i;
   var $982=(($sp_160_i+4)|0);
   var $983=HEAP32[(($982)>>2)];
   var $984=((($983)+($tsize_244_i))|0);
   HEAP32[(($982)>>2)]=$984;
   var $985=(($tbase_245_i+8)|0);
   var $986=$985;
   var $987=$986 & 7;
   var $988=(($987)|(0))==0;
   if ($988) { var $993 = 0;label = 226; break; } else { label = 225; break; }
  case 225: 
   var $990=(((-$986))|0);
   var $991=$990 & 7;
   var $993 = $991;label = 226; break;
  case 226: 
   var $993;
   var $994=(($tbase_245_i+$993)|0);
   var $_sum93_i=((($tsize_244_i)+(8))|0);
   var $995=(($tbase_245_i+$_sum93_i)|0);
   var $996=$995;
   var $997=$996 & 7;
   var $998=(($997)|(0))==0;
   if ($998) { var $1003 = 0;label = 228; break; } else { label = 227; break; }
  case 227: 
   var $1000=(((-$996))|0);
   var $1001=$1000 & 7;
   var $1003 = $1001;label = 228; break;
  case 228: 
   var $1003;
   var $_sum94_i=((($1003)+($tsize_244_i))|0);
   var $1004=(($tbase_245_i+$_sum94_i)|0);
   var $1005=$1004;
   var $1006=$1004;
   var $1007=$994;
   var $1008=((($1006)-($1007))|0);
   var $_sum_i21_i=((($993)+($nb_0))|0);
   var $1009=(($tbase_245_i+$_sum_i21_i)|0);
   var $1010=$1009;
   var $1011=((($1008)-($nb_0))|0);
   var $1012=$nb_0 | 3;
   var $_sum1_i22_i=((($993)+(4))|0);
   var $1013=(($tbase_245_i+$_sum1_i22_i)|0);
   var $1014=$1013;
   HEAP32[(($1014)>>2)]=$1012;
   var $1015=HEAP32[((((7776)|0))>>2)];
   var $1016=(($1005)|(0))==(($1015)|(0));
   if ($1016) { label = 229; break; } else { label = 230; break; }
  case 229: 
   var $1018=HEAP32[((((7764)|0))>>2)];
   var $1019=((($1018)+($1011))|0);
   HEAP32[((((7764)|0))>>2)]=$1019;
   HEAP32[((((7776)|0))>>2)]=$1010;
   var $1020=$1019 | 1;
   var $_sum46_i_i=((($_sum_i21_i)+(4))|0);
   var $1021=(($tbase_245_i+$_sum46_i_i)|0);
   var $1022=$1021;
   HEAP32[(($1022)>>2)]=$1020;
   label = 303; break;
  case 230: 
   var $1024=HEAP32[((((7772)|0))>>2)];
   var $1025=(($1005)|(0))==(($1024)|(0));
   if ($1025) { label = 231; break; } else { label = 232; break; }
  case 231: 
   var $1027=HEAP32[((((7760)|0))>>2)];
   var $1028=((($1027)+($1011))|0);
   HEAP32[((((7760)|0))>>2)]=$1028;
   HEAP32[((((7772)|0))>>2)]=$1010;
   var $1029=$1028 | 1;
   var $_sum44_i_i=((($_sum_i21_i)+(4))|0);
   var $1030=(($tbase_245_i+$_sum44_i_i)|0);
   var $1031=$1030;
   HEAP32[(($1031)>>2)]=$1029;
   var $_sum45_i_i=((($1028)+($_sum_i21_i))|0);
   var $1032=(($tbase_245_i+$_sum45_i_i)|0);
   var $1033=$1032;
   HEAP32[(($1033)>>2)]=$1028;
   label = 303; break;
  case 232: 
   var $_sum2_i23_i=((($tsize_244_i)+(4))|0);
   var $_sum95_i=((($_sum2_i23_i)+($1003))|0);
   var $1035=(($tbase_245_i+$_sum95_i)|0);
   var $1036=$1035;
   var $1037=HEAP32[(($1036)>>2)];
   var $1038=$1037 & 3;
   var $1039=(($1038)|(0))==1;
   if ($1039) { label = 233; break; } else { var $oldfirst_0_i_i = $1005;var $qsize_0_i_i = $1011;label = 280; break; }
  case 233: 
   var $1041=$1037 & -8;
   var $1042=$1037 >>> 3;
   var $1043=(($1037)>>>(0)) < 256;
   if ($1043) { label = 234; break; } else { label = 246; break; }
  case 234: 
   var $_sum3940_i_i=$1003 | 8;
   var $_sum105_i=((($_sum3940_i_i)+($tsize_244_i))|0);
   var $1045=(($tbase_245_i+$_sum105_i)|0);
   var $1046=$1045;
   var $1047=HEAP32[(($1046)>>2)];
   var $_sum41_i_i=((($tsize_244_i)+(12))|0);
   var $_sum106_i=((($_sum41_i_i)+($1003))|0);
   var $1048=(($tbase_245_i+$_sum106_i)|0);
   var $1049=$1048;
   var $1050=HEAP32[(($1049)>>2)];
   var $1051=$1042 << 1;
   var $1052=((7792+($1051<<2))|0);
   var $1053=$1052;
   var $1054=(($1047)|(0))==(($1053)|(0));
   if ($1054) { label = 237; break; } else { label = 235; break; }
  case 235: 
   var $1056=$1047;
   var $1057=HEAP32[((((7768)|0))>>2)];
   var $1058=(($1056)>>>(0)) < (($1057)>>>(0));
   if ($1058) { label = 245; break; } else { label = 236; break; }
  case 236: 
   var $1060=(($1047+12)|0);
   var $1061=HEAP32[(($1060)>>2)];
   var $1062=(($1061)|(0))==(($1005)|(0));
   if ($1062) { label = 237; break; } else { label = 245; break; }
  case 237: 
   var $1063=(($1050)|(0))==(($1047)|(0));
   if ($1063) { label = 238; break; } else { label = 239; break; }
  case 238: 
   var $1065=1 << $1042;
   var $1066=$1065 ^ -1;
   var $1067=HEAP32[((((7752)|0))>>2)];
   var $1068=$1067 & $1066;
   HEAP32[((((7752)|0))>>2)]=$1068;
   label = 279; break;
  case 239: 
   var $1070=(($1050)|(0))==(($1053)|(0));
   if ($1070) { label = 240; break; } else { label = 241; break; }
  case 240: 
   var $_pre56_i_i=(($1050+8)|0);
   var $_pre_phi57_i_i = $_pre56_i_i;label = 243; break;
  case 241: 
   var $1072=$1050;
   var $1073=HEAP32[((((7768)|0))>>2)];
   var $1074=(($1072)>>>(0)) < (($1073)>>>(0));
   if ($1074) { label = 244; break; } else { label = 242; break; }
  case 242: 
   var $1076=(($1050+8)|0);
   var $1077=HEAP32[(($1076)>>2)];
   var $1078=(($1077)|(0))==(($1005)|(0));
   if ($1078) { var $_pre_phi57_i_i = $1076;label = 243; break; } else { label = 244; break; }
  case 243: 
   var $_pre_phi57_i_i;
   var $1079=(($1047+12)|0);
   HEAP32[(($1079)>>2)]=$1050;
   HEAP32[(($_pre_phi57_i_i)>>2)]=$1047;
   label = 279; break;
  case 244: 
   _abort();
   throw "Reached an unreachable!";
  case 245: 
   _abort();
   throw "Reached an unreachable!";
  case 246: 
   var $1081=$1004;
   var $_sum34_i_i=$1003 | 24;
   var $_sum96_i=((($_sum34_i_i)+($tsize_244_i))|0);
   var $1082=(($tbase_245_i+$_sum96_i)|0);
   var $1083=$1082;
   var $1084=HEAP32[(($1083)>>2)];
   var $_sum5_i_i=((($tsize_244_i)+(12))|0);
   var $_sum97_i=((($_sum5_i_i)+($1003))|0);
   var $1085=(($tbase_245_i+$_sum97_i)|0);
   var $1086=$1085;
   var $1087=HEAP32[(($1086)>>2)];
   var $1088=(($1087)|(0))==(($1081)|(0));
   if ($1088) { label = 252; break; } else { label = 247; break; }
  case 247: 
   var $_sum3637_i_i=$1003 | 8;
   var $_sum98_i=((($_sum3637_i_i)+($tsize_244_i))|0);
   var $1090=(($tbase_245_i+$_sum98_i)|0);
   var $1091=$1090;
   var $1092=HEAP32[(($1091)>>2)];
   var $1093=$1092;
   var $1094=HEAP32[((((7768)|0))>>2)];
   var $1095=(($1093)>>>(0)) < (($1094)>>>(0));
   if ($1095) { label = 251; break; } else { label = 248; break; }
  case 248: 
   var $1097=(($1092+12)|0);
   var $1098=HEAP32[(($1097)>>2)];
   var $1099=(($1098)|(0))==(($1081)|(0));
   if ($1099) { label = 249; break; } else { label = 251; break; }
  case 249: 
   var $1101=(($1087+8)|0);
   var $1102=HEAP32[(($1101)>>2)];
   var $1103=(($1102)|(0))==(($1081)|(0));
   if ($1103) { label = 250; break; } else { label = 251; break; }
  case 250: 
   HEAP32[(($1097)>>2)]=$1087;
   HEAP32[(($1101)>>2)]=$1092;
   var $R_1_i_i = $1087;label = 259; break;
  case 251: 
   _abort();
   throw "Reached an unreachable!";
  case 252: 
   var $_sum67_i_i=$1003 | 16;
   var $_sum103_i=((($_sum2_i23_i)+($_sum67_i_i))|0);
   var $1106=(($tbase_245_i+$_sum103_i)|0);
   var $1107=$1106;
   var $1108=HEAP32[(($1107)>>2)];
   var $1109=(($1108)|(0))==0;
   if ($1109) { label = 253; break; } else { var $R_0_i_i = $1108;var $RP_0_i_i = $1107;label = 254; break; }
  case 253: 
   var $_sum104_i=((($_sum67_i_i)+($tsize_244_i))|0);
   var $1111=(($tbase_245_i+$_sum104_i)|0);
   var $1112=$1111;
   var $1113=HEAP32[(($1112)>>2)];
   var $1114=(($1113)|(0))==0;
   if ($1114) { var $R_1_i_i = 0;label = 259; break; } else { var $R_0_i_i = $1113;var $RP_0_i_i = $1112;label = 254; break; }
  case 254: 
   var $RP_0_i_i;
   var $R_0_i_i;
   var $1115=(($R_0_i_i+20)|0);
   var $1116=HEAP32[(($1115)>>2)];
   var $1117=(($1116)|(0))==0;
   if ($1117) { label = 255; break; } else { var $R_0_i_i = $1116;var $RP_0_i_i = $1115;label = 254; break; }
  case 255: 
   var $1119=(($R_0_i_i+16)|0);
   var $1120=HEAP32[(($1119)>>2)];
   var $1121=(($1120)|(0))==0;
   if ($1121) { label = 256; break; } else { var $R_0_i_i = $1120;var $RP_0_i_i = $1119;label = 254; break; }
  case 256: 
   var $1123=$RP_0_i_i;
   var $1124=HEAP32[((((7768)|0))>>2)];
   var $1125=(($1123)>>>(0)) < (($1124)>>>(0));
   if ($1125) { label = 258; break; } else { label = 257; break; }
  case 257: 
   HEAP32[(($RP_0_i_i)>>2)]=0;
   var $R_1_i_i = $R_0_i_i;label = 259; break;
  case 258: 
   _abort();
   throw "Reached an unreachable!";
  case 259: 
   var $R_1_i_i;
   var $1129=(($1084)|(0))==0;
   if ($1129) { label = 279; break; } else { label = 260; break; }
  case 260: 
   var $_sum31_i_i=((($tsize_244_i)+(28))|0);
   var $_sum99_i=((($_sum31_i_i)+($1003))|0);
   var $1131=(($tbase_245_i+$_sum99_i)|0);
   var $1132=$1131;
   var $1133=HEAP32[(($1132)>>2)];
   var $1134=((8056+($1133<<2))|0);
   var $1135=HEAP32[(($1134)>>2)];
   var $1136=(($1081)|(0))==(($1135)|(0));
   if ($1136) { label = 261; break; } else { label = 263; break; }
  case 261: 
   HEAP32[(($1134)>>2)]=$R_1_i_i;
   var $cond_i_i=(($R_1_i_i)|(0))==0;
   if ($cond_i_i) { label = 262; break; } else { label = 269; break; }
  case 262: 
   var $1138=HEAP32[(($1132)>>2)];
   var $1139=1 << $1138;
   var $1140=$1139 ^ -1;
   var $1141=HEAP32[((((7756)|0))>>2)];
   var $1142=$1141 & $1140;
   HEAP32[((((7756)|0))>>2)]=$1142;
   label = 279; break;
  case 263: 
   var $1144=$1084;
   var $1145=HEAP32[((((7768)|0))>>2)];
   var $1146=(($1144)>>>(0)) < (($1145)>>>(0));
   if ($1146) { label = 267; break; } else { label = 264; break; }
  case 264: 
   var $1148=(($1084+16)|0);
   var $1149=HEAP32[(($1148)>>2)];
   var $1150=(($1149)|(0))==(($1081)|(0));
   if ($1150) { label = 265; break; } else { label = 266; break; }
  case 265: 
   HEAP32[(($1148)>>2)]=$R_1_i_i;
   label = 268; break;
  case 266: 
   var $1153=(($1084+20)|0);
   HEAP32[(($1153)>>2)]=$R_1_i_i;
   label = 268; break;
  case 267: 
   _abort();
   throw "Reached an unreachable!";
  case 268: 
   var $1156=(($R_1_i_i)|(0))==0;
   if ($1156) { label = 279; break; } else { label = 269; break; }
  case 269: 
   var $1158=$R_1_i_i;
   var $1159=HEAP32[((((7768)|0))>>2)];
   var $1160=(($1158)>>>(0)) < (($1159)>>>(0));
   if ($1160) { label = 278; break; } else { label = 270; break; }
  case 270: 
   var $1162=(($R_1_i_i+24)|0);
   HEAP32[(($1162)>>2)]=$1084;
   var $_sum3233_i_i=$1003 | 16;
   var $_sum100_i=((($_sum3233_i_i)+($tsize_244_i))|0);
   var $1163=(($tbase_245_i+$_sum100_i)|0);
   var $1164=$1163;
   var $1165=HEAP32[(($1164)>>2)];
   var $1166=(($1165)|(0))==0;
   if ($1166) { label = 274; break; } else { label = 271; break; }
  case 271: 
   var $1168=$1165;
   var $1169=HEAP32[((((7768)|0))>>2)];
   var $1170=(($1168)>>>(0)) < (($1169)>>>(0));
   if ($1170) { label = 273; break; } else { label = 272; break; }
  case 272: 
   var $1172=(($R_1_i_i+16)|0);
   HEAP32[(($1172)>>2)]=$1165;
   var $1173=(($1165+24)|0);
   HEAP32[(($1173)>>2)]=$R_1_i_i;
   label = 274; break;
  case 273: 
   _abort();
   throw "Reached an unreachable!";
  case 274: 
   var $_sum101_i=((($_sum2_i23_i)+($_sum3233_i_i))|0);
   var $1176=(($tbase_245_i+$_sum101_i)|0);
   var $1177=$1176;
   var $1178=HEAP32[(($1177)>>2)];
   var $1179=(($1178)|(0))==0;
   if ($1179) { label = 279; break; } else { label = 275; break; }
  case 275: 
   var $1181=$1178;
   var $1182=HEAP32[((((7768)|0))>>2)];
   var $1183=(($1181)>>>(0)) < (($1182)>>>(0));
   if ($1183) { label = 277; break; } else { label = 276; break; }
  case 276: 
   var $1185=(($R_1_i_i+20)|0);
   HEAP32[(($1185)>>2)]=$1178;
   var $1186=(($1178+24)|0);
   HEAP32[(($1186)>>2)]=$R_1_i_i;
   label = 279; break;
  case 277: 
   _abort();
   throw "Reached an unreachable!";
  case 278: 
   _abort();
   throw "Reached an unreachable!";
  case 279: 
   var $_sum9_i_i=$1041 | $1003;
   var $_sum102_i=((($_sum9_i_i)+($tsize_244_i))|0);
   var $1190=(($tbase_245_i+$_sum102_i)|0);
   var $1191=$1190;
   var $1192=((($1041)+($1011))|0);
   var $oldfirst_0_i_i = $1191;var $qsize_0_i_i = $1192;label = 280; break;
  case 280: 
   var $qsize_0_i_i;
   var $oldfirst_0_i_i;
   var $1194=(($oldfirst_0_i_i+4)|0);
   var $1195=HEAP32[(($1194)>>2)];
   var $1196=$1195 & -2;
   HEAP32[(($1194)>>2)]=$1196;
   var $1197=$qsize_0_i_i | 1;
   var $_sum10_i_i=((($_sum_i21_i)+(4))|0);
   var $1198=(($tbase_245_i+$_sum10_i_i)|0);
   var $1199=$1198;
   HEAP32[(($1199)>>2)]=$1197;
   var $_sum11_i_i=((($qsize_0_i_i)+($_sum_i21_i))|0);
   var $1200=(($tbase_245_i+$_sum11_i_i)|0);
   var $1201=$1200;
   HEAP32[(($1201)>>2)]=$qsize_0_i_i;
   var $1202=$qsize_0_i_i >>> 3;
   var $1203=(($qsize_0_i_i)>>>(0)) < 256;
   if ($1203) { label = 281; break; } else { label = 286; break; }
  case 281: 
   var $1205=$1202 << 1;
   var $1206=((7792+($1205<<2))|0);
   var $1207=$1206;
   var $1208=HEAP32[((((7752)|0))>>2)];
   var $1209=1 << $1202;
   var $1210=$1208 & $1209;
   var $1211=(($1210)|(0))==0;
   if ($1211) { label = 282; break; } else { label = 283; break; }
  case 282: 
   var $1213=$1208 | $1209;
   HEAP32[((((7752)|0))>>2)]=$1213;
   var $_sum27_pre_i_i=((($1205)+(2))|0);
   var $_pre_i24_i=((7792+($_sum27_pre_i_i<<2))|0);
   var $F4_0_i_i = $1207;var $_pre_phi_i25_i = $_pre_i24_i;label = 285; break;
  case 283: 
   var $_sum30_i_i=((($1205)+(2))|0);
   var $1215=((7792+($_sum30_i_i<<2))|0);
   var $1216=HEAP32[(($1215)>>2)];
   var $1217=$1216;
   var $1218=HEAP32[((((7768)|0))>>2)];
   var $1219=(($1217)>>>(0)) < (($1218)>>>(0));
   if ($1219) { label = 284; break; } else { var $F4_0_i_i = $1216;var $_pre_phi_i25_i = $1215;label = 285; break; }
  case 284: 
   _abort();
   throw "Reached an unreachable!";
  case 285: 
   var $_pre_phi_i25_i;
   var $F4_0_i_i;
   HEAP32[(($_pre_phi_i25_i)>>2)]=$1010;
   var $1222=(($F4_0_i_i+12)|0);
   HEAP32[(($1222)>>2)]=$1010;
   var $_sum28_i_i=((($_sum_i21_i)+(8))|0);
   var $1223=(($tbase_245_i+$_sum28_i_i)|0);
   var $1224=$1223;
   HEAP32[(($1224)>>2)]=$F4_0_i_i;
   var $_sum29_i_i=((($_sum_i21_i)+(12))|0);
   var $1225=(($tbase_245_i+$_sum29_i_i)|0);
   var $1226=$1225;
   HEAP32[(($1226)>>2)]=$1207;
   label = 303; break;
  case 286: 
   var $1228=$1009;
   var $1229=$qsize_0_i_i >>> 8;
   var $1230=(($1229)|(0))==0;
   if ($1230) { var $I7_0_i_i = 0;label = 289; break; } else { label = 287; break; }
  case 287: 
   var $1232=(($qsize_0_i_i)>>>(0)) > 16777215;
   if ($1232) { var $I7_0_i_i = 31;label = 289; break; } else { label = 288; break; }
  case 288: 
   var $1234=((($1229)+(1048320))|0);
   var $1235=$1234 >>> 16;
   var $1236=$1235 & 8;
   var $1237=$1229 << $1236;
   var $1238=((($1237)+(520192))|0);
   var $1239=$1238 >>> 16;
   var $1240=$1239 & 4;
   var $1241=$1240 | $1236;
   var $1242=$1237 << $1240;
   var $1243=((($1242)+(245760))|0);
   var $1244=$1243 >>> 16;
   var $1245=$1244 & 2;
   var $1246=$1241 | $1245;
   var $1247=(((14)-($1246))|0);
   var $1248=$1242 << $1245;
   var $1249=$1248 >>> 15;
   var $1250=((($1247)+($1249))|0);
   var $1251=$1250 << 1;
   var $1252=((($1250)+(7))|0);
   var $1253=$qsize_0_i_i >>> (($1252)>>>(0));
   var $1254=$1253 & 1;
   var $1255=$1254 | $1251;
   var $I7_0_i_i = $1255;label = 289; break;
  case 289: 
   var $I7_0_i_i;
   var $1257=((8056+($I7_0_i_i<<2))|0);
   var $_sum12_i26_i=((($_sum_i21_i)+(28))|0);
   var $1258=(($tbase_245_i+$_sum12_i26_i)|0);
   var $1259=$1258;
   HEAP32[(($1259)>>2)]=$I7_0_i_i;
   var $_sum13_i_i=((($_sum_i21_i)+(16))|0);
   var $1260=(($tbase_245_i+$_sum13_i_i)|0);
   var $_sum14_i_i=((($_sum_i21_i)+(20))|0);
   var $1261=(($tbase_245_i+$_sum14_i_i)|0);
   var $1262=$1261;
   HEAP32[(($1262)>>2)]=0;
   var $1263=$1260;
   HEAP32[(($1263)>>2)]=0;
   var $1264=HEAP32[((((7756)|0))>>2)];
   var $1265=1 << $I7_0_i_i;
   var $1266=$1264 & $1265;
   var $1267=(($1266)|(0))==0;
   if ($1267) { label = 290; break; } else { label = 291; break; }
  case 290: 
   var $1269=$1264 | $1265;
   HEAP32[((((7756)|0))>>2)]=$1269;
   HEAP32[(($1257)>>2)]=$1228;
   var $1270=$1257;
   var $_sum15_i_i=((($_sum_i21_i)+(24))|0);
   var $1271=(($tbase_245_i+$_sum15_i_i)|0);
   var $1272=$1271;
   HEAP32[(($1272)>>2)]=$1270;
   var $_sum16_i_i=((($_sum_i21_i)+(12))|0);
   var $1273=(($tbase_245_i+$_sum16_i_i)|0);
   var $1274=$1273;
   HEAP32[(($1274)>>2)]=$1228;
   var $_sum17_i_i=((($_sum_i21_i)+(8))|0);
   var $1275=(($tbase_245_i+$_sum17_i_i)|0);
   var $1276=$1275;
   HEAP32[(($1276)>>2)]=$1228;
   label = 303; break;
  case 291: 
   var $1278=HEAP32[(($1257)>>2)];
   var $1279=(($I7_0_i_i)|(0))==31;
   if ($1279) { var $1284 = 0;label = 293; break; } else { label = 292; break; }
  case 292: 
   var $1281=$I7_0_i_i >>> 1;
   var $1282=(((25)-($1281))|0);
   var $1284 = $1282;label = 293; break;
  case 293: 
   var $1284;
   var $1285=$qsize_0_i_i << $1284;
   var $K8_0_i_i = $1285;var $T_0_i27_i = $1278;label = 294; break;
  case 294: 
   var $T_0_i27_i;
   var $K8_0_i_i;
   var $1287=(($T_0_i27_i+4)|0);
   var $1288=HEAP32[(($1287)>>2)];
   var $1289=$1288 & -8;
   var $1290=(($1289)|(0))==(($qsize_0_i_i)|(0));
   if ($1290) { label = 299; break; } else { label = 295; break; }
  case 295: 
   var $1292=$K8_0_i_i >>> 31;
   var $1293=(($T_0_i27_i+16+($1292<<2))|0);
   var $1294=HEAP32[(($1293)>>2)];
   var $1295=(($1294)|(0))==0;
   var $1296=$K8_0_i_i << 1;
   if ($1295) { label = 296; break; } else { var $K8_0_i_i = $1296;var $T_0_i27_i = $1294;label = 294; break; }
  case 296: 
   var $1298=$1293;
   var $1299=HEAP32[((((7768)|0))>>2)];
   var $1300=(($1298)>>>(0)) < (($1299)>>>(0));
   if ($1300) { label = 298; break; } else { label = 297; break; }
  case 297: 
   HEAP32[(($1293)>>2)]=$1228;
   var $_sum24_i_i=((($_sum_i21_i)+(24))|0);
   var $1302=(($tbase_245_i+$_sum24_i_i)|0);
   var $1303=$1302;
   HEAP32[(($1303)>>2)]=$T_0_i27_i;
   var $_sum25_i_i=((($_sum_i21_i)+(12))|0);
   var $1304=(($tbase_245_i+$_sum25_i_i)|0);
   var $1305=$1304;
   HEAP32[(($1305)>>2)]=$1228;
   var $_sum26_i_i=((($_sum_i21_i)+(8))|0);
   var $1306=(($tbase_245_i+$_sum26_i_i)|0);
   var $1307=$1306;
   HEAP32[(($1307)>>2)]=$1228;
   label = 303; break;
  case 298: 
   _abort();
   throw "Reached an unreachable!";
  case 299: 
   var $1310=(($T_0_i27_i+8)|0);
   var $1311=HEAP32[(($1310)>>2)];
   var $1312=$T_0_i27_i;
   var $1313=HEAP32[((((7768)|0))>>2)];
   var $1314=(($1312)>>>(0)) < (($1313)>>>(0));
   if ($1314) { label = 302; break; } else { label = 300; break; }
  case 300: 
   var $1316=$1311;
   var $1317=(($1316)>>>(0)) < (($1313)>>>(0));
   if ($1317) { label = 302; break; } else { label = 301; break; }
  case 301: 
   var $1319=(($1311+12)|0);
   HEAP32[(($1319)>>2)]=$1228;
   HEAP32[(($1310)>>2)]=$1228;
   var $_sum21_i_i=((($_sum_i21_i)+(8))|0);
   var $1320=(($tbase_245_i+$_sum21_i_i)|0);
   var $1321=$1320;
   HEAP32[(($1321)>>2)]=$1311;
   var $_sum22_i_i=((($_sum_i21_i)+(12))|0);
   var $1322=(($tbase_245_i+$_sum22_i_i)|0);
   var $1323=$1322;
   HEAP32[(($1323)>>2)]=$T_0_i27_i;
   var $_sum23_i_i=((($_sum_i21_i)+(24))|0);
   var $1324=(($tbase_245_i+$_sum23_i_i)|0);
   var $1325=$1324;
   HEAP32[(($1325)>>2)]=0;
   label = 303; break;
  case 302: 
   _abort();
   throw "Reached an unreachable!";
  case 303: 
   var $_sum1819_i_i=$993 | 8;
   var $1326=(($tbase_245_i+$_sum1819_i_i)|0);
   var $mem_0 = $1326;label = 341; break;
  case 304: 
   var $1327=$890;
   var $sp_0_i_i_i = ((8200)|0);label = 305; break;
  case 305: 
   var $sp_0_i_i_i;
   var $1329=(($sp_0_i_i_i)|0);
   var $1330=HEAP32[(($1329)>>2)];
   var $1331=(($1330)>>>(0)) > (($1327)>>>(0));
   if ($1331) { label = 307; break; } else { label = 306; break; }
  case 306: 
   var $1333=(($sp_0_i_i_i+4)|0);
   var $1334=HEAP32[(($1333)>>2)];
   var $1335=(($1330+$1334)|0);
   var $1336=(($1335)>>>(0)) > (($1327)>>>(0));
   if ($1336) { label = 308; break; } else { label = 307; break; }
  case 307: 
   var $1338=(($sp_0_i_i_i+8)|0);
   var $1339=HEAP32[(($1338)>>2)];
   var $sp_0_i_i_i = $1339;label = 305; break;
  case 308: 
   var $_sum_i15_i=((($1334)-(47))|0);
   var $_sum1_i16_i=((($1334)-(39))|0);
   var $1340=(($1330+$_sum1_i16_i)|0);
   var $1341=$1340;
   var $1342=$1341 & 7;
   var $1343=(($1342)|(0))==0;
   if ($1343) { var $1348 = 0;label = 310; break; } else { label = 309; break; }
  case 309: 
   var $1345=(((-$1341))|0);
   var $1346=$1345 & 7;
   var $1348 = $1346;label = 310; break;
  case 310: 
   var $1348;
   var $_sum2_i17_i=((($_sum_i15_i)+($1348))|0);
   var $1349=(($1330+$_sum2_i17_i)|0);
   var $1350=(($890+16)|0);
   var $1351=$1350;
   var $1352=(($1349)>>>(0)) < (($1351)>>>(0));
   var $1353=$1352 ? $1327 : $1349;
   var $1354=(($1353+8)|0);
   var $1355=$1354;
   var $1356=((($tsize_244_i)-(40))|0);
   var $1357=(($tbase_245_i+8)|0);
   var $1358=$1357;
   var $1359=$1358 & 7;
   var $1360=(($1359)|(0))==0;
   if ($1360) { var $1364 = 0;label = 312; break; } else { label = 311; break; }
  case 311: 
   var $1362=(((-$1358))|0);
   var $1363=$1362 & 7;
   var $1364 = $1363;label = 312; break;
  case 312: 
   var $1364;
   var $1365=(($tbase_245_i+$1364)|0);
   var $1366=$1365;
   var $1367=((($1356)-($1364))|0);
   HEAP32[((((7776)|0))>>2)]=$1366;
   HEAP32[((((7764)|0))>>2)]=$1367;
   var $1368=$1367 | 1;
   var $_sum_i_i_i=((($1364)+(4))|0);
   var $1369=(($tbase_245_i+$_sum_i_i_i)|0);
   var $1370=$1369;
   HEAP32[(($1370)>>2)]=$1368;
   var $_sum2_i_i_i=((($tsize_244_i)-(36))|0);
   var $1371=(($tbase_245_i+$_sum2_i_i_i)|0);
   var $1372=$1371;
   HEAP32[(($1372)>>2)]=40;
   var $1373=HEAP32[((((7568)|0))>>2)];
   HEAP32[((((7780)|0))>>2)]=$1373;
   var $1374=(($1353+4)|0);
   var $1375=$1374;
   HEAP32[(($1375)>>2)]=27;
   assert(16 % 1 === 0);HEAP32[(($1354)>>2)]=HEAP32[(((((8200)|0)))>>2)];HEAP32[((($1354)+(4))>>2)]=HEAP32[((((((8200)|0)))+(4))>>2)];HEAP32[((($1354)+(8))>>2)]=HEAP32[((((((8200)|0)))+(8))>>2)];HEAP32[((($1354)+(12))>>2)]=HEAP32[((((((8200)|0)))+(12))>>2)];
   HEAP32[((((8200)|0))>>2)]=$tbase_245_i;
   HEAP32[((((8204)|0))>>2)]=$tsize_244_i;
   HEAP32[((((8212)|0))>>2)]=0;
   HEAP32[((((8208)|0))>>2)]=$1355;
   var $1376=(($1353+28)|0);
   var $1377=$1376;
   HEAP32[(($1377)>>2)]=7;
   var $1378=(($1353+32)|0);
   var $1379=(($1378)>>>(0)) < (($1335)>>>(0));
   if ($1379) { var $1380 = $1377;label = 313; break; } else { label = 314; break; }
  case 313: 
   var $1380;
   var $1381=(($1380+4)|0);
   HEAP32[(($1381)>>2)]=7;
   var $1382=(($1380+8)|0);
   var $1383=$1382;
   var $1384=(($1383)>>>(0)) < (($1335)>>>(0));
   if ($1384) { var $1380 = $1381;label = 313; break; } else { label = 314; break; }
  case 314: 
   var $1385=(($1353)|(0))==(($1327)|(0));
   if ($1385) { label = 338; break; } else { label = 315; break; }
  case 315: 
   var $1387=$1353;
   var $1388=$890;
   var $1389=((($1387)-($1388))|0);
   var $1390=(($1327+$1389)|0);
   var $_sum3_i_i=((($1389)+(4))|0);
   var $1391=(($1327+$_sum3_i_i)|0);
   var $1392=$1391;
   var $1393=HEAP32[(($1392)>>2)];
   var $1394=$1393 & -2;
   HEAP32[(($1392)>>2)]=$1394;
   var $1395=$1389 | 1;
   var $1396=(($890+4)|0);
   HEAP32[(($1396)>>2)]=$1395;
   var $1397=$1390;
   HEAP32[(($1397)>>2)]=$1389;
   var $1398=$1389 >>> 3;
   var $1399=(($1389)>>>(0)) < 256;
   if ($1399) { label = 316; break; } else { label = 321; break; }
  case 316: 
   var $1401=$1398 << 1;
   var $1402=((7792+($1401<<2))|0);
   var $1403=$1402;
   var $1404=HEAP32[((((7752)|0))>>2)];
   var $1405=1 << $1398;
   var $1406=$1404 & $1405;
   var $1407=(($1406)|(0))==0;
   if ($1407) { label = 317; break; } else { label = 318; break; }
  case 317: 
   var $1409=$1404 | $1405;
   HEAP32[((((7752)|0))>>2)]=$1409;
   var $_sum11_pre_i_i=((($1401)+(2))|0);
   var $_pre_i_i=((7792+($_sum11_pre_i_i<<2))|0);
   var $F_0_i_i = $1403;var $_pre_phi_i_i = $_pre_i_i;label = 320; break;
  case 318: 
   var $_sum12_i_i=((($1401)+(2))|0);
   var $1411=((7792+($_sum12_i_i<<2))|0);
   var $1412=HEAP32[(($1411)>>2)];
   var $1413=$1412;
   var $1414=HEAP32[((((7768)|0))>>2)];
   var $1415=(($1413)>>>(0)) < (($1414)>>>(0));
   if ($1415) { label = 319; break; } else { var $F_0_i_i = $1412;var $_pre_phi_i_i = $1411;label = 320; break; }
  case 319: 
   _abort();
   throw "Reached an unreachable!";
  case 320: 
   var $_pre_phi_i_i;
   var $F_0_i_i;
   HEAP32[(($_pre_phi_i_i)>>2)]=$890;
   var $1418=(($F_0_i_i+12)|0);
   HEAP32[(($1418)>>2)]=$890;
   var $1419=(($890+8)|0);
   HEAP32[(($1419)>>2)]=$F_0_i_i;
   var $1420=(($890+12)|0);
   HEAP32[(($1420)>>2)]=$1403;
   label = 338; break;
  case 321: 
   var $1422=$890;
   var $1423=$1389 >>> 8;
   var $1424=(($1423)|(0))==0;
   if ($1424) { var $I1_0_i_i = 0;label = 324; break; } else { label = 322; break; }
  case 322: 
   var $1426=(($1389)>>>(0)) > 16777215;
   if ($1426) { var $I1_0_i_i = 31;label = 324; break; } else { label = 323; break; }
  case 323: 
   var $1428=((($1423)+(1048320))|0);
   var $1429=$1428 >>> 16;
   var $1430=$1429 & 8;
   var $1431=$1423 << $1430;
   var $1432=((($1431)+(520192))|0);
   var $1433=$1432 >>> 16;
   var $1434=$1433 & 4;
   var $1435=$1434 | $1430;
   var $1436=$1431 << $1434;
   var $1437=((($1436)+(245760))|0);
   var $1438=$1437 >>> 16;
   var $1439=$1438 & 2;
   var $1440=$1435 | $1439;
   var $1441=(((14)-($1440))|0);
   var $1442=$1436 << $1439;
   var $1443=$1442 >>> 15;
   var $1444=((($1441)+($1443))|0);
   var $1445=$1444 << 1;
   var $1446=((($1444)+(7))|0);
   var $1447=$1389 >>> (($1446)>>>(0));
   var $1448=$1447 & 1;
   var $1449=$1448 | $1445;
   var $I1_0_i_i = $1449;label = 324; break;
  case 324: 
   var $I1_0_i_i;
   var $1451=((8056+($I1_0_i_i<<2))|0);
   var $1452=(($890+28)|0);
   var $I1_0_c_i_i=$I1_0_i_i;
   HEAP32[(($1452)>>2)]=$I1_0_c_i_i;
   var $1453=(($890+20)|0);
   HEAP32[(($1453)>>2)]=0;
   var $1454=(($890+16)|0);
   HEAP32[(($1454)>>2)]=0;
   var $1455=HEAP32[((((7756)|0))>>2)];
   var $1456=1 << $I1_0_i_i;
   var $1457=$1455 & $1456;
   var $1458=(($1457)|(0))==0;
   if ($1458) { label = 325; break; } else { label = 326; break; }
  case 325: 
   var $1460=$1455 | $1456;
   HEAP32[((((7756)|0))>>2)]=$1460;
   HEAP32[(($1451)>>2)]=$1422;
   var $1461=(($890+24)|0);
   var $_c_i_i=$1451;
   HEAP32[(($1461)>>2)]=$_c_i_i;
   var $1462=(($890+12)|0);
   HEAP32[(($1462)>>2)]=$890;
   var $1463=(($890+8)|0);
   HEAP32[(($1463)>>2)]=$890;
   label = 338; break;
  case 326: 
   var $1465=HEAP32[(($1451)>>2)];
   var $1466=(($I1_0_i_i)|(0))==31;
   if ($1466) { var $1471 = 0;label = 328; break; } else { label = 327; break; }
  case 327: 
   var $1468=$I1_0_i_i >>> 1;
   var $1469=(((25)-($1468))|0);
   var $1471 = $1469;label = 328; break;
  case 328: 
   var $1471;
   var $1472=$1389 << $1471;
   var $K2_0_i_i = $1472;var $T_0_i_i = $1465;label = 329; break;
  case 329: 
   var $T_0_i_i;
   var $K2_0_i_i;
   var $1474=(($T_0_i_i+4)|0);
   var $1475=HEAP32[(($1474)>>2)];
   var $1476=$1475 & -8;
   var $1477=(($1476)|(0))==(($1389)|(0));
   if ($1477) { label = 334; break; } else { label = 330; break; }
  case 330: 
   var $1479=$K2_0_i_i >>> 31;
   var $1480=(($T_0_i_i+16+($1479<<2))|0);
   var $1481=HEAP32[(($1480)>>2)];
   var $1482=(($1481)|(0))==0;
   var $1483=$K2_0_i_i << 1;
   if ($1482) { label = 331; break; } else { var $K2_0_i_i = $1483;var $T_0_i_i = $1481;label = 329; break; }
  case 331: 
   var $1485=$1480;
   var $1486=HEAP32[((((7768)|0))>>2)];
   var $1487=(($1485)>>>(0)) < (($1486)>>>(0));
   if ($1487) { label = 333; break; } else { label = 332; break; }
  case 332: 
   HEAP32[(($1480)>>2)]=$1422;
   var $1489=(($890+24)|0);
   var $T_0_c8_i_i=$T_0_i_i;
   HEAP32[(($1489)>>2)]=$T_0_c8_i_i;
   var $1490=(($890+12)|0);
   HEAP32[(($1490)>>2)]=$890;
   var $1491=(($890+8)|0);
   HEAP32[(($1491)>>2)]=$890;
   label = 338; break;
  case 333: 
   _abort();
   throw "Reached an unreachable!";
  case 334: 
   var $1494=(($T_0_i_i+8)|0);
   var $1495=HEAP32[(($1494)>>2)];
   var $1496=$T_0_i_i;
   var $1497=HEAP32[((((7768)|0))>>2)];
   var $1498=(($1496)>>>(0)) < (($1497)>>>(0));
   if ($1498) { label = 337; break; } else { label = 335; break; }
  case 335: 
   var $1500=$1495;
   var $1501=(($1500)>>>(0)) < (($1497)>>>(0));
   if ($1501) { label = 337; break; } else { label = 336; break; }
  case 336: 
   var $1503=(($1495+12)|0);
   HEAP32[(($1503)>>2)]=$1422;
   HEAP32[(($1494)>>2)]=$1422;
   var $1504=(($890+8)|0);
   var $_c7_i_i=$1495;
   HEAP32[(($1504)>>2)]=$_c7_i_i;
   var $1505=(($890+12)|0);
   var $T_0_c_i_i=$T_0_i_i;
   HEAP32[(($1505)>>2)]=$T_0_c_i_i;
   var $1506=(($890+24)|0);
   HEAP32[(($1506)>>2)]=0;
   label = 338; break;
  case 337: 
   _abort();
   throw "Reached an unreachable!";
  case 338: 
   var $1507=HEAP32[((((7764)|0))>>2)];
   var $1508=(($1507)>>>(0)) > (($nb_0)>>>(0));
   if ($1508) { label = 339; break; } else { label = 340; break; }
  case 339: 
   var $1510=((($1507)-($nb_0))|0);
   HEAP32[((((7764)|0))>>2)]=$1510;
   var $1511=HEAP32[((((7776)|0))>>2)];
   var $1512=$1511;
   var $1513=(($1512+$nb_0)|0);
   var $1514=$1513;
   HEAP32[((((7776)|0))>>2)]=$1514;
   var $1515=$1510 | 1;
   var $_sum_i134=((($nb_0)+(4))|0);
   var $1516=(($1512+$_sum_i134)|0);
   var $1517=$1516;
   HEAP32[(($1517)>>2)]=$1515;
   var $1518=$nb_0 | 3;
   var $1519=(($1511+4)|0);
   HEAP32[(($1519)>>2)]=$1518;
   var $1520=(($1511+8)|0);
   var $1521=$1520;
   var $mem_0 = $1521;label = 341; break;
  case 340: 
   var $1522=___errno_location();
   HEAP32[(($1522)>>2)]=12;
   var $mem_0 = 0;label = 341; break;
  case 341: 
   var $mem_0;
   return $mem_0;
  default: assert(0, "bad label: " + label);
 }
}
Module["_malloc"] = _malloc;
function __ZNSt9bad_allocD2Ev($this) {
 var label = 0;
 return;
}
function __ZNKSt9bad_alloc4whatEv($this) {
 var label = 0;
 return ((3304)|0);
}
function __ZNSt9bad_allocD0Ev($this) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($this)|(0))==0;
   if ($1) { label = 3; break; } else { label = 2; break; }
  case 2: 
   var $3=$this;
   _free($3);
   label = 3; break;
  case 3: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
function _free($mem) {
 var label = 0;
 label = 1; 
 while(1) switch(label) {
  case 1: 
   var $1=(($mem)|(0))==0;
   if ($1) { label = 140; break; } else { label = 2; break; }
  case 2: 
   var $3=((($mem)-(8))|0);
   var $4=$3;
   var $5=HEAP32[((((7768)|0))>>2)];
   var $6=(($3)>>>(0)) < (($5)>>>(0));
   if ($6) { label = 139; break; } else { label = 3; break; }
  case 3: 
   var $8=((($mem)-(4))|0);
   var $9=$8;
   var $10=HEAP32[(($9)>>2)];
   var $11=$10 & 3;
   var $12=(($11)|(0))==1;
   if ($12) { label = 139; break; } else { label = 4; break; }
  case 4: 
   var $14=$10 & -8;
   var $_sum=((($14)-(8))|0);
   var $15=(($mem+$_sum)|0);
   var $16=$15;
   var $17=$10 & 1;
   var $18=(($17)|(0))==0;
   if ($18) { label = 5; break; } else { var $p_0 = $4;var $psize_0 = $14;label = 56; break; }
  case 5: 
   var $20=$3;
   var $21=HEAP32[(($20)>>2)];
   var $22=(($11)|(0))==0;
   if ($22) { label = 140; break; } else { label = 6; break; }
  case 6: 
   var $_sum232=(((-8)-($21))|0);
   var $24=(($mem+$_sum232)|0);
   var $25=$24;
   var $26=((($21)+($14))|0);
   var $27=(($24)>>>(0)) < (($5)>>>(0));
   if ($27) { label = 139; break; } else { label = 7; break; }
  case 7: 
   var $29=HEAP32[((((7772)|0))>>2)];
   var $30=(($25)|(0))==(($29)|(0));
   if ($30) { label = 54; break; } else { label = 8; break; }
  case 8: 
   var $32=$21 >>> 3;
   var $33=(($21)>>>(0)) < 256;
   if ($33) { label = 9; break; } else { label = 21; break; }
  case 9: 
   var $_sum276=((($_sum232)+(8))|0);
   var $35=(($mem+$_sum276)|0);
   var $36=$35;
   var $37=HEAP32[(($36)>>2)];
   var $_sum277=((($_sum232)+(12))|0);
   var $38=(($mem+$_sum277)|0);
   var $39=$38;
   var $40=HEAP32[(($39)>>2)];
   var $41=$32 << 1;
   var $42=((7792+($41<<2))|0);
   var $43=$42;
   var $44=(($37)|(0))==(($43)|(0));
   if ($44) { label = 12; break; } else { label = 10; break; }
  case 10: 
   var $46=$37;
   var $47=(($46)>>>(0)) < (($5)>>>(0));
   if ($47) { label = 20; break; } else { label = 11; break; }
  case 11: 
   var $49=(($37+12)|0);
   var $50=HEAP32[(($49)>>2)];
   var $51=(($50)|(0))==(($25)|(0));
   if ($51) { label = 12; break; } else { label = 20; break; }
  case 12: 
   var $52=(($40)|(0))==(($37)|(0));
   if ($52) { label = 13; break; } else { label = 14; break; }
  case 13: 
   var $54=1 << $32;
   var $55=$54 ^ -1;
   var $56=HEAP32[((((7752)|0))>>2)];
   var $57=$56 & $55;
   HEAP32[((((7752)|0))>>2)]=$57;
   var $p_0 = $25;var $psize_0 = $26;label = 56; break;
  case 14: 
   var $59=(($40)|(0))==(($43)|(0));
   if ($59) { label = 15; break; } else { label = 16; break; }
  case 15: 
   var $_pre305=(($40+8)|0);
   var $_pre_phi306 = $_pre305;label = 18; break;
  case 16: 
   var $61=$40;
   var $62=(($61)>>>(0)) < (($5)>>>(0));
   if ($62) { label = 19; break; } else { label = 17; break; }
  case 17: 
   var $64=(($40+8)|0);
   var $65=HEAP32[(($64)>>2)];
   var $66=(($65)|(0))==(($25)|(0));
   if ($66) { var $_pre_phi306 = $64;label = 18; break; } else { label = 19; break; }
  case 18: 
   var $_pre_phi306;
   var $67=(($37+12)|0);
   HEAP32[(($67)>>2)]=$40;
   HEAP32[(($_pre_phi306)>>2)]=$37;
   var $p_0 = $25;var $psize_0 = $26;label = 56; break;
  case 19: 
   _abort();
   throw "Reached an unreachable!";
  case 20: 
   _abort();
   throw "Reached an unreachable!";
  case 21: 
   var $69=$24;
   var $_sum266=((($_sum232)+(24))|0);
   var $70=(($mem+$_sum266)|0);
   var $71=$70;
   var $72=HEAP32[(($71)>>2)];
   var $_sum267=((($_sum232)+(12))|0);
   var $73=(($mem+$_sum267)|0);
   var $74=$73;
   var $75=HEAP32[(($74)>>2)];
   var $76=(($75)|(0))==(($69)|(0));
   if ($76) { label = 27; break; } else { label = 22; break; }
  case 22: 
   var $_sum273=((($_sum232)+(8))|0);
   var $78=(($mem+$_sum273)|0);
   var $79=$78;
   var $80=HEAP32[(($79)>>2)];
   var $81=$80;
   var $82=(($81)>>>(0)) < (($5)>>>(0));
   if ($82) { label = 26; break; } else { label = 23; break; }
  case 23: 
   var $84=(($80+12)|0);
   var $85=HEAP32[(($84)>>2)];
   var $86=(($85)|(0))==(($69)|(0));
   if ($86) { label = 24; break; } else { label = 26; break; }
  case 24: 
   var $88=(($75+8)|0);
   var $89=HEAP32[(($88)>>2)];
   var $90=(($89)|(0))==(($69)|(0));
   if ($90) { label = 25; break; } else { label = 26; break; }
  case 25: 
   HEAP32[(($84)>>2)]=$75;
   HEAP32[(($88)>>2)]=$80;
   var $R_1 = $75;label = 34; break;
  case 26: 
   _abort();
   throw "Reached an unreachable!";
  case 27: 
   var $_sum269=((($_sum232)+(20))|0);
   var $93=(($mem+$_sum269)|0);
   var $94=$93;
   var $95=HEAP32[(($94)>>2)];
   var $96=(($95)|(0))==0;
   if ($96) { label = 28; break; } else { var $R_0 = $95;var $RP_0 = $94;label = 29; break; }
  case 28: 
   var $_sum268=((($_sum232)+(16))|0);
   var $98=(($mem+$_sum268)|0);
   var $99=$98;
   var $100=HEAP32[(($99)>>2)];
   var $101=(($100)|(0))==0;
   if ($101) { var $R_1 = 0;label = 34; break; } else { var $R_0 = $100;var $RP_0 = $99;label = 29; break; }
  case 29: 
   var $RP_0;
   var $R_0;
   var $102=(($R_0+20)|0);
   var $103=HEAP32[(($102)>>2)];
   var $104=(($103)|(0))==0;
   if ($104) { label = 30; break; } else { var $R_0 = $103;var $RP_0 = $102;label = 29; break; }
  case 30: 
   var $106=(($R_0+16)|0);
   var $107=HEAP32[(($106)>>2)];
   var $108=(($107)|(0))==0;
   if ($108) { label = 31; break; } else { var $R_0 = $107;var $RP_0 = $106;label = 29; break; }
  case 31: 
   var $110=$RP_0;
   var $111=(($110)>>>(0)) < (($5)>>>(0));
   if ($111) { label = 33; break; } else { label = 32; break; }
  case 32: 
   HEAP32[(($RP_0)>>2)]=0;
   var $R_1 = $R_0;label = 34; break;
  case 33: 
   _abort();
   throw "Reached an unreachable!";
  case 34: 
   var $R_1;
   var $115=(($72)|(0))==0;
   if ($115) { var $p_0 = $25;var $psize_0 = $26;label = 56; break; } else { label = 35; break; }
  case 35: 
   var $_sum270=((($_sum232)+(28))|0);
   var $117=(($mem+$_sum270)|0);
   var $118=$117;
   var $119=HEAP32[(($118)>>2)];
   var $120=((8056+($119<<2))|0);
   var $121=HEAP32[(($120)>>2)];
   var $122=(($69)|(0))==(($121)|(0));
   if ($122) { label = 36; break; } else { label = 38; break; }
  case 36: 
   HEAP32[(($120)>>2)]=$R_1;
   var $cond=(($R_1)|(0))==0;
   if ($cond) { label = 37; break; } else { label = 44; break; }
  case 37: 
   var $124=HEAP32[(($118)>>2)];
   var $125=1 << $124;
   var $126=$125 ^ -1;
   var $127=HEAP32[((((7756)|0))>>2)];
   var $128=$127 & $126;
   HEAP32[((((7756)|0))>>2)]=$128;
   var $p_0 = $25;var $psize_0 = $26;label = 56; break;
  case 38: 
   var $130=$72;
   var $131=HEAP32[((((7768)|0))>>2)];
   var $132=(($130)>>>(0)) < (($131)>>>(0));
   if ($132) { label = 42; break; } else { label = 39; break; }
  case 39: 
   var $134=(($72+16)|0);
   var $135=HEAP32[(($134)>>2)];
   var $136=(($135)|(0))==(($69)|(0));
   if ($136) { label = 40; break; } else { label = 41; break; }
  case 40: 
   HEAP32[(($134)>>2)]=$R_1;
   label = 43; break;
  case 41: 
   var $139=(($72+20)|0);
   HEAP32[(($139)>>2)]=$R_1;
   label = 43; break;
  case 42: 
   _abort();
   throw "Reached an unreachable!";
  case 43: 
   var $142=(($R_1)|(0))==0;
   if ($142) { var $p_0 = $25;var $psize_0 = $26;label = 56; break; } else { label = 44; break; }
  case 44: 
   var $144=$R_1;
   var $145=HEAP32[((((7768)|0))>>2)];
   var $146=(($144)>>>(0)) < (($145)>>>(0));
   if ($146) { label = 53; break; } else { label = 45; break; }
  case 45: 
   var $148=(($R_1+24)|0);
   HEAP32[(($148)>>2)]=$72;
   var $_sum271=((($_sum232)+(16))|0);
   var $149=(($mem+$_sum271)|0);
   var $150=$149;
   var $151=HEAP32[(($150)>>2)];
   var $152=(($151)|(0))==0;
   if ($152) { label = 49; break; } else { label = 46; break; }
  case 46: 
   var $154=$151;
   var $155=HEAP32[((((7768)|0))>>2)];
   var $156=(($154)>>>(0)) < (($155)>>>(0));
   if ($156) { label = 48; break; } else { label = 47; break; }
  case 47: 
   var $158=(($R_1+16)|0);
   HEAP32[(($158)>>2)]=$151;
   var $159=(($151+24)|0);
   HEAP32[(($159)>>2)]=$R_1;
   label = 49; break;
  case 48: 
   _abort();
   throw "Reached an unreachable!";
  case 49: 
   var $_sum272=((($_sum232)+(20))|0);
   var $162=(($mem+$_sum272)|0);
   var $163=$162;
   var $164=HEAP32[(($163)>>2)];
   var $165=(($164)|(0))==0;
   if ($165) { var $p_0 = $25;var $psize_0 = $26;label = 56; break; } else { label = 50; break; }
  case 50: 
   var $167=$164;
   var $168=HEAP32[((((7768)|0))>>2)];
   var $169=(($167)>>>(0)) < (($168)>>>(0));
   if ($169) { label = 52; break; } else { label = 51; break; }
  case 51: 
   var $171=(($R_1+20)|0);
   HEAP32[(($171)>>2)]=$164;
   var $172=(($164+24)|0);
   HEAP32[(($172)>>2)]=$R_1;
   var $p_0 = $25;var $psize_0 = $26;label = 56; break;
  case 52: 
   _abort();
   throw "Reached an unreachable!";
  case 53: 
   _abort();
   throw "Reached an unreachable!";
  case 54: 
   var $_sum233=((($14)-(4))|0);
   var $176=(($mem+$_sum233)|0);
   var $177=$176;
   var $178=HEAP32[(($177)>>2)];
   var $179=$178 & 3;
   var $180=(($179)|(0))==3;
   if ($180) { label = 55; break; } else { var $p_0 = $25;var $psize_0 = $26;label = 56; break; }
  case 55: 
   HEAP32[((((7760)|0))>>2)]=$26;
   var $182=HEAP32[(($177)>>2)];
   var $183=$182 & -2;
   HEAP32[(($177)>>2)]=$183;
   var $184=$26 | 1;
   var $_sum264=((($_sum232)+(4))|0);
   var $185=(($mem+$_sum264)|0);
   var $186=$185;
   HEAP32[(($186)>>2)]=$184;
   var $187=$15;
   HEAP32[(($187)>>2)]=$26;
   label = 140; break;
  case 56: 
   var $psize_0;
   var $p_0;
   var $189=$p_0;
   var $190=(($189)>>>(0)) < (($15)>>>(0));
   if ($190) { label = 57; break; } else { label = 139; break; }
  case 57: 
   var $_sum263=((($14)-(4))|0);
   var $192=(($mem+$_sum263)|0);
   var $193=$192;
   var $194=HEAP32[(($193)>>2)];
   var $195=$194 & 1;
   var $phitmp=(($195)|(0))==0;
   if ($phitmp) { label = 139; break; } else { label = 58; break; }
  case 58: 
   var $197=$194 & 2;
   var $198=(($197)|(0))==0;
   if ($198) { label = 59; break; } else { label = 112; break; }
  case 59: 
   var $200=HEAP32[((((7776)|0))>>2)];
   var $201=(($16)|(0))==(($200)|(0));
   if ($201) { label = 60; break; } else { label = 62; break; }
  case 60: 
   var $203=HEAP32[((((7764)|0))>>2)];
   var $204=((($203)+($psize_0))|0);
   HEAP32[((((7764)|0))>>2)]=$204;
   HEAP32[((((7776)|0))>>2)]=$p_0;
   var $205=$204 | 1;
   var $206=(($p_0+4)|0);
   HEAP32[(($206)>>2)]=$205;
   var $207=HEAP32[((((7772)|0))>>2)];
   var $208=(($p_0)|(0))==(($207)|(0));
   if ($208) { label = 61; break; } else { label = 140; break; }
  case 61: 
   HEAP32[((((7772)|0))>>2)]=0;
   HEAP32[((((7760)|0))>>2)]=0;
   label = 140; break;
  case 62: 
   var $211=HEAP32[((((7772)|0))>>2)];
   var $212=(($16)|(0))==(($211)|(0));
   if ($212) { label = 63; break; } else { label = 64; break; }
  case 63: 
   var $214=HEAP32[((((7760)|0))>>2)];
   var $215=((($214)+($psize_0))|0);
   HEAP32[((((7760)|0))>>2)]=$215;
   HEAP32[((((7772)|0))>>2)]=$p_0;
   var $216=$215 | 1;
   var $217=(($p_0+4)|0);
   HEAP32[(($217)>>2)]=$216;
   var $218=(($189+$215)|0);
   var $219=$218;
   HEAP32[(($219)>>2)]=$215;
   label = 140; break;
  case 64: 
   var $221=$194 & -8;
   var $222=((($221)+($psize_0))|0);
   var $223=$194 >>> 3;
   var $224=(($194)>>>(0)) < 256;
   if ($224) { label = 65; break; } else { label = 77; break; }
  case 65: 
   var $226=(($mem+$14)|0);
   var $227=$226;
   var $228=HEAP32[(($227)>>2)];
   var $_sum257258=$14 | 4;
   var $229=(($mem+$_sum257258)|0);
   var $230=$229;
   var $231=HEAP32[(($230)>>2)];
   var $232=$223 << 1;
   var $233=((7792+($232<<2))|0);
   var $234=$233;
   var $235=(($228)|(0))==(($234)|(0));
   if ($235) { label = 68; break; } else { label = 66; break; }
  case 66: 
   var $237=$228;
   var $238=HEAP32[((((7768)|0))>>2)];
   var $239=(($237)>>>(0)) < (($238)>>>(0));
   if ($239) { label = 76; break; } else { label = 67; break; }
  case 67: 
   var $241=(($228+12)|0);
   var $242=HEAP32[(($241)>>2)];
   var $243=(($242)|(0))==(($16)|(0));
   if ($243) { label = 68; break; } else { label = 76; break; }
  case 68: 
   var $244=(($231)|(0))==(($228)|(0));
   if ($244) { label = 69; break; } else { label = 70; break; }
  case 69: 
   var $246=1 << $223;
   var $247=$246 ^ -1;
   var $248=HEAP32[((((7752)|0))>>2)];
   var $249=$248 & $247;
   HEAP32[((((7752)|0))>>2)]=$249;
   label = 110; break;
  case 70: 
   var $251=(($231)|(0))==(($234)|(0));
   if ($251) { label = 71; break; } else { label = 72; break; }
  case 71: 
   var $_pre303=(($231+8)|0);
   var $_pre_phi304 = $_pre303;label = 74; break;
  case 72: 
   var $253=$231;
   var $254=HEAP32[((((7768)|0))>>2)];
   var $255=(($253)>>>(0)) < (($254)>>>(0));
   if ($255) { label = 75; break; } else { label = 73; break; }
  case 73: 
   var $257=(($231+8)|0);
   var $258=HEAP32[(($257)>>2)];
   var $259=(($258)|(0))==(($16)|(0));
   if ($259) { var $_pre_phi304 = $257;label = 74; break; } else { label = 75; break; }
  case 74: 
   var $_pre_phi304;
   var $260=(($228+12)|0);
   HEAP32[(($260)>>2)]=$231;
   HEAP32[(($_pre_phi304)>>2)]=$228;
   label = 110; break;
  case 75: 
   _abort();
   throw "Reached an unreachable!";
  case 76: 
   _abort();
   throw "Reached an unreachable!";
  case 77: 
   var $262=$15;
   var $_sum235=((($14)+(16))|0);
   var $263=(($mem+$_sum235)|0);
   var $264=$263;
   var $265=HEAP32[(($264)>>2)];
   var $_sum236237=$14 | 4;
   var $266=(($mem+$_sum236237)|0);
   var $267=$266;
   var $268=HEAP32[(($267)>>2)];
   var $269=(($268)|(0))==(($262)|(0));
   if ($269) { label = 83; break; } else { label = 78; break; }
  case 78: 
   var $271=(($mem+$14)|0);
   var $272=$271;
   var $273=HEAP32[(($272)>>2)];
   var $274=$273;
   var $275=HEAP32[((((7768)|0))>>2)];
   var $276=(($274)>>>(0)) < (($275)>>>(0));
   if ($276) { label = 82; break; } else { label = 79; break; }
  case 79: 
   var $278=(($273+12)|0);
   var $279=HEAP32[(($278)>>2)];
   var $280=(($279)|(0))==(($262)|(0));
   if ($280) { label = 80; break; } else { label = 82; break; }
  case 80: 
   var $282=(($268+8)|0);
   var $283=HEAP32[(($282)>>2)];
   var $284=(($283)|(0))==(($262)|(0));
   if ($284) { label = 81; break; } else { label = 82; break; }
  case 81: 
   HEAP32[(($278)>>2)]=$268;
   HEAP32[(($282)>>2)]=$273;
   var $R7_1 = $268;label = 90; break;
  case 82: 
   _abort();
   throw "Reached an unreachable!";
  case 83: 
   var $_sum239=((($14)+(12))|0);
   var $287=(($mem+$_sum239)|0);
   var $288=$287;
   var $289=HEAP32[(($288)>>2)];
   var $290=(($289)|(0))==0;
   if ($290) { label = 84; break; } else { var $R7_0 = $289;var $RP9_0 = $288;label = 85; break; }
  case 84: 
   var $_sum238=((($14)+(8))|0);
   var $292=(($mem+$_sum238)|0);
   var $293=$292;
   var $294=HEAP32[(($293)>>2)];
   var $295=(($294)|(0))==0;
   if ($295) { var $R7_1 = 0;label = 90; break; } else { var $R7_0 = $294;var $RP9_0 = $293;label = 85; break; }
  case 85: 
   var $RP9_0;
   var $R7_0;
   var $296=(($R7_0+20)|0);
   var $297=HEAP32[(($296)>>2)];
   var $298=(($297)|(0))==0;
   if ($298) { label = 86; break; } else { var $R7_0 = $297;var $RP9_0 = $296;label = 85; break; }
  case 86: 
   var $300=(($R7_0+16)|0);
   var $301=HEAP32[(($300)>>2)];
   var $302=(($301)|(0))==0;
   if ($302) { label = 87; break; } else { var $R7_0 = $301;var $RP9_0 = $300;label = 85; break; }
  case 87: 
   var $304=$RP9_0;
   var $305=HEAP32[((((7768)|0))>>2)];
   var $306=(($304)>>>(0)) < (($305)>>>(0));
   if ($306) { label = 89; break; } else { label = 88; break; }
  case 88: 
   HEAP32[(($RP9_0)>>2)]=0;
   var $R7_1 = $R7_0;label = 90; break;
  case 89: 
   _abort();
   throw "Reached an unreachable!";
  case 90: 
   var $R7_1;
   var $310=(($265)|(0))==0;
   if ($310) { label = 110; break; } else { label = 91; break; }
  case 91: 
   var $_sum250=((($14)+(20))|0);
   var $312=(($mem+$_sum250)|0);
   var $313=$312;
   var $314=HEAP32[(($313)>>2)];
   var $315=((8056+($314<<2))|0);
   var $316=HEAP32[(($315)>>2)];
   var $317=(($262)|(0))==(($316)|(0));
   if ($317) { label = 92; break; } else { label = 94; break; }
  case 92: 
   HEAP32[(($315)>>2)]=$R7_1;
   var $cond298=(($R7_1)|(0))==0;
   if ($cond298) { label = 93; break; } else { label = 100; break; }
  case 93: 
   var $319=HEAP32[(($313)>>2)];
   var $320=1 << $319;
   var $321=$320 ^ -1;
   var $322=HEAP32[((((7756)|0))>>2)];
   var $323=$322 & $321;
   HEAP32[((((7756)|0))>>2)]=$323;
   label = 110; break;
  case 94: 
   var $325=$265;
   var $326=HEAP32[((((7768)|0))>>2)];
   var $327=(($325)>>>(0)) < (($326)>>>(0));
   if ($327) { label = 98; break; } else { label = 95; break; }
  case 95: 
   var $329=(($265+16)|0);
   var $330=HEAP32[(($329)>>2)];
   var $331=(($330)|(0))==(($262)|(0));
   if ($331) { label = 96; break; } else { label = 97; break; }
  case 96: 
   HEAP32[(($329)>>2)]=$R7_1;
   label = 99; break;
  case 97: 
   var $334=(($265+20)|0);
   HEAP32[(($334)>>2)]=$R7_1;
   label = 99; break;
  case 98: 
   _abort();
   throw "Reached an unreachable!";
  case 99: 
   var $337=(($R7_1)|(0))==0;
   if ($337) { label = 110; break; } else { label = 100; break; }
  case 100: 
   var $339=$R7_1;
   var $340=HEAP32[((((7768)|0))>>2)];
   var $341=(($339)>>>(0)) < (($340)>>>(0));
   if ($341) { label = 109; break; } else { label = 101; break; }
  case 101: 
   var $343=(($R7_1+24)|0);
   HEAP32[(($343)>>2)]=$265;
   var $_sum251=((($14)+(8))|0);
   var $344=(($mem+$_sum251)|0);
   var $345=$344;
   var $346=HEAP32[(($345)>>2)];
   var $347=(($346)|(0))==0;
   if ($347) { label = 105; break; } else { label = 102; break; }
  case 102: 
   var $349=$346;
   var $350=HEAP32[((((7768)|0))>>2)];
   var $351=(($349)>>>(0)) < (($350)>>>(0));
   if ($351) { label = 104; break; } else { label = 103; break; }
  case 103: 
   var $353=(($R7_1+16)|0);
   HEAP32[(($353)>>2)]=$346;
   var $354=(($346+24)|0);
   HEAP32[(($354)>>2)]=$R7_1;
   label = 105; break;
  case 104: 
   _abort();
   throw "Reached an unreachable!";
  case 105: 
   var $_sum252=((($14)+(12))|0);
   var $357=(($mem+$_sum252)|0);
   var $358=$357;
   var $359=HEAP32[(($358)>>2)];
   var $360=(($359)|(0))==0;
   if ($360) { label = 110; break; } else { label = 106; break; }
  case 106: 
   var $362=$359;
   var $363=HEAP32[((((7768)|0))>>2)];
   var $364=(($362)>>>(0)) < (($363)>>>(0));
   if ($364) { label = 108; break; } else { label = 107; break; }
  case 107: 
   var $366=(($R7_1+20)|0);
   HEAP32[(($366)>>2)]=$359;
   var $367=(($359+24)|0);
   HEAP32[(($367)>>2)]=$R7_1;
   label = 110; break;
  case 108: 
   _abort();
   throw "Reached an unreachable!";
  case 109: 
   _abort();
   throw "Reached an unreachable!";
  case 110: 
   var $371=$222 | 1;
   var $372=(($p_0+4)|0);
   HEAP32[(($372)>>2)]=$371;
   var $373=(($189+$222)|0);
   var $374=$373;
   HEAP32[(($374)>>2)]=$222;
   var $375=HEAP32[((((7772)|0))>>2)];
   var $376=(($p_0)|(0))==(($375)|(0));
   if ($376) { label = 111; break; } else { var $psize_1 = $222;label = 113; break; }
  case 111: 
   HEAP32[((((7760)|0))>>2)]=$222;
   label = 140; break;
  case 112: 
   var $379=$194 & -2;
   HEAP32[(($193)>>2)]=$379;
   var $380=$psize_0 | 1;
   var $381=(($p_0+4)|0);
   HEAP32[(($381)>>2)]=$380;
   var $382=(($189+$psize_0)|0);
   var $383=$382;
   HEAP32[(($383)>>2)]=$psize_0;
   var $psize_1 = $psize_0;label = 113; break;
  case 113: 
   var $psize_1;
   var $385=$psize_1 >>> 3;
   var $386=(($psize_1)>>>(0)) < 256;
   if ($386) { label = 114; break; } else { label = 119; break; }
  case 114: 
   var $388=$385 << 1;
   var $389=((7792+($388<<2))|0);
   var $390=$389;
   var $391=HEAP32[((((7752)|0))>>2)];
   var $392=1 << $385;
   var $393=$391 & $392;
   var $394=(($393)|(0))==0;
   if ($394) { label = 115; break; } else { label = 116; break; }
  case 115: 
   var $396=$391 | $392;
   HEAP32[((((7752)|0))>>2)]=$396;
   var $_sum248_pre=((($388)+(2))|0);
   var $_pre=((7792+($_sum248_pre<<2))|0);
   var $F16_0 = $390;var $_pre_phi = $_pre;label = 118; break;
  case 116: 
   var $_sum249=((($388)+(2))|0);
   var $398=((7792+($_sum249<<2))|0);
   var $399=HEAP32[(($398)>>2)];
   var $400=$399;
   var $401=HEAP32[((((7768)|0))>>2)];
   var $402=(($400)>>>(0)) < (($401)>>>(0));
   if ($402) { label = 117; break; } else { var $F16_0 = $399;var $_pre_phi = $398;label = 118; break; }
  case 117: 
   _abort();
   throw "Reached an unreachable!";
  case 118: 
   var $_pre_phi;
   var $F16_0;
   HEAP32[(($_pre_phi)>>2)]=$p_0;
   var $405=(($F16_0+12)|0);
   HEAP32[(($405)>>2)]=$p_0;
   var $406=(($p_0+8)|0);
   HEAP32[(($406)>>2)]=$F16_0;
   var $407=(($p_0+12)|0);
   HEAP32[(($407)>>2)]=$390;
   label = 140; break;
  case 119: 
   var $409=$p_0;
   var $410=$psize_1 >>> 8;
   var $411=(($410)|(0))==0;
   if ($411) { var $I18_0 = 0;label = 122; break; } else { label = 120; break; }
  case 120: 
   var $413=(($psize_1)>>>(0)) > 16777215;
   if ($413) { var $I18_0 = 31;label = 122; break; } else { label = 121; break; }
  case 121: 
   var $415=((($410)+(1048320))|0);
   var $416=$415 >>> 16;
   var $417=$416 & 8;
   var $418=$410 << $417;
   var $419=((($418)+(520192))|0);
   var $420=$419 >>> 16;
   var $421=$420 & 4;
   var $422=$421 | $417;
   var $423=$418 << $421;
   var $424=((($423)+(245760))|0);
   var $425=$424 >>> 16;
   var $426=$425 & 2;
   var $427=$422 | $426;
   var $428=(((14)-($427))|0);
   var $429=$423 << $426;
   var $430=$429 >>> 15;
   var $431=((($428)+($430))|0);
   var $432=$431 << 1;
   var $433=((($431)+(7))|0);
   var $434=$psize_1 >>> (($433)>>>(0));
   var $435=$434 & 1;
   var $436=$435 | $432;
   var $I18_0 = $436;label = 122; break;
  case 122: 
   var $I18_0;
   var $438=((8056+($I18_0<<2))|0);
   var $439=(($p_0+28)|0);
   var $I18_0_c=$I18_0;
   HEAP32[(($439)>>2)]=$I18_0_c;
   var $440=(($p_0+20)|0);
   HEAP32[(($440)>>2)]=0;
   var $441=(($p_0+16)|0);
   HEAP32[(($441)>>2)]=0;
   var $442=HEAP32[((((7756)|0))>>2)];
   var $443=1 << $I18_0;
   var $444=$442 & $443;
   var $445=(($444)|(0))==0;
   if ($445) { label = 123; break; } else { label = 124; break; }
  case 123: 
   var $447=$442 | $443;
   HEAP32[((((7756)|0))>>2)]=$447;
   HEAP32[(($438)>>2)]=$409;
   var $448=(($p_0+24)|0);
   var $_c=$438;
   HEAP32[(($448)>>2)]=$_c;
   var $449=(($p_0+12)|0);
   HEAP32[(($449)>>2)]=$p_0;
   var $450=(($p_0+8)|0);
   HEAP32[(($450)>>2)]=$p_0;
   label = 136; break;
  case 124: 
   var $452=HEAP32[(($438)>>2)];
   var $453=(($I18_0)|(0))==31;
   if ($453) { var $458 = 0;label = 126; break; } else { label = 125; break; }
  case 125: 
   var $455=$I18_0 >>> 1;
   var $456=(((25)-($455))|0);
   var $458 = $456;label = 126; break;
  case 126: 
   var $458;
   var $459=$psize_1 << $458;
   var $K19_0 = $459;var $T_0 = $452;label = 127; break;
  case 127: 
   var $T_0;
   var $K19_0;
   var $461=(($T_0+4)|0);
   var $462=HEAP32[(($461)>>2)];
   var $463=$462 & -8;
   var $464=(($463)|(0))==(($psize_1)|(0));
   if ($464) { label = 132; break; } else { label = 128; break; }
  case 128: 
   var $466=$K19_0 >>> 31;
   var $467=(($T_0+16+($466<<2))|0);
   var $468=HEAP32[(($467)>>2)];
   var $469=(($468)|(0))==0;
   var $470=$K19_0 << 1;
   if ($469) { label = 129; break; } else { var $K19_0 = $470;var $T_0 = $468;label = 127; break; }
  case 129: 
   var $472=$467;
   var $473=HEAP32[((((7768)|0))>>2)];
   var $474=(($472)>>>(0)) < (($473)>>>(0));
   if ($474) { label = 131; break; } else { label = 130; break; }
  case 130: 
   HEAP32[(($467)>>2)]=$409;
   var $476=(($p_0+24)|0);
   var $T_0_c245=$T_0;
   HEAP32[(($476)>>2)]=$T_0_c245;
   var $477=(($p_0+12)|0);
   HEAP32[(($477)>>2)]=$p_0;
   var $478=(($p_0+8)|0);
   HEAP32[(($478)>>2)]=$p_0;
   label = 136; break;
  case 131: 
   _abort();
   throw "Reached an unreachable!";
  case 132: 
   var $481=(($T_0+8)|0);
   var $482=HEAP32[(($481)>>2)];
   var $483=$T_0;
   var $484=HEAP32[((((7768)|0))>>2)];
   var $485=(($483)>>>(0)) < (($484)>>>(0));
   if ($485) { label = 135; break; } else { label = 133; break; }
  case 133: 
   var $487=$482;
   var $488=(($487)>>>(0)) < (($484)>>>(0));
   if ($488) { label = 135; break; } else { label = 134; break; }
  case 134: 
   var $490=(($482+12)|0);
   HEAP32[(($490)>>2)]=$409;
   HEAP32[(($481)>>2)]=$409;
   var $491=(($p_0+8)|0);
   var $_c244=$482;
   HEAP32[(($491)>>2)]=$_c244;
   var $492=(($p_0+12)|0);
   var $T_0_c=$T_0;
   HEAP32[(($492)>>2)]=$T_0_c;
   var $493=(($p_0+24)|0);
   HEAP32[(($493)>>2)]=0;
   label = 136; break;
  case 135: 
   _abort();
   throw "Reached an unreachable!";
  case 136: 
   var $495=HEAP32[((((7784)|0))>>2)];
   var $496=((($495)-(1))|0);
   HEAP32[((((7784)|0))>>2)]=$496;
   var $497=(($496)|(0))==0;
   if ($497) { var $sp_0_in_i = ((8208)|0);label = 137; break; } else { label = 140; break; }
  case 137: 
   var $sp_0_in_i;
   var $sp_0_i=HEAP32[(($sp_0_in_i)>>2)];
   var $498=(($sp_0_i)|(0))==0;
   var $499=(($sp_0_i+8)|0);
   if ($498) { label = 138; break; } else { var $sp_0_in_i = $499;label = 137; break; }
  case 138: 
   HEAP32[((((7784)|0))>>2)]=-1;
   label = 140; break;
  case 139: 
   _abort();
   throw "Reached an unreachable!";
  case 140: 
   return;
  default: assert(0, "bad label: " + label);
 }
}
Module["_free"] = _free;
// EMSCRIPTEN_END_FUNCS
// EMSCRIPTEN_END_FUNCS
// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;
// === Auto-generated postamble setup entry stuff ===
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;
var initialStackTop;
Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');
  args = args || [];
  ensureInitRuntime();
  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);
  initialStackTop = STACKTOP;
  try {
    var ret = Module['_main'](argc, argv, 0);
    // if we're not running an evented main loop, it's time to exit
    if (!Module['noExitRuntime']) {
      exit(ret);
    }
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      throw e;
    }
  }
}
function run(args) {
  args = args || Module['arguments'];
  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return;
  }
  preRun();
  if (runDependencies > 0) {
    // a preRun added a dependency, run will be called later
    return;
  }
  function doRun() {
    ensureInitRuntime();
    preMain();
    calledRun = true;
    if (Module['_main'] && shouldRunNow) {
      Module['callMain'](args);
    }
    postRun();
  }
  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      if (!ABORT) doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;
function exit(status) {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;
  // exit the runtime
  exitRuntime();
  // throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;
function abort(text) {
  if (text) {
    Module.print(text);
  }
  ABORT = true;
  EXITSTATUS = 1;
  throw 'abort() at ' + (new Error().stack);
}
Module['abort'] = Module.abort = abort;
// {{PRE_RUN_ADDITIONS}}
/*global Module*/
/*global _malloc, _free, _memcpy*/
/*global FUNCTION_TABLE, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32*/
/*global readLatin1String*/
/*global __emval_register, _emval_handle_array, __emval_decref*/
/*global ___getTypeName*/
/*jslint sub:true*/ /* The symbols 'fromWireType' and 'toWireType' must be accessed via array notation to be closure-safe since craftInvokerFunction crafts functions as strings that can't be closured. */
var InternalError = Module['InternalError'] = extendError(Error, 'InternalError');
var BindingError = Module['BindingError'] = extendError(Error, 'BindingError');
var UnboundTypeError = Module['UnboundTypeError'] = extendError(BindingError, 'UnboundTypeError');
function throwInternalError(message) {
    throw new InternalError(message);
}
function throwBindingError(message) {
    throw new BindingError(message);
}
function throwUnboundTypeError(message, types) {
    var unboundTypes = [];
    var seen = {};
    function visit(type) {
        if (seen[type]) {
            return;
        }
        if (registeredTypes[type]) {
            return;
        }
        if (typeDependencies[type]) {
            typeDependencies[type].forEach(visit);
            return;
        }
        unboundTypes.push(type);
        seen[type] = true;
    }
    types.forEach(visit);
    throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
}
// Creates a function overload resolution table to the given method 'methodName' in the given prototype,
// if the overload table doesn't yet exist.
function ensureOverloadTable(proto, methodName, humanName) {
    if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];
        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
        proto[methodName] = function() {
            // TODO This check can be removed in -O3 level "unsafe" optimizations.
            if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
            }
            return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };
        // Move the previous function into the overload table.
        proto[methodName].overloadTable = [];
        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
    }            
}
/* Registers a symbol (function, class, enum, ...) as part of the Module JS object so that
   hand-written code is able to access that symbol via 'Module.name'.
   name: The name of the symbol that's being exposed.
   value: The object itself to expose (function, class, ...)
   numArguments: For functions, specifies the number of arguments the function takes in. For other types, unused and undefined.
   To implement support for multiple overloads of a function, an 'overload selector' function is used. That selector function chooses
   the appropriate overload to call from an function overload table. This selector function is only used if multiple overloads are
   actually registered, since it carries a slight performance penalty. */
function exposePublicSymbol(name, value, numArguments) {
    if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
            throwBindingError("Cannot register public name '" + name + "' twice");
        }
        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
        // that routes between the two.
        ensureOverloadTable(Module, name, name);
        if (Module.hasOwnProperty(numArguments)) {
            throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
        }
        // Add the new function into the overload table.
        Module[name].overloadTable[numArguments] = value;
    }
    else {
        Module[name] = value;
        if (undefined !== numArguments) {
            Module[name].numArguments = numArguments;
        }
    }
}
function replacePublicSymbol(name, value, numArguments) {
    if (!Module.hasOwnProperty(name)) {
        throwInternalError('Replacing nonexistant public symbol');
    }
    // If there's an overload table for this symbol, replace the symbol in the overload table instead.
    if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
    }
    else {
        Module[name] = value;
    }
}
// from https://github.com/imvu/imvujs/blob/master/src/error.js
function extendError(baseErrorType, errorName) {
    var errorClass = createNamedFunction(errorName, function(message) {
        this.name = errorName;
        this.message = message;
        var stack = (new Error(message)).stack;
        if (stack !== undefined) {
            this.stack = this.toString() + '\n' +
                stack.replace(/^Error(:[^\n]*)?\n/, '');
        }
    });
    errorClass.prototype = Object.create(baseErrorType.prototype);
    errorClass.prototype.constructor = errorClass;
    errorClass.prototype.toString = function() {
        if (this.message === undefined) {
            return this.name;
        } else {
            return this.name + ': ' + this.message;
        }
    };
    return errorClass;
}
// from https://github.com/imvu/imvujs/blob/master/src/function.js
function createNamedFunction(name, body) {
    name = makeLegalFunctionName(name);
    /*jshint evil:true*/
    return new Function(
        "body",
        "return function " + name + "() {\n" +
        "    \"use strict\";" +
        "    return body.apply(this, arguments);\n" +
        "};\n"
    )(body);
}
function _embind_repr(v) {
    var t = typeof v;
    if (t === 'object' || t === 'array' || t === 'function') {
        return v.toString();
    } else {
        return '' + v;
    }
}
// typeID -> { toWireType: ..., fromWireType: ... }
var registeredTypes = {};
// typeID -> [callback]
var awaitingDependencies = {};
// typeID -> [dependentTypes]
var typeDependencies = {};
// class typeID -> {pointerType: ..., constPointerType: ...}
var registeredPointers = {};
function registerType(rawType, registeredInstance) {
    var name = registeredInstance.name;
    if (!rawType) {
        throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
    }
    if (registeredTypes.hasOwnProperty(rawType)) {
        throwBindingError("Cannot register type '" + name + "' twice");
    }
    registeredTypes[rawType] = registeredInstance;
    delete typeDependencies[rawType];
    if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];
        delete awaitingDependencies[rawType];
        callbacks.forEach(function(cb) {
            cb();
        });
    }
}
function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
    myTypes.forEach(function(type) {
        typeDependencies[type] = dependentTypes;
    });
    function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);
        if (myTypeConverters.length !== myTypes.length) {
            throwInternalError('Mismatched type converter count');
        }
        for (var i = 0; i < myTypes.length; ++i) {
            registerType(myTypes[i], myTypeConverters[i]);
        }
    }
    var typeConverters = new Array(dependentTypes.length);
    var unregisteredTypes = [];
    var registered = 0;
    dependentTypes.forEach(function(dt, i) {
        if (registeredTypes.hasOwnProperty(dt)) {
            typeConverters[i] = registeredTypes[dt];
        } else {
            unregisteredTypes.push(dt);
            if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
            }
            awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                    onComplete(typeConverters);
                }
            });
        }
    });
    if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
    }
}
var __charCodes = (function() {
    var codes = new Array(256);
    for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
    }
    return codes;
})();
function readLatin1String(ptr) {
    var ret = "";
    var c = ptr;
    while (HEAPU8[c]) {
        ret += __charCodes[HEAPU8[c++]];
    }
    return ret;
}
function getTypeName(type) {
    var ptr = ___getTypeName(type);
    var rv = readLatin1String(ptr);
    _free(ptr);
    return rv;
}
function heap32VectorToArray(count, firstElement) {
    var array = [];
    for (var i = 0; i < count; i++) {
        array.push(HEAP32[(firstElement >> 2) + i]);
    }
    return array;
}
function requireRegisteredType(rawType, humanName) {
    var impl = registeredTypes[rawType];
    if (undefined === impl) {
        throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
    }
    return impl;
}
function __embind_register_void(rawType, name) {
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function() {
            return undefined;
        },
        'toWireType': function(destructors, o) {
            // TODO: assert if anything else is given?
            return undefined;
        },
    });
}
function __embind_register_bool(rawType, name, trueValue, falseValue) {
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function(wt) {
            // ambiguous emscripten ABI: sometimes return values are
            // true or false, and sometimes integers (0 or 1)
            return !!wt;
        },
        'toWireType': function(destructors, o) {
            return o ? trueValue : falseValue;
        },
        destructorFunction: null, // This type does not need a destructor
    });
}
// When converting a number from JS to C++ side, the valid range of the number is
// [minRange, maxRange], inclusive.
function __embind_register_integer(primitiveType, name, minRange, maxRange) {
    name = readLatin1String(name);
    if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
        maxRange = 4294967295;
    }
    registerType(primitiveType, {
        name: name,
        minRange: minRange,
        maxRange: maxRange,
        'fromWireType': function(value) {
            return value;
        },
        'toWireType': function(destructors, value) {
            // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
            // avoid the following two if()s and assume value is of proper type.
            if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
                throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');
            }
            return value | 0;
        },
        destructorFunction: null, // This type does not need a destructor
    });
}
function __embind_register_float(rawType, name) {
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function(value) {
            return value;
        },
        'toWireType': function(destructors, value) {
            // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
            // avoid the following if() and assume value is of proper type.
            if (typeof value !== "number" && typeof value !== "boolean") {
                throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
        },
        destructorFunction: null, // This type does not need a destructor
    });
}
function __embind_register_std_string(rawType, name) {
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function(value) {
            var length = HEAPU32[value >> 2];
            var a = new Array(length);
            for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
            }
            _free(value);
            return a.join('');
        },
        'toWireType': function(destructors, value) {
            if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
            }
            function getTAElement(ta, index) {
                return ta[index];
            }
            function getStringElement(string, index) {
                return string.charCodeAt(index);
            }
            var getElement;
            if (value instanceof Uint8Array) {
                getElement = getTAElement;
            } else if (value instanceof Int8Array) {
                getElement = getTAElement;
            } else if (typeof value === 'string') {
                getElement = getStringElement;
            } else {
                throwBindingError('Cannot pass non-string to std::string');
            }
            // assumes 4-byte alignment
            var length = value.length;
            var ptr = _malloc(4 + length);
            HEAPU32[ptr >> 2] = length;
            for (var i = 0; i < length; ++i) {
                var charCode = getElement(value, i);
                if (charCode > 255) {
                    _free(ptr);
                    throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                }
                HEAPU8[ptr + 4 + i] = charCode;
            }
            if (destructors !== null) {
                destructors.push(_free, ptr);
            }
            return ptr;
        },
        destructorFunction: function(ptr) { _free(ptr); },
    });
}
function __embind_register_std_wstring(rawType, charSize, name) {
    name = readLatin1String(name);
    var HEAP, shift;
    if (charSize === 2) {
        HEAP = HEAPU16;
        shift = 1;
    } else if (charSize === 4) {
        HEAP = HEAPU32;
        shift = 2;
    }
    registerType(rawType, {
        name: name,
        'fromWireType': function(value) {
            var length = HEAPU32[value >> 2];
            var a = new Array(length);
            var start = (value + 4) >> shift;
            for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAP[start + i]);
            }
            _free(value);
            return a.join('');
        },
        'toWireType': function(destructors, value) {
            // assumes 4-byte alignment
            var length = value.length;
            var ptr = _malloc(4 + length * charSize);
            HEAPU32[ptr >> 2] = length;
            var start = (ptr + 4) >> shift;
            for (var i = 0; i < length; ++i) {
                HEAP[start + i] = value.charCodeAt(i);
            }
            if (destructors !== null) {
                destructors.push(_free, ptr);
            }
            return ptr;
        },
        destructorFunction: function(ptr) { _free(ptr); },
    });
}
function __embind_register_emval(rawType, name) {
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function(handle) {
            var rv = _emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
        },
        'toWireType': function(destructors, value) {
            return __emval_register(value);
        },
        destructorFunction: null, // This type does not need a destructor
    });
}
function __embind_register_memory_view(rawType, name) {
    var typeMapping = [
        Int8Array,
        Uint8Array,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array,        
    ];
    name = readLatin1String(name);
    registerType(rawType, {
        name: name,
        'fromWireType': function(handle) {
            var type = HEAPU32[handle >> 2];
            var size = HEAPU32[(handle >> 2) + 1]; // in elements
            var data = HEAPU32[(handle >> 2) + 2]; // byte offset into emscripten heap
            var TA = typeMapping[type];
            return new TA(HEAP8.buffer, data, size);
        },
    });
}
function runDestructors(destructors) {
    while (destructors.length) {
        var ptr = destructors.pop();
        var del = destructors.pop();
        del(ptr);
    }
}
// Function implementation of operator new, per
// http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
// 13.2.2
// ES3
function new_(constructor, argumentList) {
    if (!(constructor instanceof Function)) {
        throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
    }
    /*
     * Previously, the following line was just:
     function dummy() {};
     * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the
     * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which
     * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way
     * to write a test for this behavior.  -NRD 2013.02.22
     */
    var dummy = createNamedFunction(constructor.name, function(){});
    dummy.prototype = constructor.prototype;
    var obj = new dummy;
    var r = constructor.apply(obj, argumentList);
    return (r instanceof Object) ? r : obj;
}
// The path to interop from JS code to C++ code:
// (hand-written JS code) -> (autogenerated JS invoker) -> (template-generated C++ invoker) -> (target C++ function)
// craftInvokerFunction generates the JS invoker function for each function exposed to JS through embind.
function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
    // humanName: a human-readable string name for the function to be generated.
    // argTypes: An array that contains the embind type objects for all types in the function signature.
    //    argTypes[0] is the type object for the function return value.
    //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
    //    argTypes[2...] are the actual function parameters.
    // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
    // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
    // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
    var argCount = argTypes.length;
    if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
    }
    var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
    if (!isClassMethodFunc && !FUNCTION_TABLE[cppTargetFunc]) {
        throwBindingError('Global function '+humanName+' is not defined!');
    }
    // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
// TODO: This omits argument count check - enable only at -O3 or similar.
//    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
//       return FUNCTION_TABLE[fn];
//    }
    var argsList = "";
    var argsListWired = "";
    for(var i = 0; i < argCount-2; ++i) {
        argsList += (i!==0?", ":"")+"arg"+i;
        argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
    }
    var invokerFnBody =
        "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
        "if (arguments.length !== "+(argCount - 2)+") {\n" +
            "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
        "}\n";
    // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
    // TODO: Remove this completely once all function invokers are being dynamically generated.
    var needsDestructorStack = false;
    for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
            needsDestructorStack = true;
            break;
        }
    }
    if (needsDestructorStack) {
        invokerFnBody +=
            "var destructors = [];\n";
    }
    var dtorStack = needsDestructorStack ? "destructors" : "null";
    var args1 = ["throwBindingError", "classType", "invoker", "fn", "runDestructors", "retType", "classParam"];
    var args2 = [throwBindingError, classType, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
    if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
    }
    for(var i = 0; i < argCount-2; ++i) {
        invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
        args1.push("argType"+i);
        args2.push(argTypes[i+2]);
    }
    if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
    }
    var returns = (argTypes[0].name !== "void");
    invokerFnBody +=
        (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";
    if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
    } else {
        for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
            var paramName = (i === 1 ? "thisWired" : ("arg"+(i-2)+"Wired"));
            if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
                args1.push(paramName+"_dtor");
                args2.push(argTypes[i].destructorFunction);
            }
        }
    }
    if (returns) {
        invokerFnBody += "return retType.fromWireType(rv);\n";
    }
    invokerFnBody += "}\n";
    args1.push(invokerFnBody);
    var invokerFunction = new_(Function, args1).apply(null, args2);
    return invokerFunction;
}
function __embind_register_function(name, argCount, rawArgTypesAddr, rawInvoker, fn) {
    var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    name = readLatin1String(name);
    rawInvoker = FUNCTION_TABLE[rawInvoker];
    exposePublicSymbol(name, function() {
        throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);
    }, argCount - 1);
    whenDependentTypesAreResolved([], argTypes, function(argTypes) {
        var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
        replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);
        return [];
    });
}
var tupleRegistrations = {};
function __embind_register_value_array(rawType, name, rawConstructor, rawDestructor) {
    tupleRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: FUNCTION_TABLE[rawConstructor],
        rawDestructor: FUNCTION_TABLE[rawDestructor],
        elements: [],
    };
}
function __embind_register_value_array_element(
    rawTupleType,
    getterReturnType,
    getter,
    getterContext,
    setterArgumentType,
    setter,
    setterContext
) {
    tupleRegistrations[rawTupleType].elements.push({
        getterReturnType: getterReturnType,
        getter: FUNCTION_TABLE[getter],
        getterContext: getterContext,
        setterArgumentType: setterArgumentType,
        setter: FUNCTION_TABLE[setter],
        setterContext: setterContext,
    });
}
function __embind_finalize_value_array(rawTupleType) {
    var reg = tupleRegistrations[rawTupleType];
    delete tupleRegistrations[rawTupleType];
    var elements = reg.elements;
    var elementsLength = elements.length;
    var elementTypes = elements.map(function(elt) { return elt.getterReturnType; }).
                concat(elements.map(function(elt) { return elt.setterArgumentType; }));
    var rawConstructor = reg.rawConstructor;
    var rawDestructor = reg.rawDestructor;
    whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes) {
        elements.forEach(function(elt, i) {
            var getterReturnType = elementTypes[i];
            var getter = elt.getter;
            var getterContext = elt.getterContext;
            var setterArgumentType = elementTypes[i + elementsLength];
            var setter = elt.setter;
            var setterContext = elt.setterContext;
            elt.read = function(ptr) {
                return getterReturnType['fromWireType'](getter(getterContext, ptr));
            };
            elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
                runDestructors(destructors);
            };
        });
        return [{
            name: reg.name,
            'fromWireType': function(ptr) {
                var rv = new Array(elementsLength);
                for (var i = 0; i < elementsLength; ++i) {
                    rv[i] = elements[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
            },
            'toWireType': function(destructors, o) {
                if (elementsLength !== o.length) {
                    throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
                }
                var ptr = rawConstructor();
                for (var i = 0; i < elementsLength; ++i) {
                    elements[i].write(ptr, o[i]);
                }
                if (destructors !== null) {
                    destructors.push(rawDestructor, ptr);
                }
                return ptr;
            },
            destructorFunction: rawDestructor,
        }];
    });
}
var structRegistrations = {};
function __embind_register_value_object(
    rawType,
    name,
    rawConstructor,
    rawDestructor
) {
    structRegistrations[rawType] = {
        name: readLatin1String(name),
        rawConstructor: FUNCTION_TABLE[rawConstructor],
        rawDestructor: FUNCTION_TABLE[rawDestructor],
        fields: [],
    };
}
function __embind_register_value_object_field(
    structType,
    fieldName,
    getterReturnType,
    getter,
    getterContext,
    setterArgumentType,
    setter,
    setterContext
) {
    structRegistrations[structType].fields.push({
        fieldName: readLatin1String(fieldName),
        getterReturnType: getterReturnType,
        getter: FUNCTION_TABLE[getter],
        getterContext: getterContext,
        setterArgumentType: setterArgumentType,
        setter: FUNCTION_TABLE[setter],
        setterContext: setterContext,
    });
}
function __embind_finalize_value_object(structType) {
    var reg = structRegistrations[structType];
    delete structRegistrations[structType];
    var rawConstructor = reg.rawConstructor;
    var rawDestructor = reg.rawDestructor;
    var fieldRecords = reg.fields;
    var fieldTypes = fieldRecords.map(function(field) { return field.getterReturnType; }).
              concat(fieldRecords.map(function(field) { return field.setterArgumentType; }));
    whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes) {
        var fields = {};
        fieldRecords.forEach(function(field, i) {
            var fieldName = field.fieldName;
            var getterReturnType = fieldTypes[i];
            var getter = field.getter;
            var getterContext = field.getterContext;
            var setterArgumentType = fieldTypes[i + fieldRecords.length];
            var setter = field.setter;
            var setterContext = field.setterContext;
            fields[fieldName] = {
                read: function(ptr) {
                    return getterReturnType['fromWireType'](
                        getter(getterContext, ptr));
                },
                write: function(ptr, o) {
                    var destructors = [];
                    setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, o));
                    runDestructors(destructors);
                }
            };
        });
        return [{
            name: reg.name,
            'fromWireType': function(ptr) {
                var rv = {};
                for (var i in fields) {
                    rv[i] = fields[i].read(ptr);
                }
                rawDestructor(ptr);
                return rv;
            },
            'toWireType': function(destructors, o) {
                // todo: Here we have an opportunity for -O3 level "unsafe" optimizations:
                // assume all fields are present without checking.
                for (var fieldName in fields) {
                    if (!(fieldName in o)) {
                        throw new TypeError('Missing field');
                    }
                }
                var ptr = rawConstructor();
                for (fieldName in fields) {
                    fields[fieldName].write(ptr, o[fieldName]);
                }
                if (destructors !== null) {
                    destructors.push(rawDestructor, ptr);
                }
                return ptr;
            },
            destructorFunction: rawDestructor,
        }];
    });
}
var genericPointerToWireType = function(destructors, handle) {
    if (handle === null) {
        if (this.isReference) {
            throwBindingError('null is not a valid ' + this.name);
        }
        if (this.isSmartPointer) {
            var ptr = this.rawConstructor();
            if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
            }
            return ptr;
        } else {
            return 0;
        }
    }
    if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
    }
    if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    if (this.isSmartPointer) {
        // TODO: this is not strictly true
        // We could support BY_EMVAL conversions from raw pointers to smart pointers
        // because the smart pointer can hold a reference to the handle
        if (undefined === handle.$$.smartPtr) {
            throwBindingError('Passing raw pointer to smart pointer is illegal');
        }
        switch (this.sharingPolicy) {
            case 0: // NONE
                // no upcasting
                if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                } else {
                    throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
                }
                break;
            case 1: // INTRUSIVE
                ptr = handle.$$.smartPtr;
                break;
            case 2: // BY_EMVAL
                if (handle.$$.smartPtrType === this) {
                    ptr = handle.$$.smartPtr;
                } else {
                    var clonedHandle = handle['clone']();
                    ptr = this.rawShare(
                        ptr,
                        __emval_register(function() {
                            clonedHandle['delete']();
                        })
                    );
                    if (destructors !== null) {
                        destructors.push(this.rawDestructor, ptr);
                    }
                }
                break;
            default:
                throwBindingError('Unsupporting sharing policy');
        }
    }
    return ptr;
};
// If we know a pointer type is not going to have SmartPtr logic in it, we can
// special-case optimize it a bit (compare to genericPointerToWireType)
var constNoSmartPtrRawPointerToWireType = function(destructors, handle) {
    if (handle === null) {
        if (this.isReference) {
            throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
    }
    if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
};
// An optimized version for non-const method accesses - there we must additionally restrict that
// the pointer is not a const-pointer.
var nonConstNoSmartPtrRawPointerToWireType = function(destructors, handle) {
    if (handle === null) {
        if (this.isReference) {
            throwBindingError('null is not a valid ' + this.name);
        }
        return 0;
    }
    if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
    }
    if (!handle.$$.ptr) {
        throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
    }
    if (handle.$$.ptrType.isConst) {
        throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
    }
    var handleClass = handle.$$.ptrType.registeredClass;
    var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
    return ptr;
};
function RegisteredPointer(
    name,
    registeredClass,
    isReference,
    isConst,
    // smart pointer properties
    isSmartPointer,
    pointeeType,
    sharingPolicy,
    rawGetPointee,
    rawConstructor,
    rawShare,
    rawDestructor
) {
    this.name = name;
    this.registeredClass = registeredClass;
    this.isReference = isReference;
    this.isConst = isConst;
    // smart pointer properties
    this.isSmartPointer = isSmartPointer;
    this.pointeeType = pointeeType;
    this.sharingPolicy = sharingPolicy;
    this.rawGetPointee = rawGetPointee;
    this.rawConstructor = rawConstructor;
    this.rawShare = rawShare;
    this.rawDestructor = rawDestructor;
    if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
            this['toWireType'] = constNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
        } else {
            this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
            this.destructorFunction = null;
        }
    } else {
        this['toWireType'] = genericPointerToWireType;
        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in 
        //       craftInvokerFunction altogether.
    }
}
RegisteredPointer.prototype.getPointee = function(ptr) {
    if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
    }
    return ptr;
};
RegisteredPointer.prototype.destructor = function(ptr) {
    if (this.rawDestructor) {
        this.rawDestructor(ptr);
    }
};
RegisteredPointer.prototype['fromWireType'] = function(ptr) {
    // ptr is a raw pointer (or a raw smartpointer)
    // rawPointer is a maybe-null raw pointer
    var rawPointer = this.getPointee(ptr);
    if (!rawPointer) {
        this.destructor(ptr);
        return null;
    }
    function makeDefaultHandle() {
        if (this.isSmartPointer) {
            return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this.pointeeType,
                ptr: rawPointer,
                smartPtrType: this,
                smartPtr: ptr,
            });
        } else {
            return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this,
                ptr: ptr,
            });
        }
    }
    var actualType = this.registeredClass.getActualType(rawPointer);
    var registeredPointerRecord = registeredPointers[actualType];
    if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
    }
    var toType;
    if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
    } else {
        toType = registeredPointerRecord.pointerType;
    }
    var dp = downcastPointer(
        rawPointer,
        this.registeredClass,
        toType.registeredClass);
    if (dp === null) {
        return makeDefaultHandle.call(this);
    }
    if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
            ptrType: toType,
            ptr: dp,
            smartPtrType: this,
            smartPtr: ptr,
        });
    } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, {
            ptrType: toType,
            ptr: dp,
        });
    }
};
function makeClassHandle(prototype, record) {
    if (!record.ptrType || !record.ptr) {
        throwInternalError('makeClassHandle requires ptr and ptrType');
    }
    var hasSmartPtrType = !!record.smartPtrType;
    var hasSmartPtr = !!record.smartPtr;
    if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError('Both smartPtrType and smartPtr must be specified');
    }
    record.count = { value: 1 };
    return Object.create(prototype, {
        $$: {
            value: record,
        },
    });
}
// root of all pointer and smart pointer handles in embind
function ClassHandle() {
}
function getInstanceTypeName(handle) {
    return handle.$$.ptrType.registeredClass.name;
}
ClassHandle.prototype['isAliasOf'] = function(other) {
    if (!(this instanceof ClassHandle)) {
        return false;
    }
    if (!(other instanceof ClassHandle)) {
        return false;
    }
    var leftClass = this.$$.ptrType.registeredClass;
    var left = this.$$.ptr;
    var rightClass = other.$$.ptrType.registeredClass;
    var right = other.$$.ptr;
    while (leftClass.baseClass) {
        left = leftClass.upcast(left);
        leftClass = leftClass.baseClass;
    }
    while (rightClass.baseClass) {
        right = rightClass.upcast(right);
        rightClass = rightClass.baseClass;
    }
    return leftClass === rightClass && left === right;
};
function throwInstanceAlreadyDeleted(obj) {
    throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
}
ClassHandle.prototype['clone'] = function() {
    if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
    }
    var clone = Object.create(Object.getPrototypeOf(this), {
        $$: {
            value: shallowCopy(this.$$),
        }
    });
    clone.$$.count.value += 1;
    return clone;
};
function runDestructor(handle) {
    var $$ = handle.$$;
    if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
    } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
    }
}
ClassHandle.prototype['delete'] = function ClassHandle_delete() {
    if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
    }
    if (this.$$.deleteScheduled) {
        throwBindingError('Object already scheduled for deletion');
    }
    this.$$.count.value -= 1;
    if (0 === this.$$.count.value) {
        runDestructor(this);
    }
    this.$$.smartPtr = undefined;
    this.$$.ptr = undefined;
};
var deletionQueue = [];
ClassHandle.prototype['isDeleted'] = function isDeleted() {
    return !this.$$.ptr;
};
ClassHandle.prototype['deleteLater'] = function deleteLater() {
    if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
    }
    if (this.$$.deleteScheduled) {
        throwBindingError('Object already scheduled for deletion');
    }
    deletionQueue.push(this);
    if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
    }
    this.$$.deleteScheduled = true;
    return this;
};
function flushPendingDeletes() {
    while (deletionQueue.length) {
        var obj = deletionQueue.pop();
        obj.$$.deleteScheduled = false;
        obj['delete']();
    }
}
Module['flushPendingDeletes'] = flushPendingDeletes;
var delayFunction;
Module['setDelayFunction'] = function setDelayFunction(fn) {
    delayFunction = fn;
    if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
    }
};
function RegisteredClass(
    name,
    constructor,
    instancePrototype,
    rawDestructor,
    baseClass,
    getActualType,
    upcast,
    downcast
) {
    this.name = name;
    this.constructor = constructor;
    this.instancePrototype = instancePrototype;
    this.rawDestructor = rawDestructor;
    this.baseClass = baseClass;
    this.getActualType = getActualType;
    this.upcast = upcast;
    this.downcast = downcast;
}
function shallowCopy(o) {
    var rv = {};
    for (var k in o) {
        rv[k] = o[k];
    }
    return rv;
}
function __embind_register_class(
    rawType,
    rawPointerType,
    rawConstPointerType,
    baseClassRawType,
    getActualType,
    upcast,
    downcast,
    name,
    rawDestructor
) {
    name = readLatin1String(name);
    rawDestructor = FUNCTION_TABLE[rawDestructor];
    getActualType = FUNCTION_TABLE[getActualType];
    upcast = FUNCTION_TABLE[upcast];
    downcast = FUNCTION_TABLE[downcast];
    var legalFunctionName = makeLegalFunctionName(name);
    exposePublicSymbol(legalFunctionName, function() {
        // this code cannot run if baseClassRawType is zero
        throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
    });
    whenDependentTypesAreResolved(
        [rawType, rawPointerType, rawConstPointerType],
        baseClassRawType ? [baseClassRawType] : [],
        function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
            } else {
                basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                    throw new BindingError("Use 'new' to construct " + name);
                }
                if (undefined === registeredClass.constructor_body) {
                    throw new BindingError(name + " has no accessible constructor");
                }
                var body = registeredClass.constructor_body[arguments.length];
                if (undefined === body) {
                    throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                }
                return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, {
                constructor: { value: constructor },
            });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(
                name,
                constructor,
                instancePrototype,
                rawDestructor,
                baseClass,
                getActualType,
                upcast,
                downcast);
            var referenceConverter = new RegisteredPointer(
                name,
                registeredClass,
                true,
                false,
                false);
            var pointerConverter = new RegisteredPointer(
                name + '*',
                registeredClass,
                false,
                false,
                false);
            var constPointerConverter = new RegisteredPointer(
                name + ' const*',
                registeredClass,
                false,
                true,
                false);
            registeredPointers[rawType] = {
                pointerType: pointerConverter,
                constPointerType: constPointerConverter
            };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
        }
    );
}
function __embind_register_class_constructor(
    rawClassType,
    argCount,
    rawArgTypesAddr,
    invoker,
    rawConstructor
) {
    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    invoker = FUNCTION_TABLE[invoker];
    whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = 'constructor ' + classType.name;
        if (undefined === classType.registeredClass.constructor_body) {
            classType.registeredClass.constructor_body = [];
        }
        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
            throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        }
        classType.registeredClass.constructor_body[argCount - 1] = function() {
            throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
        };
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            classType.registeredClass.constructor_body[argCount - 1] = function() {
                if (arguments.length !== argCount - 1) {
                    throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount-1));
                }
                var destructors = [];
                var args = new Array(argCount);
                args[0] = rawConstructor;
                for (var i = 1; i < argCount; ++i) {
                    args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]['fromWireType'](ptr);
            };
            return [];
        });
        return [];
    });
}
function downcastPointer(ptr, ptrClass, desiredClass) {
    if (ptrClass === desiredClass) {
        return ptr;
    }
    if (undefined === desiredClass.baseClass) {
        return null; // no conversion
    }
    // O(depth) stack space used
    return desiredClass.downcast(
        downcastPointer(ptr, ptrClass, desiredClass.baseClass));
}
function upcastPointer(ptr, ptrClass, desiredClass) {
    while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
            throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
        }
        ptr = ptrClass.upcast(ptr);
        ptrClass = ptrClass.baseClass;
    }
    return ptr;
}
function validateThis(this_, classType, humanName) {
    if (!(this_ instanceof Object)) {
        throwBindingError(humanName + ' with invalid "this": ' + this_);
    }
    if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
    }
    if (!this_.$$.ptr) {
        throwBindingError('cannot call emscripten binding method ' + humanName + ' on deleted object');
    }
    // todo: kill this
    return upcastPointer(
        this_.$$.ptr,
        this_.$$.ptrType.registeredClass,
        classType.registeredClass);
}
function __embind_register_class_function(
    rawClassType,
    methodName,
    argCount,
    rawArgTypesAddr, // [ReturnType, ThisType, Args...]
    rawInvoker,
    context
) {
    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    methodName = readLatin1String(methodName);
    rawInvoker = FUNCTION_TABLE[rawInvoker];
    whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
        var unboundTypesHandler = function() {
            throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
        };
        var proto = classType.registeredClass.instancePrototype;
        var method = proto[methodName];
        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount-2)) {
            // This is the first overload to be registered, OR we are replacing a function in the base class with a function in the derived class.
            unboundTypesHandler.argCount = argCount-2;
            unboundTypesHandler.className = classType.name;
            proto[methodName] = unboundTypesHandler;
        } else {
            // There was an existing function with the same name registered. Set up a function overload routing table.
            ensureOverloadTable(proto, methodName, humanName);
            proto[methodName].overloadTable[argCount-2] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
            // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
            // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
            if (undefined === proto[methodName].overloadTable) {
                proto[methodName] = memberFunction;
            } else {
                proto[methodName].overloadTable[argCount-2] = memberFunction;
            }
            return [];
        });
        return [];
    });
}
function __embind_register_class_class_function(
    rawClassType,
    methodName,
    argCount,
    rawArgTypesAddr,
    rawInvoker,
    fn
) {
    var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
    methodName = readLatin1String(methodName);
    rawInvoker = FUNCTION_TABLE[rawInvoker];
    whenDependentTypesAreResolved([], [rawClassType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + methodName;
        var unboundTypesHandler = function() {
                throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
            };
        var proto = classType.registeredClass.constructor;
        if (undefined === proto[methodName]) {
            // This is the first function to be registered with this name.
            unboundTypesHandler.argCount = argCount-1;
            proto[methodName] = unboundTypesHandler;
        } else {
            // There was an existing function with the same name registered. Set up a function overload routing table.
            ensureOverloadTable(proto, methodName, humanName);
            proto[methodName].overloadTable[argCount-1] = unboundTypesHandler;
        }
        whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
            // Replace the initial unbound-types-handler stub with the proper function. If multiple overloads are registered,
            // the function handlers go into an overload table.
            var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
            var func = craftInvokerFunction(humanName, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn);
            if (undefined === proto[methodName].overloadTable) {
                proto[methodName] = func;
            } else {
                proto[methodName].overloadTable[argCount-1] = func;
            }
            return [];
        });
        return [];
    });
}
function __embind_register_class_property(
    classType,
    fieldName,
    getterReturnType,
    getter,
    getterContext,
    setterArgumentType,
    setter,
    setterContext
) {
    fieldName = readLatin1String(fieldName);
    getter = FUNCTION_TABLE[getter];
    whenDependentTypesAreResolved([], [classType], function(classType) {
        classType = classType[0];
        var humanName = classType.name + '.' + fieldName;
        var desc = {
            get: function() {
                throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
            },
            enumerable: true,
            configurable: true
        };
        if (setter) {
            desc.set = function() {
                throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
            };
        } else {
            desc.set = function(v) {
                throwBindingError(humanName + ' is a read-only property');
            };
        }
        Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
        whenDependentTypesAreResolved(
            [],
            (setter ? [getterReturnType, setterArgumentType] : [getterReturnType]),
        function(types) {
            var getterReturnType = types[0];
            var desc = {
                get: function() {
                    var ptr = validateThis(this, classType, humanName + ' getter');
                    return getterReturnType['fromWireType'](getter(getterContext, ptr));
                },
                enumerable: true
            };
            if (setter) {
                setter = FUNCTION_TABLE[setter];
                var setterArgumentType = types[1];
                desc.set = function(v) {
                    var ptr = validateThis(this, classType, humanName + ' setter');
                    var destructors = [];
                    setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
                    runDestructors(destructors);
                };
            }
            Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
            return [];
        });
        return [];
    });
}
var char_0 = '0'.charCodeAt(0);
var char_9 = '9'.charCodeAt(0);
function makeLegalFunctionName(name) {
    name = name.replace(/[^a-zA-Z0-9_]/g, '$');
    var f = name.charCodeAt(0);
    if (f >= char_0 && f <= char_9) {
        return '_' + name;
    } else {
        return name;
    }
}
function __embind_register_smart_ptr(
    rawType,
    rawPointeeType,
    name,
    sharingPolicy,
    rawGetPointee,
    rawConstructor,
    rawShare,
    rawDestructor
) {
    name = readLatin1String(name);
    rawGetPointee = FUNCTION_TABLE[rawGetPointee];
    rawConstructor = FUNCTION_TABLE[rawConstructor];
    rawShare = FUNCTION_TABLE[rawShare];
    rawDestructor = FUNCTION_TABLE[rawDestructor];
    whenDependentTypesAreResolved([rawType], [rawPointeeType], function(pointeeType) {
        pointeeType = pointeeType[0];
        var registeredPointer = new RegisteredPointer(
            name,
            pointeeType.registeredClass,
            false,
            false,
            // smart pointer properties
            true,
            pointeeType,
            sharingPolicy,
            rawGetPointee,
            rawConstructor,
            rawShare,
            rawDestructor);
        return [registeredPointer];
    });
}
function __embind_register_enum(
    rawType,
    name
) {
    name = readLatin1String(name);
    function constructor() {
    }
    constructor.values = {};
    registerType(rawType, {
        name: name,
        constructor: constructor,
        'fromWireType': function(c) {
            return this.constructor.values[c];
        },
        'toWireType': function(destructors, c) {
            return c.value;
        },
        destructorFunction: null,
    });
    exposePublicSymbol(name, constructor);
}
function __embind_register_enum_value(
    rawEnumType,
    name,
    enumValue
) {
    var enumType = requireRegisteredType(rawEnumType, 'enum');
    name = readLatin1String(name);
    var Enum = enumType.constructor;
    var Value = Object.create(enumType.constructor.prototype, {
        value: {value: enumValue},
        constructor: {value: createNamedFunction(enumType.name + '_' + name, function() {})},
    });
    Enum.values[enumValue] = Value;
    Enum[name] = Value;
}
function __embind_register_constant(name, type, value) {
    name = readLatin1String(name);
    whenDependentTypesAreResolved([], [type], function(type) {
        type = type[0];
        Module[name] = type['fromWireType'](value);
        return [];
    });
}
/*global Module:true, Runtime*/
/*global HEAP32*/
/*global new_*/
/*global createNamedFunction*/
/*global readLatin1String, writeStringToMemory*/
/*global requireRegisteredType, throwBindingError*/
/*jslint sub:true*/ /* The symbols 'fromWireType' and 'toWireType' must be accessed via array notation to be closure-safe since craftInvokerFunction crafts functions as strings that can't be closured. */
var Module = Module || {};
var _emval_handle_array = [{}]; // reserve zero
var _emval_free_list = [];
// Public JS API
/** @expose */
Module.count_emval_handles = function() {
    var count = 0;
    for (var i = 1; i < _emval_handle_array.length; ++i) {
        if (_emval_handle_array[i] !== undefined) {
            ++count;
        }
    }
    return count;
};
/** @expose */
Module.get_first_emval = function() {
    for (var i = 1; i < _emval_handle_array.length; ++i) {
        if (_emval_handle_array[i] !== undefined) {
            return _emval_handle_array[i];
        }
    }
    return null;
};
// Private C++ API
var _emval_symbols = {}; // address -> string
function __emval_register_symbol(address) {
    _emval_symbols[address] = readLatin1String(address);
}
function getStringOrSymbol(address) {
    var symbol = _emval_symbols[address];
    if (symbol === undefined) {
        return readLatin1String(address);
    } else {
        return symbol;
    }
}
function requireHandle(handle) {
    if (!handle) {
        throwBindingError('Cannot use deleted val. handle = ' + handle);
    }
}
function __emval_register(value) {
    var handle = _emval_free_list.length ?
        _emval_free_list.pop() :
        _emval_handle_array.length;
    _emval_handle_array[handle] = {refcount: 1, value: value};
    return handle;
}
function __emval_incref(handle) {
    if (handle) {
        _emval_handle_array[handle].refcount += 1;
    }
}
function __emval_decref(handle) {
    if (handle && 0 === --_emval_handle_array[handle].refcount) {
        _emval_handle_array[handle] = undefined;
        _emval_free_list.push(handle);
    }
}
function __emval_new_array() {
    return __emval_register([]);
}
function __emval_new_object() {
    return __emval_register({});
}
function __emval_undefined() {
    return __emval_register(undefined);
}
function __emval_null() {
    return __emval_register(null);
}
function __emval_new_cstring(v) {
    return __emval_register(getStringOrSymbol(v));
}
function __emval_take_value(type, v) {
    type = requireRegisteredType(type, '_emval_take_value');
    v = type['fromWireType'](v);
    return __emval_register(v);
}
var __newers = {}; // arity -> function
function craftEmvalAllocator(argCount) {
    /*This function returns a new function that looks like this:
    function emval_allocator_3(handle, argTypes, arg0Wired, arg1Wired, arg2Wired) {
        var argType0 = requireRegisteredType(HEAP32[(argTypes >> 2)], "parameter 0");
        var arg0 = argType0.fromWireType(arg0Wired);
        var argType1 = requireRegisteredType(HEAP32[(argTypes >> 2) + 1], "parameter 1");
        var arg1 = argType1.fromWireType(arg1Wired);
        var argType2 = requireRegisteredType(HEAP32[(argTypes >> 2) + 2], "parameter 2");
        var arg2 = argType2.fromWireType(arg2Wired);
        var constructor = _emval_handle_array[handle].value;
        var emval = new constructor(arg0, arg1, arg2);
        return emval;
    } */
    var args1 = ["requireRegisteredType", "HEAP32", "_emval_handle_array", "__emval_register"];
    var args2 = [requireRegisteredType, HEAP32, _emval_handle_array, __emval_register];
    var argsList = "";
    var argsListWired = "";
    for(var i = 0; i < argCount; ++i) {
        argsList += (i!==0?", ":"")+"arg"+i; // 'arg0, arg1, ..., argn'
        argsListWired += ", arg"+i+"Wired"; // ', arg0Wired, arg1Wired, ..., argnWired'
    }
    var invokerFnBody =
        "return function emval_allocator_"+argCount+"(handle, argTypes " + argsListWired + ") {\n";
    for(var i = 0; i < argCount; ++i) {
        invokerFnBody += 
            "var argType"+i+" = requireRegisteredType(HEAP32[(argTypes >> 2) + "+i+"], \"parameter "+i+"\");\n" +
            "var arg"+i+" = argType"+i+".fromWireType(arg"+i+"Wired);\n";
    }
    invokerFnBody +=
        "var constructor = _emval_handle_array[handle].value;\n" +
        "var obj = new constructor("+argsList+");\n" +
        "return __emval_register(obj);\n" +
        "}\n";
    args1.push(invokerFnBody);
    var invokerFunction = new_(Function, args1).apply(null, args2);
    return invokerFunction;
}
function __emval_new(handle, argCount, argTypes) {
    requireHandle(handle);
    var newer = __newers[argCount];
    if (!newer) {
        newer = craftEmvalAllocator(argCount);
        __newers[argCount] = newer;
    }
    if (argCount === 0) {
        return newer(handle, argTypes);
    } else if (argCount === 1) {
        return newer(handle, argTypes, arguments[3]);
    } else if (argCount === 2) {
        return newer(handle, argTypes, arguments[3], arguments[4]);
    } else if (argCount === 3) {
        return newer(handle, argTypes, arguments[3], arguments[4], arguments[5]);
    } else if (argCount === 4) {
        return newer(handle, argTypes, arguments[3], arguments[4], arguments[5], arguments[6]);
    } else {
        // This is a slow path! (.apply and .splice are slow), so a few specializations are present above.
        return newer.apply(null, arguments.splice(1));
    }
}
// appease jshint (technically this code uses eval)
var global = (function(){return Function;})()('return this')();
function __emval_get_global(name) {
    name = getStringOrSymbol(name);
    return __emval_register(global[name]);
}
function __emval_get_module_property(name) {
    name = getStringOrSymbol(name);
    return __emval_register(Module[name]);
}
function __emval_get_property(handle, key) {
    requireHandle(handle);
    return __emval_register(_emval_handle_array[handle].value[_emval_handle_array[key].value]);
}
function __emval_set_property(handle, key, value) {
    requireHandle(handle);
    _emval_handle_array[handle].value[_emval_handle_array[key].value] = _emval_handle_array[value].value;
}
function __emval_as(handle, returnType) {
    requireHandle(handle);
    returnType = requireRegisteredType(returnType, 'emval::as');
    var destructors = [];
    // caller owns destructing
    return returnType['toWireType'](destructors, _emval_handle_array[handle].value);
}
function parseParameters(argCount, argTypes, argWireTypes) {
    var a = new Array(argCount);
    for (var i = 0; i < argCount; ++i) {
        var argType = requireRegisteredType(
            HEAP32[(argTypes >> 2) + i],
            "parameter " + i);
        a[i] = argType['fromWireType'](argWireTypes[i]);
    }
    return a;
}
function __emval_call(handle, argCount, argTypes) {
    requireHandle(handle);
    var types = lookupTypes(argCount, argTypes);
    var args = new Array(argCount);
    for (var i = 0; i < argCount; ++i) {
        args[i] = types[i]['fromWireType'](arguments[3 + i]);
    }
    var fn = _emval_handle_array[handle].value;
    var rv = fn.apply(undefined, args);
    return __emval_register(rv);
}
function lookupTypes(argCount, argTypes, argWireTypes) {
    var a = new Array(argCount);
    for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(
            HEAP32[(argTypes >> 2) + i],
            "parameter " + i);
    }
    return a;
}
function __emval_get_method_caller(argCount, argTypes) {
    var types = lookupTypes(argCount, argTypes);
    var retType = types[0];
    var signatureName = retType.name + "_$" + types.slice(1).map(function (t) { return t.name; }).join("_") + "$";
    var args1 = ["addFunction", "createNamedFunction", "requireHandle", "getStringOrSymbol", "_emval_handle_array", "retType"];
    var args2 = [Runtime.addFunction, createNamedFunction, requireHandle, getStringOrSymbol, _emval_handle_array, retType];
    var argsList = ""; // 'arg0, arg1, arg2, ... , argN'
    var argsListWired = ""; // 'arg0Wired, ..., argNWired'
    for (var i = 0; i < argCount - 1; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;
        argsListWired += ", arg" + i + "Wired";
        args1.push("argType" + i);
        args2.push(types[1 + i]);
    }
    var invokerFnBody =
        "return addFunction(createNamedFunction('" + signatureName + "', function (handle, name" + argsListWired + ") {\n" +
        "requireHandle(handle);\n" +
        "name = getStringOrSymbol(name);\n";
    for (var i = 0; i < argCount - 1; ++i) {
        invokerFnBody += "var arg" + i + " = argType" + i + ".fromWireType(arg" + i + "Wired);\n";
    }
    invokerFnBody +=
        "var obj = _emval_handle_array[handle].value;\n" +
        "return retType.toWireType(null, obj[name](" + argsList + "));\n" + 
        "}));\n";
    args1.push(invokerFnBody);
    var invokerFunction = new_(Function, args1).apply(null, args2);
    return invokerFunction;
}
function __emval_has_function(handle, name) {
    name = getStringOrSymbol(name);
    return _emval_handle_array[handle].value[name] instanceof Function;
}
(function() {
function assert(check, msg) {
  if (!check) throw msg + new Error().stack;
}
Module['FS_createPath']('/', 'meshes', true, true);
    function DataRequest() {}
    DataRequest.prototype = {
      requests: {},
      open: function(mode, name) {
        this.requests[name] = this;
      },
      send: function() {}
    };
    var filePreload0 = new DataRequest();
    filePreload0.open('GET', '/meshes/nav_test.obj', true);
    filePreload0.responseType = 'arraybuffer';
    filePreload0.onload = function() {
      var arrayBuffer = filePreload0.response;
      assert(arrayBuffer, 'Loading file /meshes/nav_test.obj failed.');
      var byteArray = !arrayBuffer.subarray ? new Uint8Array(arrayBuffer) : arrayBuffer;
      Module['FS_createPreloadedFile']('/meshes', 'nav_test.obj', byteArray, true, true, function() {
        Module['removeRunDependency']('fp /meshes/nav_test.obj');
      });
    };
    Module['addRunDependency']('fp /meshes/nav_test.obj');
    filePreload0.send(null);
    if (!Module.expectedDataFileDownloads) {
      Module.expectedDataFileDownloads = 0;
      Module.finishedDataFileDownloads = 0;
    }
    Module.expectedDataFileDownloads++;
    var PACKAGE_PATH = window['encodeURIComponent'](window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf('/')) + '/');
    var PACKAGE_NAME = 'build/recast.emcc.data';
    var REMOTE_PACKAGE_NAME = 'recast.emcc.data';
    var PACKAGE_UUID = '4ba71bbf-0ce6-462e-86db-6f94b693e167';
    function fetchRemotePackage(packageName, callback, errback) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', packageName, true);
      xhr.responseType = 'arraybuffer';
      xhr.onprogress = function(event) {
        var url = packageName;
        if (event.loaded && event.total) {
          if (!xhr.addedTotal) {
            xhr.addedTotal = true;
            if (!Module.dataFileDownloads) Module.dataFileDownloads = {};
            Module.dataFileDownloads[url] = {
              loaded: event.loaded,
              total: event.total
            };
          } else {
            Module.dataFileDownloads[url].loaded = event.loaded;
          }
          var total = 0;
          var loaded = 0;
          var num = 0;
          for (var download in Module.dataFileDownloads) {
          var data = Module.dataFileDownloads[download];
            total += data.total;
            loaded += data.loaded;
            num++;
          }
          total = Math.ceil(total * Module.expectedDataFileDownloads/num);
          Module['setStatus']('Downloading data... (' + loaded + '/' + total + ')');
        } else if (!Module.dataFileDownloads) {
          Module['setStatus']('Downloading data...');
        }
      };
      xhr.onload = function(event) {
        var packageData = xhr.response;
        callback(packageData);
      };
      xhr.send(null);
    };
    function processPackageData(arrayBuffer) {
      Module.finishedDataFileDownloads++;
      assert(arrayBuffer, 'Loading data file failed.');
      var byteArray = new Uint8Array(arrayBuffer);
      var curr;
        curr = DataRequest.prototype.requests['/meshes/nav_test.obj'];
        var data = byteArray.subarray(0, 115059);
        var ptr = Module['_malloc'](115059);
        Module['HEAPU8'].set(data, ptr);
        curr.response = Module['HEAPU8'].subarray(ptr, ptr + 115059);
        curr.onload();
                Module['removeRunDependency']('datafile_build/recast.emcc.data');
    };
    Module['addRunDependency']('datafile_build/recast.emcc.data');
    function handleError(error) {
      console.error('package error:', error);
    };
    if (!Module.preloadResults)
      Module.preloadResults = {};
      Module.preloadResults[PACKAGE_NAME] = {fromCache: false};
      fetchRemotePackage(REMOTE_PACKAGE_NAME, processPackageData, handleError);
})();
if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}
// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}
run();
// {{POST_RUN_ADDITIONS}}
// {{MODULE_ADDITIONS}}
//@ sourceMappingURL=recast.emcc.js.map